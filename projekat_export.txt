FILE: gradle.properties

# Project-wide Gradle settings.

# Specifies the JVM arguments used for the daemon process.
//org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8

# AndroidX package structure
android.useAndroidX=true

# Kotlin code style for this project
kotlin.code.style=official

# Enables namespacing of each library's R class
android.nonTransitiveRClass=true

# Kotlin daemon
kotlin.daemon.enabled=false

# MapLibre Configuration
MAPBOX_DOWNLOADS_TOKEN=pk.eyJ1Ijoiam9jYW5lZCIsImEiOiJjbWkydzYxengxZHYwMmxxenBhN3B4Z240In0.qHFIOex_C8uT_OrELXO0Mw
MAPLIBRE_ACCESS_TOKEN=

# Android Configuration
android.enableJetifier=true
android.jetifier.ignorelist=bcprov-jdk15on
android.suppressUnsupportedCompileSdk=34

# KAPT Configuration
kapt.use.worker.api=true
kapt.incremental.apt=true
kapt.include.compile.classpath=false

# Gradle Performance
org.gradle.parallel=true
org.gradle.caching=true
org.gradle.configureondemand=true

# Kotlin Configuration
kotlin.mpp.stability.nowarn=true
kotlin.incremental.js.ir=true

# Build Configuration
android.defaults.buildfeatures.buildconfig=true

org.gradle.jvmargs=--add-exports=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED \
--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED \
--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED \
--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED \
--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED


kotlin.native.ignoreDisabledTargets=true

kotlin.daemon.jvm.options=-Xmx2048m


FILE: README.md

# gps_tracker_ds
Stabilan_Build_06.11.2025

# GPS Tracker DS

**Stabilna Android aplikacija za praæenje lokacije, upravljanje rutama i deljenje taèaka u realnom vremenu.**

## ?? Funkcionalnosti

- ?? Login i registracija korisnika
- ??? Prikaz mape sa trenutnom lokacijom (OpenStreetMap)
- ?? Dodavanje, ureðivanje i brisanje taèaka
- ?? Snimanje i brisanje ruta
- ?? Izvoz ruta u deljiv format
- ?? Praæenje drugog ureðaja u realnom vremenu
- ?? Zoom na trenutnu lokaciju klikom na dugme "Moja lokacija"

## ?? Tehnologije

- **Kotlin + Jetpack Compose**
- **Room Database** za lokalno skladištenje
- **OpenStreetMap** integracija
- **MVVM arhitektura** sa modularnim pristupom
- **Gradle** build sistem (klasièni `.gradle` fajlovi)


## ?? Inspiracija

Aplikacija je vizuelno i funkcionalno inspirisana iCar GPS aplikacijom, sa fokusom na modularnost, stabilnost i edukativnu vrednost za buduæe generacije studenata.

## ????? Autor

Jovan Nedeljkoviæ — student, istraživaè i praktièar koji kombinuje preciznost, vizuelnu jasnoæu i edukativni pristup u svakom projektu.

---
## ZIP struktura

gps_tracker_ds/
+¦¦ .gitignore
+¦¦ README.md
+¦¦ build.gradle
+¦¦ gradle.properties
+¦¦ gradlew
+¦¦ gradlew.bat
+¦¦ settings.gradle.kts
+¦¦ gradle/
-   L¦¦ wrapper/
-       +¦¦ gradle-wrapper.jar
-       L¦¦ gradle-wrapper.properties
+¦¦ .idea/
-   +¦¦ codeStyles/
-   +¦¦ libraries/
-   +¦¦ vcs.xml
-   +¦¦ misc.xml
-   +¦¦ modules.xml
-   +¦¦ workspace.xml
-   L¦¦ ...
L¦¦ app/
    +¦¦ build.gradle
    +¦¦ proguard-rules.pro
    L¦¦ src/
        L¦¦ main/
            +¦¦ AndroidManifest.xml
            +¦¦ java/
            -   L¦¦ com/
            -       L¦¦ jovannedeljkovicatvss/
            -           L¦¦ gps_tracker_ds/
            -               +¦¦ MainActivity.kt
            -               +¦¦ data/
            -               -   +¦¦ model/
            -               -   -   L¦¦ User.kt
            -               -   L¦¦ repository/
            -               -       L¦¦ LocationRepository.kt
            -               +¦¦ domain/
            -               -   L¦¦ usecase/
            -               -       L¦¦ TrackLocationUseCase.kt
            -               +¦¦ ui/
            -               -   +¦¦ login/
            -               -   -   L¦¦ LoginScreen.kt
            -               -   +¦¦ map/
            -               -   -   L¦¦ MapScreen.kt
            -               -   L¦¦ components/
            -               -       L¦¦ LocationButton.kt
            -               +¦¦ util/
            -               -   L¦¦ LocationUtils.kt
            -               L¦¦ navigation/
            -                   L¦¦ AppNavigation.kt
            L¦¦ res/
                +¦¦ layout/
                -   L¦¦ activity_main.xml
                +¦¦ values/
                -   +¦¦ colors.xml
                -   +¦¦ strings.xml
                -   L¦¦ themes.xml
                L¦¦ drawable/
                    L¦¦ ic_location.xml




FILE: app\proguard-rules.pro

# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile


FILE: app\src\androidTest\java\jovannedeljkovic\gps_tracker_pro\ExampleInstrumentedTest.kt

package jovannedeljkovic.gps_tracker_pro

import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
        assertEquals("jovannedeljkovic.gps_tracker_ds", appContext.packageName)
    }
}


FILE: app\src\main\AndroidManifest.xml

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Permisije - BEZ DUPLIKATA -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"
        tools:ignore="ScopedStorage" />



    <!-- Za Android 10+ -->
    <uses-permission android:name="android.permission.ACCESS_MEDIA_LOCATION" />

    <application
        android:name=".App"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/Theme.AppCompat.Light"
        android:usesCleartextTraffic="true"
        android:networkSecurityConfig="@xml/network_security_config"
        tools:targetApi="31">

        <!-- File Provider za deljenje fajlova -->
        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>

        <!-- Login kao LAUNCHER -->
        <activity
            android:name=".ui.auth.LoginActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity android:name=".ui.auth.RegisterActivity" />
        <activity android:name=".ui.main.MainActivity" />
        <activity android:name=".ui.admin.AdminActivity" />

        <!-- HERE Maps API Key -->
        <meta-data
            android:name="com.here.sdk.access_key_id"
            android:value="fmb3TiJmJUp9sUlGRVntRw" />
        <meta-data
            android:name="com.here.sdk.access_key_secret"
            android:value="sv3x71M0o0Ogn2YylHL2axXZ6rUNW5TXZsAfQVpoItFGF56dnYqtjqAiukFcUYo1N67cbtjfLgIwN00rKFdc0w" />

        <service
            android:name=".service.TrackingService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="location"
            tools:ignore="ExportedService" />
    </application>
</manifest>


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\App.kt

package jovannedeljkovic.gps_tracker_pro

import android.app.Application
import android.util.Log
import jovannedeljkovic.gps_tracker_pro.data.database.AppDatabase
import jovannedeljkovic.gps_tracker_pro.data.repository.PointRepository
import jovannedeljkovic.gps_tracker_pro.data.repository.RouteRepository
import jovannedeljkovic.gps_tracker_pro.data.repository.UserRepository
import jovannedeljkovic.gps_tracker_pro.utils.PasswordHasher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch

class App : Application() {
    val database by lazy { AppDatabase.getDatabase(this) }
    val userRepository by lazy { UserRepository(database.userDao()) }
    val routeRepository by lazy { RouteRepository(database.routeDao()) }
    val pointRepository by lazy { PointRepository(database.pointOfInterestDao()) }

    override fun onCreate() {
        super.onCreate()
        ensureBackupAdminExists()
    }

    private fun ensureBackupAdminExists() {
        GlobalScope.launch(Dispatchers.IO) {
            try {
                val backupAdminEmail = "backupadmin@localhost"
                val existingUser = userRepository.getUserByEmail(backupAdminEmail)

                if (existingUser == null) {
                    // Kreiraj backup admina
                    val backupAdmin = jovannedeljkovic.gps_tracker_pro.data.entities.User(
                        email = backupAdminEmail,
                        password = PasswordHasher.hashPassword("backup123"),
                        name = "Backup Admin",
                        role = "ADMIN"
                    )
                    userRepository.registerUser(backupAdmin)
                    Log.d("App", "Backup admin kreiran")
                }
            } catch (e: Exception) {
                Log.e("App", "Greška pri kreiranju backup admina: ${e.message}")
            }
        }
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\database\AppDatabase.kt

package jovannedeljkovic.gps_tracker_pro.data.database

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import jovannedeljkovic.gps_tracker_pro.data.database.dao.PointOfInterestDao
import jovannedeljkovic.gps_tracker_pro.data.database.dao.RouteDao
import jovannedeljkovic.gps_tracker_pro.data.database.dao.UserDao
import jovannedeljkovic.gps_tracker_pro.data.entities.LocationPoint
import jovannedeljkovic.gps_tracker_pro.data.entities.PointOfInterest
import jovannedeljkovic.gps_tracker_pro.data.entities.Route
import jovannedeljkovic.gps_tracker_pro.data.entities.User

@Database(
    entities = [
        User::class,
        Route::class,
        LocationPoint::class,
        PointOfInterest::class
    ],
    version = 3,
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
    abstract fun routeDao(): RouteDao
    abstract fun pointOfInterestDao(): PointOfInterestDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "gps_tracker_database"
                )
                    .fallbackToDestructiveMigration()
                    .build()
                INSTANCE = instance
                instance
            }
        }
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\database\dao\PointOfInterestDao.kt

package jovannedeljkovic.gps_tracker_pro.data.database.dao

import androidx.room.*
import jovannedeljkovic.gps_tracker_pro.data.entities.PointOfInterest

@Dao
interface PointOfInterestDao {

    @Insert
    suspend fun insertPoint(point: PointOfInterest)

    @Update
    suspend fun updatePoint(point: PointOfInterest)

    @Delete
    suspend fun deletePoint(point: PointOfInterest)

    @Query("SELECT * FROM points_of_interest WHERE userId = :userId ORDER BY createdAt DESC")
    suspend fun getUserPoints(userId: String): List<PointOfInterest>

    @Query("SELECT * FROM points_of_interest WHERE id = :pointId")
    suspend fun getPointById(pointId: String): PointOfInterest?
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\database\dao\RouteDao.kt

package jovannedeljkovic.gps_tracker_pro.data.database.dao

import androidx.room.*
import jovannedeljkovic.gps_tracker_pro.data.entities.LocationPoint
import jovannedeljkovic.gps_tracker_pro.data.entities.Route

@Dao
interface RouteDao {

    // Rute
    @Insert
    suspend fun insertRoute(route: Route)

    @Update
    suspend fun updateRoute(route: Route)

    @Query("SELECT * FROM routes WHERE userId = :userId ORDER BY startTime DESC")
    suspend fun getUserRoutes(userId: String): List<Route>

    @Query("SELECT * FROM routes WHERE id = :routeId")
    suspend fun getRouteById(routeId: String): Route?

    // DODATE METODE ZA BRISANJE
    @Delete
    suspend fun deleteRoute(route: Route)

    @Query("DELETE FROM routes WHERE id = :routeId")
    suspend fun deleteRouteById(routeId: String)

    // Taèke
    @Insert
    suspend fun insertLocationPoint(point: LocationPoint)

    @Query("SELECT * FROM location_points WHERE routeId = :routeId ORDER BY timestamp ASC")
    suspend fun getRoutePoints(routeId: String): List<LocationPoint>

    @Query("DELETE FROM location_points WHERE routeId = :routeId")
    suspend fun deleteRoutePoints(routeId: String)
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\database\dao\UserDao.kt

// app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\database\dao\UserDao.kt
package jovannedeljkovic.gps_tracker_pro.data.database.dao

import androidx.room.*
import jovannedeljkovic.gps_tracker_pro.data.entities.User

@Dao
interface UserDao {
    @Insert
    suspend fun insertUser(user: User)

    @Query("SELECT * FROM users WHERE email = :email AND password = :password")
    suspend fun loginUser(email: String, password: String): User?

    @Query("SELECT * FROM users WHERE email = :email")
    suspend fun getUserByEmail(email: String): User?

    @Query("SELECT COUNT(*) FROM users WHERE email = :email")
    suspend fun isEmailExists(email: String): Int

    // NOVE METODE:
    @Query("SELECT * FROM users WHERE id = :userId")
    suspend fun getUserById(userId: String): User?

    @Query("UPDATE users SET role = :role WHERE id = :userId")
    suspend fun updateUserRole(userId: String, role: String)

    @Query("UPDATE users SET premiumExpiry = :expiry WHERE id = :userId")
    suspend fun updatePremiumExpiry(userId: String, expiry: Long)

    @Query("SELECT * FROM users")
    suspend fun getAllUsers(): List<User> // Za admin panel

    @Query("DELETE FROM users WHERE id = :userId")
    suspend fun deleteUserById(userId: String)

}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\database\entities\User.kt

// app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\entities\User.kt
package jovannedeljkovic.gps_tracker_pro.data.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

@Entity(tableName = "users")
data class User(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val email: String,
    val password: String,
    val name: String = "",
    val phone: String = "",
    val role: String = "BASIC", // NOVO: BASIC, PREMIUM, ADMIN
    val premiumExpiry: Long = 0L, // NOVO: datum isteka premiuma
    val createdAt: Long = System.currentTimeMillis()
)


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\entities\LocationPoint.kt

package jovannedeljkovic.gps_tracker_pro.data.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

@Entity(tableName = "location_points")
data class LocationPoint(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val routeId: String,
    val latitude: Double,
    val longitude: Double,
    val timestamp: Long = System.currentTimeMillis(),
    val accuracy: Float = 0f
)


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\entities\PointOfInterest.kt

package jovannedeljkovic.gps_tracker_pro.data.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

@Entity(tableName = "points_of_interest")
data class PointOfInterest(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val userId: String,
    val name: String = "Nova taèka",
    val latitude: Double,
    val longitude: Double,
    val createdAt: Long = System.currentTimeMillis()
)


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\entities\Route.kt

package jovannedeljkovic.gps_tracker_pro.data.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

@Entity(tableName = "routes")
data class Route(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val userId: String,
    val name: String = "Nova ruta",
    val distance: Double = 0.0, // u metrima
    val duration: Long = 0, // u milisekundama
    val startTime: Long = System.currentTimeMillis(),
    val endTime: Long = 0,
    val isCompleted: Boolean = false
)


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\repository\PointRepository.kt

package jovannedeljkovic.gps_tracker_pro.data.repository

import jovannedeljkovic.gps_tracker_pro.data.database.dao.PointOfInterestDao
import jovannedeljkovic.gps_tracker_pro.data.entities.PointOfInterest

class PointRepository(private val pointDao: PointOfInterestDao) {

    suspend fun addPoint(point: PointOfInterest) {
        pointDao.insertPoint(point)
    }

    suspend fun updatePoint(point: PointOfInterest) {
        pointDao.updatePoint(point)
    }

    suspend fun deletePoint(point: PointOfInterest) {
        pointDao.deletePoint(point)
    }

    suspend fun getUserPoints(userId: String): List<PointOfInterest> {
        return pointDao.getUserPoints(userId)
    }

    suspend fun getPointById(pointId: String): PointOfInterest? {
        return pointDao.getPointById(pointId)
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\repository\RouteRepository.kt

package jovannedeljkovic.gps_tracker_pro.data.repository

import jovannedeljkovic.gps_tracker_pro.data.database.dao.RouteDao
import jovannedeljkovic.gps_tracker_pro.data.entities.LocationPoint
import jovannedeljkovic.gps_tracker_pro.data.entities.Route

class RouteRepository(private val routeDao: RouteDao) {

    suspend fun createRoute(route: Route): String {
        routeDao.insertRoute(route)
        return route.id
    }

    suspend fun deleteRoutePoints(routeId: String) {
        routeDao.deleteRoutePoints(routeId)
    }
    suspend fun updateRoute(route: Route) {
        routeDao.updateRoute(route)
    }

    suspend fun addLocationPoint(point: LocationPoint) {
        routeDao.insertLocationPoint(point)
    }

    suspend fun getUserRoutes(userId: String): List<Route> {
        return routeDao.getUserRoutes(userId)
    }

    suspend fun getRoutePoints(routeId: String): List<LocationPoint> {
        return routeDao.getRoutePoints(routeId)
    }

    suspend fun getRouteById(routeId: String): Route? {
        return routeDao.getRouteById(routeId)
    }

    // DODATA METODA ZA BRISANJE RUTE
    suspend fun deleteRoute(route: Route) {
        // Prvo obriši sve taèke rute
        routeDao.deleteRoutePoints(route.id)
        // Onda obriši rutu
        routeDao.deleteRoute(route)
    }

    // DODATA METODA ZA BRISANJE RUTE PO ID
    suspend fun deleteRouteById(routeId: String) {
        routeDao.deleteRoutePoints(routeId)
        routeDao.deleteRouteById(routeId)
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\data\repository\UserRepository.kt

package jovannedeljkovic.gps_tracker_pro.data.repository

import jovannedeljkovic.gps_tracker_pro.data.database.dao.UserDao
import jovannedeljkovic.gps_tracker_pro.data.entities.User
import jovannedeljkovic.gps_tracker_pro.utils.AdminManager
class UserRepository(private val userDao: UserDao) {

    suspend fun registerUser(user: User): Boolean {
        return try {
            // Proveri da li email veæ postoji
            val existingUser = userDao.getUserByEmail(user.email)
            if (existingUser != null) {
                return false // Email veæ postoji
            }

            // PROVERA DA LI JE MASTER ADMIN
            val finalUser = if (AdminManager.isMasterAdmin(user.email)) {
                user.copy(role = "ADMIN") // Automatski postavi kao ADMIN
            } else {
                user // Ostavi BASIC ulogu
            }

            userDao.insertUser(finalUser)
            true
        } catch (e: Exception) {
            false
        }
    }

    suspend fun loginUser(email: String, password: String): User? {
        val user = userDao.loginUser(email, password)

        // PROVERA: ako je master admin, osiguraj da je role ADMIN
        user?.let { existingUser ->
            if (AdminManager.isMasterAdmin(email) && existingUser.role != "ADMIN") {
                // Ako je master admin ali nema ADMIN role, popravi to
                setUserAsAdmin(existingUser.id)
                return userDao.getUserByEmail(email) // Vrati korigovanog usera
            }
        }

        return user
    }

    suspend fun isEmailExists(email: String): Boolean {
        return userDao.getUserByEmail(email) != null
    }

    // OSTALE METODE:
    suspend fun getUserById(userId: String): User? {
        return userDao.getUserById(userId)
    }

    suspend fun deleteUser(userId: String): Boolean {
        return try {
            userDao.deleteUserById(userId)
            true
        } catch (e: Exception) {
            false
        }
    }
    suspend fun upgradeToPremium(userId: String, days: Int = 30): Boolean {
        return try {
            val expiry = System.currentTimeMillis() + (days * 24 * 60 * 60 * 1000L)
            userDao.updateUserRole(userId, "PREMIUM")
            userDao.updatePremiumExpiry(userId, expiry)
            true
        } catch (e: Exception) {
            false
        }
    }

    suspend fun downgradeToBasic(userId: String): Boolean {
        return try {
            userDao.updateUserRole(userId, "BASIC")
            userDao.updatePremiumExpiry(userId, 0L)
            true
        } catch (e: Exception) {
            false
        }
    }

    suspend fun setUserAsAdmin(userId: String): Boolean {
        return try {
            userDao.updateUserRole(userId, "ADMIN")
            true
        } catch (e: Exception) {
            false
        }
    }

    suspend fun getAllUsers(): List<User> {
        return userDao.getAllUsers()
    }

    suspend fun isUserPremium(userId: String): Boolean {
        val user = userDao.getUserById(userId)
        return user?.role == "PREMIUM" && (user.premiumExpiry > System.currentTimeMillis() || user.premiumExpiry == 0L)
    }

    suspend fun isUserAdmin(userId: String): Boolean {
        val user = userDao.getUserById(userId)
        return user?.role == "ADMIN"
    }

    suspend fun getUserRole(userId: String): String {
        val user = userDao.getUserById(userId)
        return user?.role ?: "BASIC"
    }

    suspend fun getUserByEmail(email: String): User? {
        return userDao.getUserByEmail(email)
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\network\GpsTrackerApi.kt

package jovannedeljkovic.gps_tracker_pro.network

import retrofit2.http.Body
import retrofit2.http.POST

interface GpsTrackerApi {
    @POST("auth/login")
    suspend fun login(@Body request: LoginRequest): LoginResponse

    @POST("locations")
    suspend fun sendLocation(@Body location: LocationData): ApiResponse
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\network\NetworkModels.kt

package jovannedeljkovic.gps_tracker_pro.network

data class LoginRequest(
    val email: String,
    val password: String
)

data class LoginResponse(
    val success: Boolean,
    val message: String,
    val user: User?,
    val token: String?
)

data class User(
    val id: Int,
    val email: String,
    val name: String,
    val role: String
)

data class LocationData(
    val userId: Int,
    val latitude: Double,
    val longitude: Double,
    val timestamp: String
)

data class ApiResponse(
    val success: Boolean,
    val message: String
)


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\network\RetrofitInstance.kt

package jovannedeljkovic.gps_tracker_pro.network

import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

object RetrofitInstance {
    private const val BASE_URL = "http://10.0.2.2:5000/api/" // Za emulator

    private val loggingInterceptor = HttpLoggingInterceptor().apply {
        level = HttpLoggingInterceptor.Level.BODY
    }

    private val client = OkHttpClient.Builder()
        .addInterceptor(loggingInterceptor)
        .build()

    private val retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .client(client)
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    val api: GpsTrackerApi by lazy {
        retrofit.create(GpsTrackerApi::class.java)
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\service\TrackingService.kt

package jovannedeljkovic.gps_tracker_pro.service

import android.app.*
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.location.Location
import android.os.*
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import com.google.android.gms.location.*
import jovannedeljkovic.gps_tracker_pro.R
import jovannedeljkovic.gps_tracker_pro.ui.main.MainActivity

class TrackingService : Service() {

    private lateinit var wakeLock: PowerManager.WakeLock
    private lateinit var fusedLocationClient: FusedLocationProviderClient
    private lateinit var locationRequest: LocationRequest
    private lateinit var locationCallback: LocationCallback

    private var isAppInForeground = true
    private var backgroundUpdateInterval = 15000L
    private var foregroundUpdateInterval = 5000L

    companion object {
        private const val CHANNEL_ID = "tracking_service_channel"
        private const val TAG = "TrackingService"
        private const val SERVICE_NOTIFICATION_ID = 1001
        const val ACTION_START_TRACKING = "START_TRACKING"
        const val ACTION_STOP_TRACKING = "STOP_TRACKING"
        const val ACTION_APP_IN_FOREGROUND = "APP_FOREGROUND"
        const val ACTION_APP_IN_BACKGROUND = "APP_BACKGROUND"
    }

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "Service onCreate")

        createNotificationChannel()
        initializeOptimizedLocationClient()

        val powerManager = getSystemService(POWER_SERVICE) as PowerManager
        wakeLock = powerManager.newWakeLock(
            PowerManager.PARTIAL_WAKE_LOCK,
            "GPSTracker:TrackingService"
        )
        wakeLock.acquire()
    }

    private fun initializeOptimizedLocationClient() {
        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)

        locationRequest = LocationRequest.Builder(
            Priority.PRIORITY_BALANCED_POWER_ACCURACY,
            foregroundUpdateInterval
        )
            .setMinUpdateIntervalMillis(3000L)
            .setWaitForAccurateLocation(true)
            .setMinUpdateDistanceMeters(15.0f)
            .setMaxUpdateDelayMillis(30000L)
            .build()

        locationCallback = object : LocationCallback() {
            override fun onLocationResult(locationResult: LocationResult) {
                locationResult.locations.lastOrNull()?.let { location ->
                    if (location.accuracy < 50.0f && location.accuracy > 0) {
                        Log.d(TAG, "Lokacija u pozadini: ${location.accuracy}m")
                        broadcastLocationToActivity(location)
                    }
                }
            }
        }
    }

    private fun broadcastLocationToActivity(location: Location) {
        try {
            val intent = Intent("BACKGROUND_LOCATION_UPDATE").apply {
                putExtra("latitude", location.latitude)
                putExtra("longitude", location.longitude)
                putExtra("accuracy", location.accuracy)
                putExtra("speed", location.speed)
                putExtra("bearing", location.bearing)
                putExtra("timestamp", location.time)
            }
            sendBroadcast(intent)
        } catch (e: Exception) {
            Log.e(TAG, "Greška pri slanju lokacije: ${e.message}")
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(TAG, "Service onStartCommand: ${intent?.action}")

        when (intent?.action) {
            ACTION_START_TRACKING -> {
                startForegroundTracking()
                startOptimizedLocationUpdates()
            }
            ACTION_STOP_TRACKING -> stopTracking()
            ACTION_APP_IN_FOREGROUND -> {
                isAppInForeground = true
                adjustLocationUpdatesForForeground()
            }
            ACTION_APP_IN_BACKGROUND -> {
                isAppInForeground = false
                adjustLocationUpdatesForBackground()
            }
            else -> startForegroundTracking()
        }

        return START_STICKY
    }

    private fun startOptimizedLocationUpdates() {
        if (checkLocationPermission()) {
            try {
                fusedLocationClient.requestLocationUpdates(
                    locationRequest,
                    locationCallback,
                    Looper.getMainLooper()
                )
                Log.d(TAG, "Location updates pokrenuti")
            } catch (e: SecurityException) {
                Log.e(TAG, "Greška pri pokretanju location updates: ${e.message}")
            }
        } else {
            Log.w(TAG, "Nema dozvola za lokaciju")
            stopSelf()
        }
    }

    private fun adjustLocationUpdatesForForeground() {
        stopLocationUpdates()
        locationRequest = LocationRequest.Builder(
            Priority.PRIORITY_HIGH_ACCURACY,
            foregroundUpdateInterval
        )
            .setMinUpdateIntervalMillis(2000L)
            .setWaitForAccurateLocation(true)
            .setMinUpdateDistanceMeters(5.0f)
            .build()
        startOptimizedLocationUpdates()
        Log.d(TAG, "Podešavanja za FOREGROUND")
    }

    private fun adjustLocationUpdatesForBackground() {
        stopLocationUpdates()
        locationRequest = LocationRequest.Builder(
            Priority.PRIORITY_BALANCED_POWER_ACCURACY,
            backgroundUpdateInterval
        )
            .setMinUpdateIntervalMillis(10000L)
            .setWaitForAccurateLocation(false)
            .setMinUpdateDistanceMeters(25.0f)
            .setMaxUpdateDelayMillis(60000L)
            .build()
        startOptimizedLocationUpdates()
        Log.d(TAG, "Podešavanja za BACKGROUND")
    }

    private fun startForegroundTracking() {
        try {
            val notification = createOptimizedTrackingNotification()
            startForeground(SERVICE_NOTIFICATION_ID, notification)
            Log.d(TAG, "Foreground service pokrenut")
        } catch (e: Exception) {
            Log.e(TAG, "Greška pri pokretanju foreground service: ${e.message}")
        }
    }

    private fun checkLocationPermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            this,
            android.Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
    }

    private fun stopTracking() {
        stopLocationUpdates()
        stopSelf()
        Log.d(TAG, "Snimanje zaustavljeno")
    }

    private fun stopLocationUpdates() {
        try {
            fusedLocationClient.removeLocationUpdates(locationCallback)
            Log.d(TAG, "Location updates zaustavljeni")
        } catch (e: Exception) {
            Log.e(TAG, "Greška pri zaustavljanju location updates: ${e.message}")
        }
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

            if (notificationManager.getNotificationChannel(CHANNEL_ID) == null) {
                val channel = NotificationChannel(
                    CHANNEL_ID,
                    "GPS Tracking Service",
                    NotificationManager.IMPORTANCE_LOW
                ).apply {
                    description = "Service za praæenje lokacije u pozadini"
                    setShowBadge(false)
                    lockscreenVisibility = Notification.VISIBILITY_PUBLIC
                }
                notificationManager.createNotificationChannel(channel)
            }
        }
    }

    private fun createOptimizedTrackingNotification(): Notification {
        val intent = Intent(this, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_SINGLE_TOP or Intent.FLAG_ACTIVITY_CLEAR_TOP
            action = "OPEN_TRACKING"
        }
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val stopIntent = Intent(this, TrackingService::class.java).apply {
            action = ACTION_STOP_TRACKING
        }
        val stopPendingIntent = PendingIntent.getService(
            this,
            1,
            stopIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("GPS Tracker - Snimanje aktivno")
            .setContentText("Aplikacija snima vašu rutu u pozadini")
            .setSmallIcon(android.R.drawable.ic_dialog_map) // Koristi sistemsku ikonu
            .setContentIntent(pendingIntent)
            .addAction(android.R.drawable.ic_media_pause, "Zaustavi", stopPendingIntent)
            .setOngoing(true)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setSilent(true)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .build()
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "Service onDestroy")

        stopLocationUpdates()

        if (wakeLock.isHeld) {
            wakeLock.release()
        }

        Log.d(TAG, "Service uspešno zaustavljen")
    }

    override fun onBind(intent: Intent?): IBinder? = null
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\ui\admin\AdminActivity.kt

package jovannedeljkovic.gps_tracker_pro.ui.admin

import android.content.Intent
import android.os.Bundle
import android.os.Environment
import android.text.InputType  // DODAJ OVO! ??
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.app.AlertDialog
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import jovannedeljkovic.gps_tracker_pro.App
import jovannedeljkovic.gps_tracker_pro.data.entities.User
import jovannedeljkovic.gps_tracker_pro.data.entities.Route  // DODAJ OVO! ???
import jovannedeljkovic.gps_tracker_pro.data.entities.PointOfInterest  // DODAJ OVO! ??
import jovannedeljkovic.gps_tracker_pro.databinding.ActivityAdminBinding
import jovannedeljkovic.gps_tracker_pro.ui.auth.LoginActivity
import jovannedeljkovic.gps_tracker_pro.utils.FeatureManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileWriter
import java.text.SimpleDateFormat
import java.util.*

class AdminActivity : AppCompatActivity() {

    private lateinit var binding: ActivityAdminBinding
    private lateinit var usersAdapter: UsersAdapter
    private val usersList = mutableListOf<User>()



    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityAdminBinding.inflate(layoutInflater)
        setContentView(binding.root)

        setupRecyclerView()
        loadUsers()
        setupClickListeners()

        // Dodajte dugme za statistiku ako postoji u layout-u
        binding.btnStatistics?.setOnClickListener {
            showUserStatistics()
        }
    }

    // ISPRAVNO: Ne pozivamo super odmah, veæ kada korisnik potvrdi
    override fun onBackPressed() {
        showExitConfirmationDialog()
    }

    private fun showExitConfirmationDialog() {
        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Admin Panel")
            .setMessage("Da li želite da izaðete iz admin moda?")
            .setPositiveButton("DA, izloguj me") { _, _ ->
                logoutAndExit()
            }
            .setNegativeButton("NE, ostani", null)
            .show()
    }

    private fun logoutAndExit() {
        // 1. Oèisti admin pristup
        getSharedPreferences("admin_prefs", MODE_PRIVATE)
            .edit()
            .clear()
            .apply()

        // 2. Kreiraj intent za LoginActivity
        val intent = Intent(this, LoginActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK
        }

        // 3. Pokreni LoginActivity
        startActivity(intent)

        // 4. Zatvori ovu aktivnost
        finish()

        Toast.makeText(this, "Admin mod iskljuèen", Toast.LENGTH_SHORT).show()
    }

    private fun setupRecyclerView() {
        usersAdapter = UsersAdapter(usersList) { user ->
            showUserOptionsDialog(user)
        }
        binding.rvUsers.apply {
            layoutManager = LinearLayoutManager(this@AdminActivity)
            adapter = usersAdapter
        }
    }

    private fun showUserOptionsDialog(user: User) {


        val options = arrayOf(
            "?? Postavi kao ADMIN",
            "? Postavi kao PREMIUM",
            "?? Postavi kao BASIC",
            "??? Obriši korisnika",
            "?? Podaci o korisniku",
            "?? Statistika korisnika"
        )

        AlertDialog.Builder(this)
            .setTitle("??? Upravljanje korisnikom: ${user.email}")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> setUserRole(user, "ADMIN")
                    1 -> setUserRole(user, "PREMIUM")
                    2 -> setUserRole(user, "BASIC")
                    3 -> deleteUserWithAllData(user)
                    4 -> showUserDetails(user)
                    5 -> showUserSpecificStatistics(user)
                }
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun loadUsers() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val users = app.userRepository.getAllUsers()

                usersList.clear()
                usersList.addAll(users)

                withContext(Dispatchers.Main) {
                    usersAdapter.notifyDataSetChanged()
                    binding.tvUserCount.text = "Ukupno korisnika: ${users.size}"
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(
                        this@AdminActivity,
                        "Greška pri uèitavanju korisnika: ${e.message}",
                        Toast.LENGTH_SHORT
                    ).show()
                }
            }
        }
    }

    private fun showUserSpecificStatistics(user: User) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Uèitavanje statistike...")
            .setMessage("Prikupljam podatke za korisnika: ${user.email}")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App

                // Uèitaj podatke samo za ovog korisnika
                val userRoutes = app.routeRepository.getUserRoutes(user.id)
                val userPoints = app.pointRepository.getUserPoints(user.id)

                // Izraèunaj statistike
                val totalRoutes = userRoutes.size
                val totalPoints = userPoints.size
                val totalDistance = userRoutes.sumOf { it.distance }
                val totalDuration = userRoutes.sumOf { it.duration } / 1000 / 60 // u minutima

                val latestRoute = userRoutes.maxByOrNull { it.startTime }
                val oldestRoute = userRoutes.minByOrNull { it.startTime }

                val dateFormat = SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault())

                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()

                    val statsMessage = """
                ?? STATISTIKA KORISNIKA: ${user.email}
                
                ?? Osnovne informacije:
                   ?? Kreiran: ${dateFormat.format(Date(user.createdAt))}
                   ??? Uloga: ${user.role}
                   ? Premium: ${if (user.role == "PREMIUM") "DA" else "NE"}
                   ${if (user.role == "PREMIUM" && user.premiumExpiry > 0) "   ?? Premium istièe: ${dateFormat.format(Date(user.premiumExpiry))}" else ""}
                
                ?? Aktivnost:
                   ??? Ukupno ruta: $totalRoutes
                   ?? Ukupno taèaka: $totalPoints
                   ?? Ukupna udaljenost: ${String.format("%.2f", totalDistance/1000)} km
                   ?? Ukupno vreme: ${totalDuration} minuta
                
                ? Vremenski okviri:
                   ?? Poslednja ruta: ${latestRoute?.let { dateFormat.format(Date(it.startTime)) } ?: "Nema"}
                   ??? Prva ruta: ${oldestRoute?.let { dateFormat.format(Date(it.startTime)) } ?: "Nema"}
                
                ?? Status: ${if (totalRoutes > 0) "?? AKTIVAN" else "?? NEAKTIVAN"}
                """.trimIndent()

                    AlertDialog.Builder(this@AdminActivity)
                        .setTitle("?? Statistika korisnika")
                        .setMessage(statsMessage)
                        .setPositiveButton("? Zatvori", null)
                        .setNegativeButton("?? Eksportuj CSV") { dialog, which ->
                            exportUserSpecificCSV(user, userRoutes, userPoints)
                        }
                        .show()
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@AdminActivity,
                        "? Greška pri uèitavanju statistike: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }


    private fun exportUserSpecificCSV(user: User, routes: List<Route>, points: List<PointOfInterest>) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val fileName = "korisnik_${user.email}_statistika_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.csv"
                val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                val csvFile = File(downloadsDir, fileName)

                FileWriter(csvFile).use { writer ->
                    // Header za korisnika
                    writer.append("EMAIL,ULOGA,DATUM_KREIRANJA,PREMIUM_ISTICE\n")
                    val premiumExpiry = if (user.premiumExpiry > 0) {
                        SimpleDateFormat("dd.MM.yyyy", Locale.getDefault()).format(Date(user.premiumExpiry))
                    } else "NEMA"

                    writer.append("${user.email},${user.role},${SimpleDateFormat("dd.MM.yyyy", Locale.getDefault()).format(Date(user.createdAt))},$premiumExpiry\n\n")

                    // Rute
                    writer.append("RUTE\n")
                    writer.append("ID,IME,UDALJENOST(m),VREME(min),DATUM_POCETKA\n")
                    routes.forEach { route ->
                        val duration = route.duration / 1000 / 60
                        writer.append("${route.id},${route.name},${route.distance},$duration,${SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault()).format(Date(route.startTime))}\n")
                    }

                    writer.append("\n")

                    // Taèke
                    writer.append("TAÈKE INTERESA\n")
                    writer.append("ID,IME,LATITUDA,LONGITUDA,DATUM_KREIRANJA\n")
                    points.forEach { point ->
                        writer.append("${point.id},${point.name},${point.latitude},${point.longitude},${SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault()).format(Date(point.createdAt))}\n")
                    }
                }

                withContext(Dispatchers.Main) {
                    Toast.makeText(
                        this@AdminActivity,
                        "? Statistika eksportovana u CSV!\n?? $fileName",
                        Toast.LENGTH_LONG
                    ).show()
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(
                        this@AdminActivity,
                        "? Greška pri eksportu: ${e.message}",
                        Toast.LENGTH_SHORT
                    ).show()
                }
            }
        }
    }

    private fun deleteUserWithAllData(user: User) {
        AlertDialog.Builder(this)
            .setTitle("??? Brisanje korisnika")
            .setMessage("Da li ste sigurni da želite da obrišete korisnika ${user.email}?\n\n" +
                    "Ova akcija æe obrisati:\n" +
                    "?? Sve rute korisnika\n" +
                    "?? Sve taèke interesa\n" +
                    "?? Korisnièki nalog\n\n" +
                    "?? Ova akcija se NE MOŽE poništiti!")
            .setPositiveButton("??? Obriši") { dialog, which ->
                performUserDeletion(user)
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun performUserDeletion(user: User) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Brisanje u toku...")
            .setMessage("Brišem korisnika i sve podatke...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App

                // 1. Obriši sve rute korisnika
                val userRoutes = app.routeRepository.getUserRoutes(user.id)
                userRoutes.forEach { route ->
                    // Prvo obriši sve taèke rute
                    app.routeRepository.deleteRoutePoints(route.id)
                    // Onda obriši rutu
                    app.routeRepository.deleteRoute(route)
                }

                // 2. Obriši sve taèke interesa
                val userPoints = app.pointRepository.getUserPoints(user.id)
                userPoints.forEach { point ->
                    app.pointRepository.deletePoint(point)
                }

                // 3. Obriši korisnika
                app.userRepository.deleteUser(user.id)

                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@AdminActivity,
                        "? Korisnik ${user.email} uspešno obrisan sa svim podacima!",
                        Toast.LENGTH_LONG
                    ).show()
                    loadUsers() // Osveži listu
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@AdminActivity,
                        "? Greška pri brisanju: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }


    private fun setUserRole(user: User, newRole: String) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val success = when (newRole) {
                    "ADMIN" -> app.userRepository.setUserAsAdmin(user.id)
                    "PREMIUM" -> app.userRepository.upgradeToPremium(user.id, 30)
                    "BASIC" -> app.userRepository.downgradeToBasic(user.id)
                    else -> false
                }

                withContext(Dispatchers.Main) {
                    if (success) {
                        Toast.makeText(
                            this@AdminActivity,
                            "Korisnik ${user.email} sada je $newRole",
                            Toast.LENGTH_LONG
                        ).show()
                        loadUsers()
                    } else {
                        Toast.makeText(
                            this@AdminActivity,
                            "Greška pri promeni uloge",
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(
                        this@AdminActivity,
                        "Greška: ${e.message}",
                        Toast.LENGTH_SHORT
                    ).show()
                }
            }
        }
    }

    private fun deleteUser(user: User) {
        AlertDialog.Builder(this)
            .setTitle("? Brisanje korisnika")
            .setMessage("Da li ste sigurni da želite da obrišete korisnika ${user.email}?\n\n" +
                    "Ova akcija æe obrisati:\n" +
                    "• Sve rute korisnika\n" +
                    "• Sve taèke interesa\n" +
                    "• Korisnièki nalog\n\n" +
                    "Ova akcija se NE MOŽE poništiti!")
            .setPositiveButton("? Obriši") { dialog, which ->
                lifecycleScope.launch(Dispatchers.IO) {
                    try {
                        val app = application as App

                        // Prvo obrišite rute korisnika
                        val userRoutes = app.routeRepository.getUserRoutes(user.id)
                        userRoutes.forEach { route ->
                            app.routeRepository.deleteRoute(route)
                        }

                        // Zatim obrišite taèke korisnika
                        val userPoints = app.pointRepository.getUserPoints(user.id)
                        userPoints.forEach { point ->
                            app.pointRepository.deletePoint(point)
                        }

                        // Na kraju obrišite korisnika
                        // Dodajte ovu metodu u UserDao:
                        // @Query("DELETE FROM users WHERE id = :userId")
                        // suspend fun deleteUserById(userId: String)

                        // Za sada, možete koristiti workaround:
                        // Ovde možete dodati logiku za brisanje korisnika

                        withContext(Dispatchers.Main) {
                            Toast.makeText(
                                this@AdminActivity,
                                "?? Brisanje korisnika æe biti implementirano u narednoj verziji",
                                Toast.LENGTH_LONG
                            ).show()
                            // loadUsers() // Osveži listu kada implementirate brisanje
                        }
                    } catch (e: Exception) {
                        withContext(Dispatchers.Main) {
                            Toast.makeText(
                                this@AdminActivity,
                                "? Greška: ${e.message}",
                                Toast.LENGTH_SHORT
                            ).show()
                        }
                    }
                }
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun showUserDetails(user: User) {
        val dateFormat = SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault())
        val createdDate = dateFormat.format(Date(user.createdAt))

        val premiumInfo = if (user.role == "PREMIUM" && user.premiumExpiry > 0) {
            val expiryDate = dateFormat.format(Date(user.premiumExpiry))
            "Premium istièe: $expiryDate"
        } else {
            "Nema premium"
        }

        val message = """
            ?? Email: ${user.email}
            ?? Ime: ${user.name}
            ?? Telefon: ${user.phone}
            ?? Uloga: ${FeatureManager.getUserRoleDisplayName(user)}
            ?? Kreiran: $createdDate
            ? $premiumInfo
        """.trimIndent()

        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Detalji korisnika")
            .setMessage(message)
            .setPositiveButton("OK", null)
            .show()
    }

    private fun showUserStatistics() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val allUsers = app.userRepository.getAllUsers()

                // Izraèunaj statistike
                val totalUsers = allUsers.size
                val adminCount = allUsers.count { it.role == "ADMIN" }
                val premiumCount = allUsers.count { it.role == "PREMIUM" }
                val basicCount = allUsers.count { it.role == "BASIC" }

                // Proseèno vreme od kreiranja naloga
                val averageAccountAge = allUsers.map {
                    System.currentTimeMillis() - it.createdAt
                }.average() / (1000 * 60 * 60 * 24) // u danima

                // Aktivni premium korisnici (još nije istekla pretplata)
                val activePremium = allUsers.count {
                    it.role == "PREMIUM" && it.premiumExpiry > System.currentTimeMillis()
                }

                withContext(Dispatchers.Main) {
                    val statsMessage = """
                        ?? STATISTIKA KORISNIKA
                        
                        ?? Ukupno korisnika: $totalUsers
                        
                        ?? Distribucija uloga:
                           ?? Admin: $adminCount
                           ? Premium: $premiumCount (od toga aktivnih: $activePremium)
                           ?? Basic: $basicCount
                        
                        ?? Proseèna starost naloga: ${String.format("%.1f", averageAccountAge)} dana
                        
                        ${if (premiumCount > 0) "?? Aktivni premium: ${String.format("%.1f", (activePremium.toDouble() / premiumCount * 100))}%" else "?? Nema premium korisnika"}
                        
                        ?? Poslednji pregled: ${SimpleDateFormat("dd.MM.yyyy HH:mm:ss", Locale.getDefault()).format(Date())}
                    """.trimIndent()

                    AlertDialog.Builder(this@AdminActivity)
                        .setTitle("?? Statistika korisnika")
                        .setMessage(statsMessage)
                        .setPositiveButton("?? Eksportuj CSV") { dialog, which ->
                            exportUserStatisticsToCSV(allUsers)
                        }
                        .setNegativeButton("? Zatvori", null)
                        .show()
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(
                        this@AdminActivity,
                        "? Greška pri uèitavanju statistike: ${e.message}",
                        Toast.LENGTH_SHORT
                    ).show()
                }
            }
        }
    }

    private fun exportUserStatisticsToCSV(users: List<User>) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val fileName = "korisnici_statistika_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.csv"
                val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                val csvFile = File(downloadsDir, fileName)

                FileWriter(csvFile).use { writer ->
                    // Header
                    writer.append("Email,Ime,Telefon,Uloga,Datum kreiranja,Premium istièe,Starost naloga (dana)\n")

                    // Podaci
                    users.forEach { user ->
                        val accountAgeDays = (System.currentTimeMillis() - user.createdAt) / (1000 * 60 * 60 * 24)
                        val premiumExpiry = if (user.premiumExpiry > 0) {
                            SimpleDateFormat("dd.MM.yyyy", Locale.getDefault()).format(Date(user.premiumExpiry))
                        } else "Nema premium"

                        writer.append("${user.email},${user.name},${user.phone},${user.role},")
                        writer.append("${SimpleDateFormat("dd.MM.yyyy", Locale.getDefault()).format(Date(user.createdAt))},")
                        writer.append("$premiumExpiry,$accountAgeDays\n")
                    }
                }

                withContext(Dispatchers.Main) {
                    Toast.makeText(
                        this@AdminActivity,
                        "? Statistika eksportovana u CSV: $fileName",
                        Toast.LENGTH_LONG
                    ).show()
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(
                        this@AdminActivity,
                        "? Greška pri eksportu: ${e.message}",
                        Toast.LENGTH_SHORT
                    ).show()
                }
            }
        }
    }

    private fun setupClickListeners() {
        binding.btnBack.setOnClickListener {
            showExitConfirmationDialog()
        }

        binding.btnRefresh.setOnClickListener {
            loadUsers()
        }
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\ui\admin\UsersAdapter.kt

package jovannedeljkovic.gps_tracker_pro.ui.admin

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import jovannedeljkovic.gps_tracker_pro.R
import jovannedeljkovic.gps_tracker_pro.data.entities.User
import jovannedeljkovic.gps_tracker_pro.utils.FeatureManager
import java.text.SimpleDateFormat
import java.util.*

class UsersAdapter(
    private val users: List<User>,
    private val onUserClick: (User) -> Unit
) : RecyclerView.Adapter<UsersAdapter.UserViewHolder>() {

    inner class UserViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val tvEmail: TextView = itemView.findViewById(R.id.tvUserEmail)
        private val tvRole: TextView = itemView.findViewById(R.id.tvUserRole)
        private val tvDate: TextView = itemView.findViewById(R.id.tvUserDate)

        fun bind(user: User) {
            tvEmail.text = user.email
            tvRole.text = FeatureManager.getUserRoleDisplayName(user)

            val dateFormat = SimpleDateFormat("dd.MM.yyyy", Locale.getDefault())
            tvDate.text = dateFormat.format(Date(user.createdAt))

            // Razlièite boje za razlièite uloge
            when (user.role) {
                "ADMIN" -> tvRole.setTextColor(ContextCompat.getColor(itemView.context, R.color.accent_red))
                "PREMIUM" -> tvRole.setTextColor(ContextCompat.getColor(itemView.context, R.color.accent_green))
                else -> tvRole.setTextColor(ContextCompat.getColor(itemView.context, R.color.blue_primary))
            }

            itemView.setOnClickListener {
                onUserClick(user)
            }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_user, parent, false)
        return UserViewHolder(view)
    }

    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {
        holder.bind(users[position])
    }

    override fun getItemCount(): Int = users.size
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\ui\auth\LoginActivity.kt

package jovannedeljkovic.gps_tracker_pro.ui.auth

import android.content.Intent
import android.os.Bundle
import android.text.InputType
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import jovannedeljkovic.gps_tracker_pro.App
import jovannedeljkovic.gps_tracker_pro.databinding.ActivityLoginBinding
import jovannedeljkovic.gps_tracker_pro.ui.admin.AdminActivity
import jovannedeljkovic.gps_tracker_pro.ui.main.MainActivity
import jovannedeljkovic.gps_tracker_pro.utils.PasswordHasher
import kotlinx.coroutines.launch
import jovannedeljkovic.gps_tracker_pro.utils.AdminManager
class LoginActivity : AppCompatActivity() {

    private lateinit var binding: ActivityLoginBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityLoginBinding.inflate(layoutInflater)
        setContentView(binding.root)

        setupClickListeners()
        checkForSecretAdminAccess()
    }

    private fun setupClickListeners() {
        // Login dugme
        binding.btnLogin.setOnClickListener {
            loginUser()
        }

        // Registracija link
        binding.tvRegisterLink.setOnClickListener {
            startActivity(Intent(this, RegisterActivity::class.java))
            finish()
        }

        // Zaboravljena lozinka
        binding.tvForgotPassword.setOnClickListener {
            Toast.makeText(this, "Funkcionalnost u izradi", Toast.LENGTH_SHORT).show()
        }

        // SECRET CODE: dugo klik na "Registruj se" za admin access
        binding.tvRegisterLink.setOnLongClickListener {
            showSecretAdminAccess()
            true
        }

        // SECRET CODE: dugo klik na email polje
        binding.etEmail.setOnLongClickListener {
            showSecretAdminAccess()
            true
        }

        // SECRET CODE: dugo klik na "Prijavi se" dugme
        binding.btnLogin.setOnLongClickListener {
            showSecretAdminAccess()
            true
        }
    }

    private fun checkForSecretAdminAccess() {
        val sharedPreferences = getSharedPreferences("admin_prefs", MODE_PRIVATE)
        val hasAdminAccess = sharedPreferences.getBoolean("has_admin_access", false)

        if (hasAdminAccess) {
            // Ako veæ ima admin pristup, otvori admin panel direktno
            val intent = Intent(this, AdminActivity::class.java)
            startActivity(intent)
            finish()
        }
    }

    private fun showSecretAdminAccess() {
        val editText = EditText(this).apply {
            hint = "Unesi secret admin kod"
            inputType = InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_PASSWORD
        }

        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("?? Secret Admin Access")
            .setMessage("Unesi secret kod za admin pristup:")
            .setView(editText)
            .setPositiveButton("Unesi") { dialog, _ ->
                val code = editText.text.toString().trim()
                if (AdminManager.isValidSecretCode(code)) {
                    enableAdminFeatures()
                } else {
                    Toast.makeText(this, "? Pogrešan kod!", Toast.LENGTH_SHORT).show()
                }
            }
            .setNegativeButton("Otkaži", null)
            .show()
    }

    private fun enableAdminFeatures() {
        val sharedPreferences = getSharedPreferences("admin_prefs", MODE_PRIVATE)
        sharedPreferences.edit().putBoolean("has_admin_access", true).apply()

        Toast.makeText(this, "? Admin pristup omoguæen!", Toast.LENGTH_LONG).show()

        // Otvori Admin panel direktno
        val intent = Intent(this, AdminActivity::class.java)
        startActivity(intent)
        finish()
    }

    private fun loginUser() {
        val email = binding.etEmail.text.toString().trim()
        val password = binding.etPassword.text.toString()

        // Validacija
        if (email.isEmpty() || password.isEmpty()) {
            Toast.makeText(this, "Unesite email i lozinku", Toast.LENGTH_SHORT).show()
            return
        }

        if (!android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
            Toast.makeText(this, "Unesite validan email", Toast.LENGTH_SHORT).show()
            return
        }

        lifecycleScope.launch {
            try {
                val app = application as App
                val hashedPassword = PasswordHasher.hashPassword(password)

                // KORISTI ORIGINALNU METODU (sada je modifikovana sa admin proverom)
                val user = app.userRepository.loginUser(email, hashedPassword)

                runOnUiThread {
                    if (user != null) {
                        // SAÈUVAJ KORISNIÈKI EMAIL U SHARED PREFERENCES
                        val sharedPreferences = getSharedPreferences("user_prefs", MODE_PRIVATE)
                        sharedPreferences.edit().putString("user_email", email).apply()

                        Toast.makeText(
                            this@LoginActivity,
                            "Uspešno ste se prijavili!",
                            Toast.LENGTH_SHORT
                        ).show()

                        // Proveri da li je admin i prebaci na odgovarajuæu aktivnost
                        if (user.role == "ADMIN" || AdminManager.isMasterAdmin(email)) {
                            // Admin ide direktno u Admin panel
                            val intent = Intent(this@LoginActivity, AdminActivity::class.java)
                            startActivity(intent)
                        } else {
                            // Obièan korisnik ide u MainActivity
                            val intent = Intent(this@LoginActivity, MainActivity::class.java)
                            startActivity(intent)
                        }
                        finish()
                    } else {
                        Toast.makeText(
                            this@LoginActivity,
                            "Pogrešan email ili lozinka!",
                            Toast.LENGTH_LONG
                        ).show()
                    }
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(
                        this@LoginActivity,
                        "Greška pri prijavi: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }
} // OVO JE ZATVARAJUÆA ZAGRADA KOJA JE NEDOSTAJALA


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\ui\auth\RegisterActivity.kt

package jovannedeljkovic.gps_tracker_pro.ui.auth

import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import jovannedeljkovic.gps_tracker_pro.App
import jovannedeljkovic.gps_tracker_pro.data.entities.User
import jovannedeljkovic.gps_tracker_pro.databinding.ActivityRegisterBinding
import jovannedeljkovic.gps_tracker_pro.utils.PasswordHasher
import kotlinx.coroutines.launch

class RegisterActivity : AppCompatActivity() {

    private lateinit var binding: ActivityRegisterBinding
    // U deklaracijama varijabli dodaj:

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityRegisterBinding.inflate(layoutInflater)
        setContentView(binding.root)

        setupClickListeners()
    }

    private fun setupClickListeners() {
        // Registracija dugme
        binding.btnRegister.setOnClickListener {
            registerUser()
        }

        // Link ka Login
        binding.tvLoginLink.setOnClickListener {
            startActivity(Intent(this, LoginActivity::class.java))
            finish()
        }
    }

    private fun registerUser() {
        val email = binding.etEmail.text.toString().trim()
        val password = binding.etPassword.text.toString()
        val confirmPassword = binding.etConfirmPassword.text.toString()
        val name = binding.etName.text.toString().trim()
        val phone = binding.etPhone.text.toString().trim()

        // Validacija
        if (!validateInput(email, password, confirmPassword, name, phone)) {
            return
        }

        lifecycleScope.launch {
            try {
                val app = application as App
                val hashedPassword = PasswordHasher.hashPassword(password)

                val user = User(
                    email = email,
                    password = hashedPassword,
                    name = name,
                    phone = phone
                )

                val success = app.userRepository.registerUser(user)

                runOnUiThread {
                    if (success) {
                        // SAÈUVAJTE KORISNIÈKI EMAIL U SHARED PREFERENCES
                        val sharedPreferences = getSharedPreferences("user_prefs", MODE_PRIVATE)
                        sharedPreferences.edit().putString("user_email", email).apply()

                        Toast.makeText(
                            this@RegisterActivity,
                            "Uspešno ste se registrovali!",
                            Toast.LENGTH_LONG
                        ).show()

                        // Prebaci na Login
                        startActivity(Intent(this@RegisterActivity, LoginActivity::class.java))
                        finish()
                    } else {
                        Toast.makeText(
                            this@RegisterActivity,
                            "Email veæ postoji!",
                            Toast.LENGTH_LONG
                        ).show()
                    }
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(
                        this@RegisterActivity,
                        "Greška pri registraciji: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }

    private fun validateInput(
        email: String,
        password: String,
        confirmPassword: String,
        name: String,
        phone: String
    ): Boolean {
        if (email.isEmpty() || password.isEmpty() || confirmPassword.isEmpty()) {
            Toast.makeText(this, "Popunite sva obavezna polja", Toast.LENGTH_SHORT).show()
            return false
        }

        if (!android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
            Toast.makeText(this, "Unesite validan email", Toast.LENGTH_SHORT).show()
            return false
        }

        if (password.length < 6) {
            Toast.makeText(this, "Lozinka mora imati najmanje 6 karaktera", Toast.LENGTH_SHORT).show()
            return false
        }

        if (password != confirmPassword) {
            Toast.makeText(this, "Lozinke se ne poklapaju", Toast.LENGTH_SHORT).show()
            return false
        }

        return true
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\ui\main\MainActivity.kt

package jovannedeljkovic.gps_tracker_pro.ui.main


import android.content.ClipboardManager
import android.content.ClipData
import android.location.Location
import androidx.annotation.RequiresApi
import kotlin.math.*

import com.google.android.material.button.MaterialButton
import org.osmdroid.tileprovider.MapTileProviderBase
import org.osmdroid.util.MapTileIndex
import android.view.Gravity
import android.view.ViewGroup
import android.provider.Settings
import jovannedeljkovic.gps_tracker_pro.utils.AdminManager
import jovannedeljkovic.gps_tracker_pro.ui.admin.AdminActivity
import android.graphics.drawable.ColorDrawable
import android.graphics.Color
import org.osmdroid.views.overlay.Polyline
import android.os.Handler
import android.graphics.Canvas
import android.graphics.Paint
import android.view.LayoutInflater
import android.widget.ProgressBar
import android.widget.TextView
import kotlinx.coroutines.withContext
import kotlinx.coroutines.delay
import org.osmdroid.tileprovider.tilesource.XYTileSource
import org.osmdroid.tileprovider.tilesource.TileSourceFactory
import org.osmdroid.config.Configuration
import android.graphics.drawable.BitmapDrawable
import java.util.*
import kotlinx.coroutines.launch
import androidx.activity.OnBackPressedCallback
import android.os.PowerManager
import android.Manifest
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.net.Uri
import android.os.BatteryManager
import android.os.Bundle
import android.os.Environment
import android.os.Looper
import android.util.Log
import android.view.View
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import androidx.lifecycle.lifecycleScope
import com.google.android.gms.location.*
import org.osmdroid.util.GeoPoint
import org.osmdroid.views.MapView
import org.osmdroid.views.overlay.Marker
import org.osmdroid.views.overlay.compass.CompassOverlay
import org.osmdroid.views.overlay.compass.InternalCompassOrientationProvider
import org.osmdroid.views.overlay.mylocation.GpsMyLocationProvider
import org.osmdroid.views.overlay.mylocation.MyLocationNewOverlay
import jovannedeljkovic.gps_tracker_pro.R
import jovannedeljkovic.gps_tracker_pro.data.entities.LocationPoint
import jovannedeljkovic.gps_tracker_pro.data.entities.PointOfInterest
import jovannedeljkovic.gps_tracker_pro.data.entities.Route
import jovannedeljkovic.gps_tracker_pro.databinding.ActivityMainBinding
import jovannedeljkovic.gps_tracker_pro.utils.NotificationHelper
import android.os.Build
import jovannedeljkovic.gps_tracker_pro.service.TrackingService
import kotlinx.coroutines.Dispatchers
import java.io.File
import java.io.FileWriter
import java.text.SimpleDateFormat
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt
import okhttp3.OkHttpClient
import okhttp3.Request
import com.google.gson.Gson
import org.osmdroid.util.BoundingBox
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.coroutines.delay
import jovannedeljkovic.gps_tracker_pro.App
import jovannedeljkovic.gps_tracker_pro.data.entities.User
import jovannedeljkovic.gps_tracker_pro.utils.FeatureManager
import kotlinx.coroutines.launch
import android.widget.LinearLayout
import android.widget.Button
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.content.BroadcastReceiver
import android.app.Activity
import java.util.*
import android.content.ActivityNotFoundException // DODAJ OVO
import java.nio.charset.Charset // DODAJ OVO
import android.content.ContentUris
import android.provider.MediaStore
import android.text.InputType
import com.google.gson.reflect.TypeToken
import org.json.JSONObject
import java.lang.reflect.Type


data class GpxFileInfo(
    val id: Long,
    val name: String,
    val size: Long,
    val dateModified: Long
)

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding
    private lateinit var fusedLocationClient: FusedLocationProviderClient
    private lateinit var locationRequest: LocationRequest
    private lateinit var locationCallback: LocationCallback
    private var trackingTime: Long = 0L
    // Tracking variables
    private var isTracking = false
    private var trackingStartTime: Long = 0
    private var totalDistance = 0.0
    private var currentRoute: Route? = null
    private val routePoints = mutableListOf<GeoPoint>()
    private var lastLocation: Location? = null
    private var stationaryPoints = 0
    private val stationaryThreshold = 3 // Broj taèaka dok stojimo
    private var isActivityVisible = false
    private var backgroundPointsBuffer = mutableListOf<GeoPoint>()

    private var lastCompassBearing: Float = 0f
    private lateinit var backgroundLocationReceiver: BroadcastReceiver
    private var isReceivingBackgroundUpdates = false
    private var trackingSeconds = 0
    private var isFollowingLocation = false
    private val pointsOfInterest = mutableListOf<PointOfInterest>()
    private var isPointMode = false
    private var pointMarkers = mutableMapOf<String, Marker>()
    private var isMapCentered = false
    private var currentBearing: Float = 0f
    private var myLocationMarker: Marker? = null
    private var isMapOrientationNorth = true  // true = North, false = Follow direction
    private var isAutoFollowEnabled = true     // Auto-follow location
    private val polylines = mutableListOf<Polyline>()
    private lateinit var locationOverlay: MyLocationNewOverlay
    //Kompas
    private var isCompassVisible = false
    private var currentAzimuth: Float = 0f
    private val sensorManager by lazy { getSystemService(Context.SENSOR_SERVICE) as SensorManager }
    private val accelerometer by lazy { sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) }
    private val magnetometer by lazy { sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD) }
    private var wasInBackground = false
    private var lastBackgroundTime: Long = 0L
    private val backgroundThreshold = 10000L // 10 sekundi

    // Lista segmenta rute (umesto jedne rute)
    private val routeSegments = mutableListOf<MutableList<GeoPoint>>()
    private var currentSegment = mutableListOf<GeoPoint>()
    private var gravity = FloatArray(3)
    private var geomagnetic = FloatArray(3)
    private val rotationMatrix = FloatArray(9)
    private val orientation = FloatArray(3)
    // Additional tracking variables
    private var currentSpeed: Double = 0.0
    private var currentAltitude: Double = 0.0
    private var isStationary = false
    private var stationaryStartTime: Long = 0
    private var trackingMode = "self"
    private var savedRoutes = mutableListOf<Route>()

    //private lateinit var btnTrackingModeBottom: Button
    //private lateinit var progressBarBottom: ProgressBar
    //private lateinit var tvBottomTime: TextView
    //private lateinit var tvBottomDistance: TextView
    //private lateinit var tvBottomSpeed: TextView
    // Notification helper
    private lateinit var notificationHelper: NotificationHelper
    private var isSatelliteMode = false

    companion object {
        private const val LOCATION_PERMISSION_REQUEST_CODE = 1001
        private const val IMPORT_GPX_REQUEST_CODE = 2001
        private const val IMPORT_CSV_REQUEST_CODE = 2002
        private const val IMPORT_BACKUP_REQUEST_CODE = 2003
        private const val IMPORT_GPX_POINTS_REQUEST_CODE = 2004
        @RequiresApi(Build.VERSION_CODES.TIRAMISU)
        private const val RECEIVER_NOT_EXPORTED = Context.RECEIVER_NOT_EXPORTED
        private const val REQUEST_CODE_STORAGE_PERMISSION = 1002
        @RequiresApi(Build.VERSION_CODES.TIRAMISU)
        private const val RECEIVER_EXPORTED = Context.RECEIVER_EXPORTED

    }
    private fun showImportFallbackOptions() {
        AlertDialog.Builder(this)
            .setTitle("? Problem sa File Picker-om")
            .setMessage("File Picker nije dostupan. Želite li da:\n\n• Pristupite Download folderu direktno?\n• Proverite dozvole za skladištenje?")
            .setPositiveButton("?? Download Folder") { dialog, which ->
                importGpxFromDownloads()
            }
            .setNeutralButton("?? Proveri Dozvole") { dialog, which ->
                requestStoragePermissions()
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun importGpxRoute(uri: Uri) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Uvoz rute...")
            .setMessage("Uèitavam GPX fajl...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                contentResolver.openInputStream(uri)?.use { inputStream ->
                    val gpxContent = inputStream.bufferedReader().use { it.readText() }

                    // KORISTI NAPREDNI PARSER
                    val allRoutes = parseGpxContentAdvanced(gpxContent)

                    withContext(Dispatchers.Main) {
                        progressDialog.dismiss()

                        if (allRoutes.isNotEmpty()) {
                            if (allRoutes.size == 1) {
                                // Samo jedna ruta - prikaži direktno
                                showImportedRoutePreview(allRoutes.first())
                            } else {
                                // Više ruta - pita? korisnika koju da uveze
                                showRouteSelectionDialog(allRoutes)
                            }
                        } else {
                            Toast.makeText(this@MainActivity, "? Nema taèaka u GPX fajlu", Toast.LENGTH_LONG).show()
                        }
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška pri uvozu GPX: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    private fun showRouteSelectionDialog(routes: List<List<GeoPoint>>) {
        val routeNames = routes.mapIndexed { index, routePoints ->
            "Ruta ${index + 1} (${routePoints.size} taèaka)"
        }.toTypedArray()

        AlertDialog.Builder(this)
            .setTitle("?? Izaberite rutu za uvoz")
            .setMessage("Pronaðeno ${routes.size} ruta u GPX fajlu. Koju želite da uvezete?")
            .setItems(routeNames) { dialog, which ->
                val selectedRoute = routes[which]
                showImportedRoutePreview(selectedRoute, "Uvežena ruta ${which + 1}")
            }
            .setPositiveButton("?? Uvezi prvu rutu") { dialog, which ->
                showImportedRoutePreview(routes.first(), "Uvežena ruta 1")
            }
            .setNeutralButton("?? Uvezi SVE rute") { dialog, which ->  // ?? NOVO DUGME
                importAllRoutesFromGpx(routes)
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun importAllRoutesFromGpx(allRoutes: List<List<GeoPoint>>) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Uvoz svih ruta...")
            .setMessage("Uvozim ${allRoutes.size} ruta...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                var importedCount = 0

                allRoutes.forEachIndexed { index, routePoints ->
                    if (routePoints.isNotEmpty()) {
                        saveImportedRoute(routePoints, "Uvežena ruta ${index + 1}")
                        importedCount++
                    }
                }

                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@MainActivity,
                        "? Uspešno uveženo $importedCount ruta!",
                        Toast.LENGTH_LONG
                    ).show()

                    // Osveži prikaz ruta na mapi
                    loadSavedRoutes()
                    refreshMapAndRoute()
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@MainActivity,
                        "? Greška pri uvozu ruta: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }

    private suspend fun parseGpxContent(gpxContent: String): List<GeoPoint> {
        val points = mutableListOf<GeoPoint>()
        val routes = mutableListOf<List<GeoPoint>>()

        try {
            Log.d("GPXImport", "?? Poèinjem parsiranje GPX fajla")

            // 1. PARSIRAJ SVE TRKSEG (TRACK SEGMENTS)
            val trksegPattern = """<trkseg>([\s\S]*?)</trkseg>""".toRegex()
            val trksegMatches = trksegPattern.findAll(gpxContent)

            trksegMatches.forEachIndexed { segmentIndex, segmentMatch ->
                val segmentContent = segmentMatch.groupValues[1]
                val segmentPoints = mutableListOf<GeoPoint>()

                // Parsiraj taèke unutar ovog segmenta
                val pointPattern = """<trkpt lat="([^"]+)" lon="([^"]+)">""".toRegex()
                val pointMatches = pointPattern.findAll(segmentContent)

                pointMatches.forEach { pointMatch ->
                    val lat = pointMatch.groupValues[1].toDoubleOrNull()
                    val lon = pointMatch.groupValues[2].toDoubleOrNull()
                    if (lat != null && lon != null) {
                        segmentPoints.add(GeoPoint(lat, lon))
                    }
                }

                if (segmentPoints.isNotEmpty()) {
                    routes.add(segmentPoints)
                    Log.d("GPXImport", "?? Segment $segmentIndex: ${segmentPoints.size} taèaka")
                }
            }

            // 2. AKO NEMA TRKSEG, POKUŠAJ SA TRKPT DIRECTLY
            if (routes.isEmpty()) {
                Log.d("GPXImport", "?? Nema trkseg, pokušavam sa trkpt direktno")
                val pointPattern = """<trkpt lat="([^"]+)" lon="([^"]+)">""".toRegex()
                val pointMatches = pointPattern.findAll(gpxContent)

                pointMatches.forEach { pointMatch ->
                    val lat = pointMatch.groupValues[1].toDoubleOrNull()
                    val lon = pointMatch.groupValues[2].toDoubleOrNull()
                    if (lat != null && lon != null) {
                        points.add(GeoPoint(lat, lon))
                    }
                }
                Log.d("GPXImport", "?? Pronaðeno ${points.size} taèaka direktno")
            } else {
                // 3. KORISTI SAMO PRVU RUTU ILI KOMBINUJ SVE
                Log.d("GPXImport", "?? Pronaðeno ${routes.size} ruta/segmenata")

                // Opcija A: Koristi samo prvu rutu (najèešæi scenario)
                points.addAll(routes.first())

                // Opcija B: Kombinuj sve rute u jednu (ako želiš)
                // routes.forEach { routePoints -> points.addAll(routePoints) }
            }

            Log.d("GPXImport", "? Parsiranje završeno: ${points.size} taèaka")

        } catch (e: Exception) {
            Log.e("GPXImport", "?? Greška pri parsiranju GPX: ${e.message}")
        }

        return points
    }
    private suspend fun parseGpxContentAdvanced(gpxContent: String): List<List<GeoPoint>> {
        val allRoutes = mutableListOf<List<GeoPoint>>()

        try {
            Log.d("GPXImport", "?? Napredno parsiranje GPX fajla")

            // 1. PRONAÐI SVE TRK (TRACKS)
            val trkPattern = """<trk>([\s\S]*?)</trk>""".toRegex()
            val trkMatches = trkPattern.findAll(gpxContent)

            trkMatches.forEachIndexed { trackIndex, trackMatch ->
                val trackContent = trackMatch.groupValues[1]
                val trackPoints = mutableListOf<GeoPoint>()

                // Pronaði ime rute
                val namePattern = """<name>([^<]+)</name>""".toRegex()
                val nameMatch = namePattern.find(trackContent)
                val trackName = nameMatch?.groupValues?.get(1) ?: "Ruta ${trackIndex + 1}"

                Log.d("GPXImport", "?? Parsiram rutu: $trackName")

                // Pronaði sve taèke u ovoj rutí
                val pointPattern = """<trkpt lat="([^"]+)" lon="([^"]+)">""".toRegex()
                val pointMatches = pointPattern.findAll(trackContent)

                pointMatches.forEach { pointMatch ->
                    val lat = pointMatch.groupValues[1].toDoubleOrNull()
                    val lon = pointMatch.groupValues[2].toDoubleOrNull()
                    if (lat != null && lon != null) {
                        trackPoints.add(GeoPoint(lat, lon))
                    }
                }

                if (trackPoints.isNotEmpty()) {
                    allRoutes.add(trackPoints)
                    Log.d("GPXImport", "? Ruta '$trackName': ${trackPoints.size} taèaka")
                }
            }

            // 2. AKO NEMA TRK, POKUŠAJ SA TRKSEG
            if (allRoutes.isEmpty()) {
                Log.d("GPXImport", "?? Nema trk, pokušavam sa trkseg")
                val trksegPattern = """<trkseg>([\s\S]*?)</trkseg>""".toRegex()
                val trksegMatches = trksegPattern.findAll(gpxContent)

                trksegMatches.forEachIndexed { segmentIndex, segmentMatch ->
                    val segmentContent = segmentMatch.groupValues[1]
                    val segmentPoints = mutableListOf<GeoPoint>()

                    val pointPattern = """<trkpt lat="([^"]+)" lon="([^"]+)">""".toRegex()
                    val pointMatches = pointPattern.findAll(segmentContent)

                    pointMatches.forEach { pointMatch ->
                        val lat = pointMatch.groupValues[1].toDoubleOrNull()
                        val lon = pointMatch.groupValues[2].toDoubleOrNull()
                        if (lat != null && lon != null) {
                            segmentPoints.add(GeoPoint(lat, lon))
                        }
                    }

                    if (segmentPoints.isNotEmpty()) {
                        allRoutes.add(segmentPoints)
                        Log.d("GPXImport", "? Segment $segmentIndex: ${segmentPoints.size} taèaka")
                    }
                }
            }

            Log.d("GPXImport", "?? Pronaðeno ${allRoutes.size} ruta/segmenata")

        } catch (e: Exception) {
            Log.e("GPXImport", "?? Greška pri naprednom parsiranju: ${e.message}")
        }

        return allRoutes
    }
    private fun importCsvPoints(uri: Uri) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Uvoz taèaka...")
            .setMessage("Uèitavam CSV fajl...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                contentResolver.openInputStream(uri)?.use { inputStream ->
                    val reader = inputStream.bufferedReader()
                    val points = mutableListOf<PointOfInterest>()

                    reader.readLine() // Preskoèi header
                    var line: String?
                    var lineNumber = 1

                    while (reader.readLine().also { line = it } != null) {
                        lineNumber++
                        line?.let { csvLine ->
                            val fields = csvLine.split(",")
                            if (fields.size >= 3) {
                                try {
                                    val name = fields[0].trim()
                                    val lat = fields[1].trim().toDouble()
                                    val lon = fields[2].trim().toDouble()

                                    val point = PointOfInterest(
                                        userId = getCurrentUserId(),
                                        name = name,
                                        latitude = lat,
                                        longitude = lon,
                                        createdAt = System.currentTimeMillis()
                                    )
                                    points.add(point)
                                } catch (e: NumberFormatException) {
                                    Log.w("CSVImport", "Greška u liniji $lineNumber: $csvLine")
                                }
                            }
                        }
                    }

                    withContext(Dispatchers.Main) {
                        progressDialog.dismiss()
                        if (points.isNotEmpty()) {
                            showImportedPointsPreview(points)
                        } else {
                            Toast.makeText(this@MainActivity, "? Nema validnih taèaka u CSV fajlu", Toast.LENGTH_LONG).show()
                        }
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška pri uvozu CSV: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    private fun showImportedRoutePreview(points: List<GeoPoint>, suggestedName: String = "Uvežena ruta") {
        val message = """
    ??? Pronaðena ruta sa ${points.size} taèaka
    
    Prva taèka: ${String.format("%.6f", points.first().latitude)}, ${String.format("%.6f", points.first().longitude)}
    Poslednja taèka: ${String.format("%.6f", points.last().latitude)}, ${String.format("%.6f", points.last().longitude)}
    
    Želite li da saèuvate ovu rutu?
""".trimIndent()

        // Dodaj EditText za ime rute
        val input = EditText(this).apply {
            setText(suggestedName)
            hint = "Unesite ime rute"
        }

        AlertDialog.Builder(this)
            .setTitle("??? Pregled uvezene rute")
            .setMessage(message)
            .setView(input)
            .setPositiveButton("? Saèuvaj rutu") { dialog, which ->
                val routeName = input.text.toString().takeIf { it.isNotBlank() } ?: suggestedName
                saveImportedRoute(points, routeName)
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun showImportedPointsPreview(points: List<PointOfInterest>) {
        AlertDialog.Builder(this)
            .setTitle("??? Pregled uvezenih taèaka")
            .setMessage("Pronaðeno ${points.size} taèaka. Želite li da ih saèuvate?")
            .setPositiveButton("? Saèuvaj sve taèke") { dialog, which ->
                saveImportedPoints(points)
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun saveImportedRoute(points: List<GeoPoint>, routeName: String) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val route = Route(
                    userId = getCurrentUserId(),
                    name = routeName,
                    startTime = System.currentTimeMillis(),
                    distance = calculateRouteDistance(points),
                    duration = 0L,
                    isCompleted = true
                )

                val routeId = app.routeRepository.createRoute(route)

                // Saèuvaj sve taèke rute
                points.forEach { point ->
                    val locationPoint = LocationPoint(
                        routeId = routeId,
                        latitude = point.latitude,
                        longitude = point.longitude,
                        timestamp = System.currentTimeMillis()
                    )
                    app.routeRepository.addLocationPoint(locationPoint)
                }

                withContext(Dispatchers.Main) {
                    Toast.makeText(this@MainActivity, "? Ruta '$routeName' uspešno uvežena!", Toast.LENGTH_LONG).show()
                    // Prikaži rutu na mapi
                    showImportedRouteOnMap(points, routeName)
                    // Osveži listu saèuvanih ruta
                    loadSavedRoutes()
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@MainActivity, "? Greška pri èuvanju rute: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    private fun showRouteDeletionOptions() {
        if (polylines.isEmpty()) {
            Toast.makeText(this, "? Nema prikazanih ruta za brisanje", Toast.LENGTH_SHORT).show()
            return
        }

        val options = arrayOf(
            "??? Obriši sve prikazane rute sa mape",
            "?? Izaberi rutu za brisanje",
            "? Otkaži"
        )

        AlertDialog.Builder(this)
            .setTitle("??? Brisanje ruta sa mape")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> clearAllDisplayedRoutes()  // Obriši sve
                    1 -> showRouteSelectionForDeletion()  // Izaberi pojedinaèno
                    // 2 -> Otkaži
                }
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }
    private fun clearAllDisplayedRoutes() {
        polylines.forEach { polyline ->
            binding.mapView.overlays.remove(polyline)
        }
        polylines.clear()
        binding.mapView.invalidate()

        Toast.makeText(this, "??? Sve prikazane rute obrisane sa mape", Toast.LENGTH_SHORT).show()
    }
    private fun showRouteSelectionForDeletion() {
        if (polylines.isEmpty()) {
            Toast.makeText(this, "? Nema prikazanih ruta", Toast.LENGTH_SHORT).show()
            return
        }

        val routeNames = polylines.mapIndexed { index, _ ->
            "Prikazana ruta ${index + 1}"
        }.toTypedArray()

        AlertDialog.Builder(this)
            .setTitle("?? Izaberite rutu za brisanje")
            .setItems(routeNames) { dialog, which ->
                removeRouteFromMap(which)
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun removeRouteFromMap(index: Int) {
        if (index < polylines.size) {
            val polyline = polylines[index]
            binding.mapView.overlays.remove(polyline)
            polylines.removeAt(index)
            binding.mapView.invalidate()

            Toast.makeText(this, "??? Ruta obrisana sa mape", Toast.LENGTH_SHORT).show()
        }
    }
    private fun saveImportedPoints(points: List<PointOfInterest>) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App

                points.forEach { point ->
                    app.pointRepository.addPoint(point)
                }

                withContext(Dispatchers.Main) {
                    Toast.makeText(this@MainActivity, "? ${points.size} taèaka uspešno uveženo!", Toast.LENGTH_LONG).show()
                    loadPointsOfInterest() // Osveži prikaz taèaka
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@MainActivity, "? Greška pri èuvanju taèaka: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    private fun showImportedRouteOnMap(points: List<GeoPoint>, routeName: String? = null) {
        try {
            if (points.isNotEmpty()) {
                binding.mapView.controller.animateTo(points.first())
                binding.mapView.controller.setZoom(16.0)
            }

            val polyline = Polyline().apply {
                setPoints(points)

                // Razlièite boje za razlièite tipove ruta
                outlinePaint.color = when {
                    routeName?.contains("uvezen", ignoreCase = true) == true -> Color.parseColor("#FF4CAF50") // Zelena
                    routeName?.contains("snimljena", ignoreCase = true) == true -> Color.parseColor("#FF2196F3") // Plava
                    else -> Color.parseColor("#FFFF9800") // Narandžasta
                }

                outlinePaint.strokeWidth = 10.0f
                outlinePaint.style = Paint.Style.STROKE
            }

            binding.mapView.overlays.add(polyline)
            polylines.add(polyline)
            binding.mapView.invalidate()

            val message = if (routeName != null) {
                "??? Ruta '$routeName' prikazana na mapi"
            } else {
                "??? Ruta prikazana na mapi"
            }

            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()

        } catch (e: Exception) {
            Log.e("RouteDisplay", "Greška pri prikazu rute: ${e.message}")
        }
    }
    private fun calculateRouteDistance(points: List<GeoPoint>): Double {
        var totalDistance = 0.0
        for (i in 1 until points.size) {
            totalDistance += points[i-1].distanceToAsDouble(points[i])
        }
        return totalDistance
    }

    private fun importBackupData(uri: Uri) {
        Toast.makeText(this, "?? Funkcionalnost za backup u izradi...", Toast.LENGTH_LONG).show()

        // Za sada samo prikažite poruku
        AlertDialog.Builder(this)
            .setTitle("?? Uvoz Backup Podataka")
            .setMessage("Ova funkcionalnost æe biti dostupna u narednoj verziji aplikacije.\n\n" +
                    "Planirane moguænosti:\n" +
                    "• Uvoz ruta iz GPX/JSON\n" +
                    "• Uvoz taèaka interesa\n" +
                    "• Restauracija celokupnih podataka")
            .setPositiveButton("OK", null)
            .show()
    }

    private fun showBackupImportDialog(jsonObject: JSONObject) {
        val backupInfo = """
        ?? Podaci u backup fajlu:
        
        ?? Datum backup-a: ${jsonObject.optString("backupDate", "Nepoznato")}
        ?? Verzija aplikacije: ${jsonObject.optString("appVersion", "Nepoznato")}
        
        Izaberite šta želite da uvezete:
    """.trimIndent()

        AlertDialog.Builder(this)
            .setTitle("?? Opcije uvoza backup-a")
            .setMessage(backupInfo)
            .setPositiveButton("??? Samo moje rute i taèke") { dialog, which ->
                importUserDataFromBackup(jsonObject)
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun importUserDataFromBackup(jsonObject: JSONObject) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Uvoz podataka...")
            .setMessage("Uvozim rute i taèke...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val gson = Gson()

                // Uvezi rute
                if (jsonObject.has("routes")) {
                    val routesJson = jsonObject.getJSONArray("routes").toString()
                    val routesType: Type = object : TypeToken<List<Route>>() {}.type
                    val routes: List<Route> = gson.fromJson(routesJson, routesType)

                    routes.forEach { route ->
                        // Ažuriraj userId na trenutnog korisnika
                        val updatedRoute = route.copy(userId = getCurrentUserId())
                        app.routeRepository.createRoute(updatedRoute)
                    }
                }

                // Uvezi taèke
                if (jsonObject.has("points")) {
                    val pointsJson = jsonObject.getJSONArray("points").toString()
                    val pointsType: Type = object : TypeToken<List<PointOfInterest>>() {}.type
                    val points: List<PointOfInterest> = gson.fromJson(pointsJson, pointsType)

                    points.forEach { point ->
                        // Ažuriraj userId na trenutnog korisnika
                        val updatedPoint = point.copy(userId = getCurrentUserId())
                        app.pointRepository.addPoint(updatedPoint)
                    }
                }

                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@MainActivity,
                        "? Podaci uspešno uvezeni!",
                        Toast.LENGTH_LONG
                    ).show()

                    // Osveži prikaz
                    loadPointsOfInterest()
                    loadSavedRoutes()
                    refreshMapAndRoute()
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@MainActivity,
                        "? Greška pri uvozu: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }
    private fun showBackupImportOptions(backupData: BackupData) {
        val message = """
        ?? Pronaðeni podaci u backup-u:
        
        ?? Korisnici: ${backupData.users.size}
        ??? Rute: ${backupData.routes.size}
        ?? Taèke: ${backupData.points.size}
        ?? Datum backup-a: ${SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault()).format(Date(backupData.backupDate))}
        ?? Verzija aplikacije: ${backupData.appVersion}
        
        ?? Pažnja: Ovim æete zameniti trenutne podatke!
        
        Izaberite opciju uvoza:
    """.trimIndent()

        AlertDialog.Builder(this)
            .setTitle("?? Opcije uvoza backup-a")
            .setMessage(message)
            .setPositiveButton("? Uvezi SVE podatke") { dialog, which ->
                importAllBackupData(backupData)
            }
            /*.setNeutralButton("?? Samo korisnike") { dialog, which ->
                importUsersFromBackup(backupData.users)
            }*/
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    // Dodajte BackupData klase:
    data class BackupData(
        val users: List<User>,
        val routes: List<Route>,
        val points: List<PointOfInterest>,
        val backupDate: Long,
        val appVersion: String
    )


    private fun importAllBackupData(backupData: BackupData) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Uvoz svih podataka...")
            .setMessage("Molimo saèekajte...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App

                // 1. Obriši sve postojeæe podatke
                val currentUserId = getCurrentUserId()

                // 2. Uvezi korisnike
                backupData.users.forEach { user ->
                    app.userRepository.registerUser(user)
                }

                // 3. Uvezi rute
                backupData.routes.forEach { route ->
                    app.routeRepository.createRoute(route)
                }

                // 4. Uvezi taèke
                backupData.points.forEach { point ->
                    app.pointRepository.addPoint(point)
                }

                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@MainActivity,
                        "? Uspešno uvezeno ${backupData.users.size} korisnika, ${backupData.routes.size} ruta i ${backupData.points.size} taèaka!",
                        Toast.LENGTH_LONG
                    ).show()

                    // Osveži prikaz
                    loadPointsOfInterest()
                    loadSavedRoutes()
                    refreshMapAndRoute()
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@MainActivity,
                        "? Greška pri uvozu: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }
    private fun showDeleteAllDataDialog() {
        AlertDialog.Builder(this)
            .setTitle("?? Brisanje svih podataka")
            .setMessage("Da li ste sigurni da želite da obrišete SVE rute i taèke? Ova akcija se ne može poništiti!")
            .setPositiveButton("??? Obriši sve") { dialog, which ->
                deleteAllData()
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun deleteAllData() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App

                // Obriši sve rute i taèke
                val userRoutes = app.routeRepository.getUserRoutes(getCurrentUserId())
                userRoutes.forEach { route ->
                    app.routeRepository.deleteRoute(route)
                }

                val userPoints = app.pointRepository.getUserPoints(getCurrentUserId())
                userPoints.forEach { point ->
                    app.pointRepository.deletePoint(point)
                }

                withContext(Dispatchers.Main) {
                    // Oèisti mapu
                    binding.mapView.overlays.clear()
                    binding.mapView.invalidate()

                    Toast.makeText(this@MainActivity, "? Svi podaci obrisani", Toast.LENGTH_LONG).show()
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@MainActivity, "? Greška pri brisanju: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
      private fun checkBatteryOptimization() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
            if (!powerManager.isIgnoringBatteryOptimizations(packageName)) {
                Log.d("Battery", "?? Aplikacija nije izuzeta iz optimizacije baterije")
                // Opciono: možete pokazati dialog korisniku kasnije
            } else {
                Log.d("Battery", "? Aplikacija je izuzeta iz optimizacije baterije")
            }
        }
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        if (!::binding.isInitialized) {
            Log.e("MainActivity", "Binding nije uspešno inicijalizovan!")
            finish()
            return
        }

        notificationHelper = NotificationHelper(this)

        // DODAJTE OVO - postavka receivera
        setupBackgroundLocationReceiver()

        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                showExitConfirmationDialog()
            }
        })

        initializeMap()
        isAutoFollowEnabled = true
        locationOverlay.enableFollowLocation()
        setupEnhancedMapConfiguration()

        initializeLocationClient()
        setupClickListeners()  // ILI safeButtonSetup() ako koristiš tu metodu
        setupPointOfInterestMode()
        loadPointsOfInterest()
        loadSavedRoutes()
        checkLocationPermissions()
        disableAccuracyCircle()
        checkBatteryOptimization()
        checkUserFeatures()

        // DODAJ OVDE - POSLEDNJE PRE HANDLER-A:
        setupCompass()
        val filter = IntentFilter("LOCATION_UPDATE")
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            registerReceiver(locationReceiver, filter, RECEIVER_NOT_EXPORTED)
        } else {
            registerReceiver(locationReceiver, filter)
        }
        Handler(Looper.getMainLooper()).postDelayed({
            getBestLocation()
        }, 2000)
    }
    private fun getMapView(): MapView? {
        return if (::binding.isInitialized && binding.mapView != null) {
            binding.mapView
        } else {
            Log.w("MapView", "MapView nije dostupan")
            null
        }
    }
    private fun setupBackgroundLocationReceiver() {
        backgroundLocationReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                if (intent.action == "BACKGROUND_LOCATION_UPDATE") {
                    val latitude = intent.getDoubleExtra("latitude", 0.0)
                    val longitude = intent.getDoubleExtra("longitude", 0.0)
                    val accuracy = intent.getFloatExtra("accuracy", 0f)
                    val speed = intent.getFloatExtra("speed", 0f)

                    val location = Location("background_service").apply {
                        this.latitude = latitude
                        this.longitude = longitude
                        this.accuracy = accuracy
                        this.speed = speed
                    }

                    // AŽURIRAJTE RUTU SA POZADINSKOM LOKACIJOM
                    if (isTracking) {
                        val geoPoint = GeoPoint(latitude, longitude)

                        // DODAJ U GLAVNE LISTE TAÈAKA
                        routePoints.add(geoPoint)
                        currentSegment.add(geoPoint)

                        // AŽURIRAJ STATISTIKE
                        updateDistanceAndSpeedAccurate(location)

                        // SAÈUVAJ U BAZU
                        savePointToDatabase(geoPoint)

                        // OVDE JE KLJUÈNO: OSVEŽI MAPU AKO JE APLIKACIJA VIDLJIVA
                        if (isActivityVisible) {
                            runOnUiThread {
                                drawSmoothRouteOnMap()
                                Log.d("BackgroundTracking", "?? Map osvežena sa pozadinskom taèkom")
                            }
                        } else {
                            Log.d("BackgroundTracking", "?? Taèka saèuvana, mapa æe se osvežiti pri povratku")
                        }

                        Log.d("BackgroundTracking", "?? Pozadinska taèka dodata: ${String.format("%.6f", latitude)}, ${String.format("%.6f", longitude)}")
                    }
                }
            }
        }
    }

    private fun setupCompass() {
        binding.btnCompass.setOnClickListener {
            toggleCompassVisibility()
        }

        // Pokreni ažuriranje kompasa
        startCompassUpdates()
    }


    private fun toggleCompass() {
        isCompassVisible = !isCompassVisible

        if (isCompassVisible) {
            startCompass()
            //binding.compassView.visibility = View.VISIBLE
            binding.compassNeedle.visibility = View.VISIBLE
            Toast.makeText(this, "?? Kompas ukljuèen", Toast.LENGTH_SHORT).show()
        } else {
            stopCompass()
            //binding.compassView.visibility = View.GONE
            binding.compassNeedle.visibility = View.GONE
            Toast.makeText(this, "?? Kompas iskljuèen", Toast.LENGTH_SHORT).show()
        }
    }

    private fun startCompass() {
        sensorManager.registerListener(sensorListener, accelerometer, SensorManager.SENSOR_DELAY_UI)
        sensorManager.registerListener(sensorListener, magnetometer, SensorManager.SENSOR_DELAY_UI)
    }

    private fun stopCompass() {
        sensorManager.unregisterListener(sensorListener)
    }

    private val sensorListener = object : SensorEventListener {
        override fun onSensorChanged(event: SensorEvent) {
            when (event.sensor.type) {
                Sensor.TYPE_ACCELEROMETER -> gravity = event.values.clone()
                Sensor.TYPE_MAGNETIC_FIELD -> geomagnetic = event.values.clone()
            }

            if (SensorManager.getRotationMatrix(rotationMatrix, null, gravity, geomagnetic)) {
                SensorManager.getOrientation(rotationMatrix, orientation)
                val azimuth = Math.toDegrees(orientation[0].toDouble()).toFloat()

                updateCompass(azimuth)
            }
        }

        override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}
    }

    private fun updateCompass(azimuth: Float) {
        currentAzimuth = azimuth

        // Rotiraj celu osnovu kompasa (pokazuje sever)
        //binding.compassView.rotation = -azimuth

        // Kombinuj sa smerom kretanja ako se kreæeš
        val finalRotation = if (lastLocation?.hasBearing() == true) {
            -azimuth // Samo kompas (pokazuje sever)
        } else {
            -azimuth // Samo kompas
        }

        //binding.compassView.rotation = finalRotation
        binding.compassNeedle.rotation = finalRotation
    }

    private fun toggleCompassVisibility() {
        isCompassVisible = !isCompassVisible
        binding.btnCompass.visibility = if (isCompassVisible) View.VISIBLE else View.GONE

        Toast.makeText(this,
            if (isCompassVisible) "?? Kompas ukljuèen" else "?? Kompas iskljuèen",
            Toast.LENGTH_SHORT
        ).show()
    }

    private fun startCompassUpdates() {
        val handler = Handler(Looper.getMainLooper())

        val compassRunnable = object : Runnable {
            override fun run() {
                if (isCompassVisible && lastLocation != null && lastLocation!!.hasBearing()) {
                    updateCompassRotation(lastLocation!!.bearing)
                }
                handler.postDelayed(this, 100) // Ažuriraj svakih 100ms
            }
        }
        handler.post(compassRunnable)
    }

    private fun updateCompassRotation(bearing: Float) {
        if (bearing != lastCompassBearing) {
            binding.btnCompass.rotation = -bearing // Kompas se rotira suprotno od smera
            lastCompassBearing = bearing
        }
    }

    private fun checkOfflineTiles() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val satelliteDir = File(Configuration.getInstance().osmdroidBasePath, "tiles/World_Imagery")
                val tileCount = countTilesInDirectory(satelliteDir)

                withContext(Dispatchers.Main) {
                    Log.d("TileCheck", "?? Ukupno satelitskih tile-ova: $tileCount")
                    if (tileCount > 0) {
                        Toast.makeText(this@MainActivity, "? Ima $tileCount tile-ova", Toast.LENGTH_SHORT).show()
                    } else {
                        Toast.makeText(this@MainActivity, "? Nema tile-ova!", Toast.LENGTH_SHORT).show()
                    }
                }
            } catch (e: Exception) {
                Log.e("TileCheck", "Greška: ${e.message}")
            }
        }
    }
// DODAJ OVE METODE ISPOD onCreate:
private fun checkButtonAvailability() {
    val buttons = listOf(
        "btnStartTracking" to binding.btnStartTracking,
        "btnStopTracking" to binding.btnStopTracking,
        "btnMyLocation" to binding.btnMyLocation,
        "btnMenu" to binding.btnMenu,
        "btnSavedRoutes" to binding.btnSavedRoutes,
        "btnZoomIn" to binding.btnZoomIn,
        "btnZoomOut" to binding.btnZoomOut,
        "fabAddPoint" to binding.fabAddPoint,
        "btnTrackingMode" to binding.btnTrackingMode,
        "btnNavigation" to binding.btnNavigation,
        "btnMapType" to binding.btnMapType,
        "btnExport" to binding.btnExport,
        "btnReset" to binding.btnReset
    )

    buttons.forEach { (name, button) ->
        if (button == null) {
            Log.w("ButtonCheck", "Dugme $name je NULL")
        } else {
            Log.d("ButtonCheck", "Dugme $name je dostupno")
        }
    }
}
    private fun setupEnhancedMapConfiguration() {
        try {
            // POBOLJŠANA KONFIGURACIJA ZA BOLJI QUALITY
            Configuration.getInstance().apply {
                userAgentValue = packageName
                cacheMapTileCount = 3000  // Poveæan cache
                tileDownloadThreads = 4   // Više threadova za download
                tileFileSystemThreads = 3
                tileDownloadMaxQueueSize = 200
            }

            // PODEŠAVANJA ZA BOLJU OŠTRINU
            binding.mapView.apply {
                setMultiTouchControls(true)
                minZoomLevel = 3.0
                maxZoomLevel = 22.0  // Poveæan max zoom za više detalja
                setTilesScaledToDpi(true)
                setUseDataConnection(true)
                isHorizontalMapRepetitionEnabled = true
                isVerticalMapRepetitionEnabled = true
                isTilesScaledToDpi = true

                // BITNO: Omoguæi hardware acceleration za bolju performance
                setLayerType(View.LAYER_TYPE_HARDWARE, null)
            }

            Log.d("MapConfig", "Enhanced map configuration uspešno postavljena")

        } catch (e: Exception) {
            Log.e("MapConfig", "Greška pri map konfiguraciji: ${e.message}")
            Toast.makeText(this, "Upozorenje: Neke map opcije možda neæe raditi optimalno", Toast.LENGTH_SHORT).show()
        }
    }




    private fun optimizeTileCacheForZoom(zoom: Double) {
        val config = Configuration.getInstance()
        when {
            zoom > 20.0 -> {
                config.cacheMapTileCount = 6000
                config.tileDownloadThreads = 4
                Log.d("ZoomOptimize", "Ultra high zoom optimization")
            }
            zoom > 18.0 -> {
                config.cacheMapTileCount = 4000
                config.tileDownloadThreads = 3
                Log.d("ZoomOptimize", "High zoom optimization")
            }
            else -> {
                config.cacheMapTileCount = 2000
                config.tileDownloadThreads = 2
            }
        }
    }


    private fun showZoomLevel(zoom: Double) {
        // Prikazuj zoom level samo ako je veæi od 15 (kad postane bitan)
        if (zoom >= 15.0) {
            val zoomText = when {
                zoom > 20.0 -> "?? Ultra Zoom: ${String.format("%.1f", zoom)}x"
                zoom > 18.0 -> "?? High Zoom: ${String.format("%.1f", zoom)}x"
                else -> "?? Zoom: ${String.format("%.1f", zoom)}x"
            }

            // Koristi kratki toast samo za visoke zoom levele
            if (zoom > 18.0) {
                Toast.makeText(this, zoomText, Toast.LENGTH_SHORT).show()
            }
        }
    }
    private fun showZoomInfo(zoom: Double) {
        // Prikazuj zoom level samo ako je veæi od 16 (kad postane bitan)
        if (zoom >= 16.0) {
            val zoomText = when {
                zoom > 20.0 -> "?? Ultra Zoom: ${String.format("%.1f", zoom)}x"
                zoom > 18.0 -> "?? High Zoom: ${String.format("%.1f", zoom)}x"
                else -> "?? Zoom: ${String.format("%.1f", zoom)}x"
            }

            // Koristi kratki toast samo za visoke zoom levele
            if (zoom > 18.0) {
                Toast.makeText(this, zoomText, Toast.LENGTH_SHORT).show()
            }
        }
    }
    private fun setHighQualityStandardMap() {
        try {
            binding.mapView.setTileSource(TileSourceFactory.MAPNIK)
            binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)
            binding.mapView.maxZoomLevel = 22.0

            // PODEŠAVANJA ZA BOLJU OŠTRINU
            binding.mapView.setTilesScaledToDpi(true)
            binding.mapView.setBackgroundColor(Color.WHITE)

            Toast.makeText(this, "??? OSM Standard (High Quality)", Toast.LENGTH_LONG).show()
            binding.mapView.invalidate()
        } catch (e: Exception) {
            Log.e("MapType", "Standard mapa nije dostupna: ${e.message}")
            setStandardMap()
        }
    }

    private fun initializeLocationClient() {
        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)

        locationRequest = LocationRequest.Builder(
            Priority.PRIORITY_HIGH_ACCURACY,
            2000L
        )
            .setMinUpdateIntervalMillis(1000L)
            .setWaitForAccurateLocation(true)
            .setMinUpdateDistanceMeters(2.0f)
            .build()

        locationCallback = object : LocationCallback() {
            override fun onLocationResult(locationResult: LocationResult) {
                val location = locationResult.lastLocation ?: return

                if (location.accuracy < 20.0f && location.accuracy > 0 && location.speed >= 0) {
                    val currentLocation = GeoPoint(location.latitude, location.longitude)

                    // AŽURIRAJ PODATKE
                    currentSpeed = location.speed * 3.6
                    currentAltitude = location.altitude
                    currentBearing = location.bearing

                    // ? AŽURIRAJ ORIJENTACIJU MAPE AKO JE OMOGUÆENO
                    if (location.hasBearing() && !isMapOrientationNorth) {
                        updateMapOrientation(location.bearing)
                    }
                    if (isCompassVisible && location.hasBearing()) {
                        updateCompassRotation(location.bearing)
                    }

                    // ? AUTO-CENTRIRANJE AKO JE OMOGUÆENO
                    if (isAutoFollowEnabled) {
                        // PROVERI DA LI JE MAPA INICIJALIZOVANA
                        if (::binding.isInitialized && binding.mapView != null) {
                            binding.mapView.controller.animateTo(currentLocation)
                        }
                    }

                    // PRIKAŽI SAMO JEDNU TAÈNU LOKACIJU - SA PROVEROM
                    if (::binding.isInitialized && binding.mapView != null) {
                        showAccurateLocationMarker(currentLocation, location)
                    }

                    // TRACKING FUNKCIONALNOST
                    if (isTracking) {
                        addPointToRouteSmoothly(currentLocation, location)
                        updateDistanceAndSpeedAccurate(location)
                        updateTrackingNotification()
                        updateAccuracyProgress()
                    }

                    lastLocation = location
                }
            }
        }
    }
    private fun updateDistanceAndSpeedAccurate(newLocation: Location) {
        lastLocation?.let { lastLoc ->
            // KORISTI ANDROID-OVU distanceTo METODU - NAJPRECIZNIJA
            val distance = lastLoc.distanceTo(newLocation).toDouble()

            // KORISTI GPS BRZINU - NAJPRECIZNIJA
            val speed = if (newLocation.hasSpeed() && newLocation.speed > 0) {
                newLocation.speed * 3.6 // konvertuj u km/h
            } else {
                0.0
            }

            // JEDNOSTAVNO FILTRIRANJE - samo oèigledne greške
            if (distance > 1.0 && distance < 500.0) {
                totalDistance += distance
                currentSpeed = speed

                Log.d("Tracking", "?? +${String.format("%.1f", distance)}m | Ukupno: ${formatDistance(totalDistance)} | ?? Brzina: ${String.format("%.1f", speed)} km/h")
            } else {
                currentSpeed = speed
                Log.d("Tracking", "?? Preskoèeno: ${String.format("%.1f", distance)}m (GPS greška)")
            }

            updateTrackingStats(totalDistance, currentSpeed)

        } ?: run {
            // PRVA LOKACIJA
            currentSpeed = if (newLocation.hasSpeed() && newLocation.speed > 0) {
                newLocation.speed * 3.6
            } else {
                0.0
            }
            updateTrackingStats(totalDistance, currentSpeed)
            Log.d("Tracking", "?? Prva lokacija | Brzina: ${String.format("%.1f", currentSpeed)} km/h")
        }

        lastLocation = newLocation
    }
    private fun enableSatelliteOfflineMode(regionName: String) {
        try {
            // PROVERITE DA LI POSTOJE PREUZETI TILE-OVI
            val satelliteDir = File(Configuration.getInstance().osmdroidBasePath, "tiles/World_Imagery")

            if (!satelliteDir.exists()) {
                Toast.makeText(this, "? Nema preuzetih satelitskih tile-ova!", Toast.LENGTH_LONG).show()
                return
            }

            // Prebrojite tile-ove za debug
            val tileCount = countTilesInDirectory(satelliteDir)
            Log.d("SatelliteOffline", "?? Pronaðeno $tileCount tile-ova u: ${satelliteDir.absolutePath}")

            if (tileCount == 0) {
                Toast.makeText(this, "? Nema preuzetih satelitskih tile-ova!", Toast.LENGTH_LONG).show()
                return
            }

            // KREIRAJ CUSTOM TILE SOURCE
            val satelliteTileSource = createSatelliteTileSource()

            // PODEŠAVANJA ZA OFFLINE MOD
            binding.mapView.setTileSource(satelliteTileSource)
            binding.mapView.setUseDataConnection(false) // ISKLJUÈI INTERNET
            binding.mapView.getTileProvider().clearTileCache()

            // OSVEŽI PRIKAZ
            binding.mapView.invalidate()
            binding.mapView.postInvalidate()

            // PRIKAŽI INFORMACIJE
            binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)
            Toast.makeText(this, "??? Offline Satelitski: $regionName ($tileCount tile-ova)", Toast.LENGTH_LONG).show()

            Log.d("SatelliteOffline", "? Offline satelitski mod aktiviran sa $tileCount tile-ova")

        } catch (e: Exception) {
            Log.e("SatelliteOffline", "?? Greška: ${e.message}")
            Toast.makeText(this, "? Greška: ${e.message}", Toast.LENGTH_SHORT).show()
            setHighQualityStandardMap()
        }
    }
    private fun debugSatelliteTiles() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val satelliteDir = File(Configuration.getInstance().osmdroidBasePath, "tiles/World_Imagery")

                Log.d("TileDebug", "=== ??? SATELLITE TILE DEBUG ===")
                Log.d("TileDebug", "?? Cache dir exists: ${satelliteDir.exists()}")
                Log.d("TileDebug", "?? Cache dir path: ${satelliteDir.absolutePath}")

                if (satelliteDir.exists()) {
                    var tileCount = 0
                    satelliteDir.walk().forEach { file ->
                        if (file.isFile && file.name.endsWith(".png")) {
                            tileCount++
                            if (tileCount <= 10) {
                                Log.d("TileDebug", "?? Found tile: ${file.absolutePath} (${file.length()} bytes)")
                            }
                        }
                    }
                    Log.d("TileDebug", "?? Total tiles found: $tileCount")

                    withContext(Dispatchers.Main) {
                        if (tileCount == 0) {
                            Toast.makeText(this@MainActivity, "? Nema tile-ova u cache-u!", Toast.LENGTH_LONG).show()
                        } else {
                            Toast.makeText(this@MainActivity, "? Pronaðeno $tileCount tile-ova", Toast.LENGTH_LONG).show()
                        }
                    }
                } else {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@MainActivity, "? Cache folder ne postoji!", Toast.LENGTH_LONG).show()
                    }
                }

            } catch (e: Exception) {
                Log.e("TileDebug", "?? Debug error: ${e.message}")
            }
        }
    }
    private fun testSatelliteDownload() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                Log.d("TestDownload", "?? POÈINJEM TEST SATELITSKOG PREUZIMANJA...")

                // Preuzmite jedan tile za Niš
                val zoom = 14
                val x = 8800  // Koordinate za Niš
                val y = 5700

                Log.d("TestDownload", "?? Preuzimam tile za Niš: $zoom/$x/$y")
                downloadSatelliteSingleTile(x, y, zoom)

                // Proverite da li je saèuvan
                val tileFile = File(Configuration.getInstance().osmdroidBasePath, "tiles/World_Imagery/$zoom/$x/$y.png")

                withContext(Dispatchers.Main) {
                    if (tileFile.exists()) {
                        Toast.makeText(this@MainActivity, "? Test tile uspešno preuzet!", Toast.LENGTH_LONG).show()
                        debugSatelliteTiles()
                    } else {
                        Toast.makeText(this@MainActivity, "? Test tile nije saèuvan!", Toast.LENGTH_LONG).show()
                    }
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@MainActivity, "?? Greška: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    /*private fun debugSatelliteTiles(regionName: String) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val satelliteDir = File(Configuration.getInstance().osmdroidBasePath, "tiles/World_Imagery")

                Log.d("TileDebug", "=== SATELLITE TILE DEBUG ===")
                Log.d("TileDebug", "Cache dir exists: ${satelliteDir.exists()}")
                Log.d("TileDebug", "Cache dir path: ${satelliteDir.absolutePath}")

                if (satelliteDir.exists()) {
                    var tileCount = 0
                    satelliteDir.walk().forEach { file ->
                        if (file.isFile && file.name.endsWith(".png")) {
                            tileCount++
                            if (tileCount <= 5) { // Prikaži prvih 5
                                Log.d("TileDebug", "Found tile: ${file.absolutePath}")
                            }
                        }
                    }
                    Log.d("TileDebug", "Total tiles found: $tileCount")

                    withContext(Dispatchers.Main) {
                        if (tileCount == 0) {
                            Toast.makeText(this@MainActivity, "?? Nema tile-ova u cache-u!", Toast.LENGTH_LONG).show()
                        } else {
                            Toast.makeText(this@MainActivity, "? Pronaðeno $tileCount tile-ova", Toast.LENGTH_LONG).show()
                        }
                    }
                }

            } catch (e: Exception) {
                Log.e("TileDebug", "Debug error: ${e.message}")
            }
        }
    }*/
    private fun checkSatelliteTilesAvailable(regionName: String): Int {
        return try {
            val cacheDir = File(filesDir, "osmdroid/tiles/World_Imagery")
            val tileCount = countTilesInDirectory(cacheDir)

            Log.d("TileCheck", "Satelitski tile-ovi dostupni: $tileCount, putanja: ${cacheDir.absolutePath}")

            tileCount
        } catch (e: Exception) {
            Log.e("TileCheck", "Greška pri proveri tile-ova: ${e.message}")
            0
        }
    }
    private fun showSatelliteMapsList() {
        val metadataDir = File(getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), "offline_regions")
        val regionFiles = metadataDir.listFiles { file ->
            file.name.endsWith(".json") && file.readText().contains("isSatellite")
        }

        if (!metadataDir.exists() || regionFiles.isNullOrEmpty()) {
            Toast.makeText(this, "?? Nema preuzetih satelitskih mapa", Toast.LENGTH_LONG).show()
            downloadOfflineMap() // Ponudi preuzimanje
            return
        }

        val regionNames = regionFiles.map { file ->
            try {
                val metadata = Gson().fromJson(file.readText(), Map::class.java)
                "??? ${metadata["regionName"]} (${metadata["tileCount"]} tile-ova)"
            } catch (e: Exception) {
                "? Nevažeæa satelitska mapa"
            }
        }.toTypedArray()

        AlertDialog.Builder(this)
            .setTitle("?? Preuzete Satelitske Mape")
            .setItems(regionNames) { dialog, which ->
                val selectedFile = regionFiles[which]
                try {
                    val metadata = Gson().fromJson(selectedFile.readText(), Map::class.java)
                    val regionName = metadata["regionName"] as String
                    enableSatelliteOfflineMode(regionName)
                } catch (e: Exception) {
                    Toast.makeText(this, "? Greška pri uèitavanju", Toast.LENGTH_SHORT).show()
                }
            }
            .setPositiveButton("? Preuzmi Novu") { dialog, which ->
                downloadOfflineMap()
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }
    private fun checkOfflineTilesAvailable(regionName: String): Boolean {
        return try {
            val isSatellite = regionName.contains("satelit", ignoreCase = true) ||
                    regionName.contains("satellite", ignoreCase = true)

            val cacheDir = if (isSatellite) {
                File(Configuration.getInstance().osmdroidBasePath, "tiles/World_Imagery")
            } else {
                File(Configuration.getInstance().osmdroidBasePath, "tiles/OpenStreetMap")
            }

            cacheDir.exists() && cacheDir.listFiles()?.isNotEmpty() == true
        } catch (e: Exception) {
            false
        }
    }

    /*private fun deleteUserWithAllData(user: User) {
        AlertDialog.Builder(this)
            .setTitle("??? Brisanje korisnika")
            .setMessage("Da li ste sigurni da želite da obrišete korisnika ${user.email}?\n\n" +
                    "Ova akcija æe obrisati:\n" +
                    "?? Sve rute korisnika\n" +
                    "?? Sve taèke interesa\n" +
                    "?? Korisnièki nalog\n\n" +
                    "?? Ova akcija se NE MOŽE poništiti!")
            .setPositiveButton("??? Obriši") { dialog, which ->
                performUserDeletion(user)
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun performUserDeletion(user: User) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Brisanje u toku...")
            .setMessage("Brišem korisnika i sve podatke...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App

                // 1. Obriši sve rute korisnika
                val userRoutes = app.routeRepository.getUserRoutes(user.id)
                userRoutes.forEach { route ->
                    // Prvo obriši sve taèke rute
                    app.routeRepository.deleteRoutePoints(route.id)
                    // Onda obriši rutu
                    app.routeRepository.deleteRoute(route)
                }

                // 2. Obriši sve taèke interesa
                val userPoints = app.pointRepository.getUserPoints(user.id)
                userPoints.forEach { point ->
                    app.pointRepository.deletePoint(point)
                }

                // 3. Obriši korisnika
                app.userRepository.deleteUser(user.id)

                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@AdminActivity,  // ? ISPRAVNO: Dodajte @
                        "? Korisnik ${user.email} uspešno obrisan sa svim podacima!",
                        Toast.LENGTH_LONG
                    ).show()
                    loadUsers() // Osveži listu
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(
                        this@AdminActivity,
                        "? Greška pri brisanju: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }*/
    private fun showNavigationMenu() {
        val options = arrayOf(
            "??? Offline Mape",
            "??? Alatke",
            "?? Kompas",
            "?? Režim praæenja",
            "?? Podešavanja",
            "?? Admin Panel",
            "?? Odjava"
        )

        AlertDialog.Builder(this)
            .setTitle("?? Navigacioni Meni")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> showOfflineMapsDialog()
                    1 -> showToolsDialog()
                    2 -> toggleCompass()
                    3 -> toggleTrackingMode()
                    4 -> showSettings()
                    5 -> showAdminLoginDialog()
                    6 -> logout()
                }
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }

    private fun showAdminLoginDialog() {
        val editText = EditText(this).apply {
            hint = "?? Unesite Admin secret key"
            inputType = InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_PASSWORD
        }

        AlertDialog.Builder(this)
            .setTitle("?? Admin Panel Pristup")
            .setMessage("Za pristup Admin panelu unesite secret key:")
            .setView(editText)
            .setPositiveButton("?? Uloguj se") { dialog, _ ->
                val code = editText.text.toString().trim()
                if (code == "ADMIN123") {
                    // Saèuvaj admin pristup
                    val sharedPreferences = getSharedPreferences("admin_prefs", MODE_PRIVATE)
                    sharedPreferences.edit().putBoolean("has_admin_access", true).apply()

                    // Otvori Admin panel
                    val intent = Intent(this, AdminActivity::class.java)
                    startActivity(intent)

                    Toast.makeText(this@MainActivity, "? Admin pristup odobren!", Toast.LENGTH_SHORT).show()
                } else {
                    Toast.makeText(this@MainActivity, "? Pogrešan kod!", Toast.LENGTH_SHORT).show()
                }
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun openAdminPanel() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val userEmail = getCurrentUserFromPrefs()
                val user = app.userRepository.getUserByEmail(userEmail)

                // PROVERA SECRET ADMIN PRISTUPA
                val sharedPreferences = getSharedPreferences("admin_prefs", MODE_PRIVATE)
                val hasSecretAdminAccess = sharedPreferences.getBoolean("has_admin_access", false)

                runOnUiThread {
                    val isAdmin = user?.role == "ADMIN" ||
                            AdminManager.isMasterAdmin(userEmail) ||
                            hasSecretAdminAccess

                    if (isAdmin) {
                        val intent = Intent(this@MainActivity, AdminActivity::class.java)
                        startActivity(intent)
                    } else {
                        AlertDialog.Builder(this@MainActivity)
                            .setTitle("?? Admin pristup")
                            .setMessage("Samo administratori mogu pristupiti Admin panelu.")
                            .setPositiveButton("OK", null)
                            .show()
                    }
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Greška: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
    private fun setupClickListeners() {
        try {
            Log.d("ClickSetup", "Postavljanje click listener-a...")

            // 1. TRACKING DUGMIÆI
            binding.btnStartTracking.setOnClickListener {
                Log.d("Click", "Start Tracking kliknut")
                startTracking()
            }
            binding.btnStopTracking.setOnClickListener {
                Log.d("Click", "Stop Tracking kliknut")
                stopTracking()
            }

            // 2. MOJA LOKACIJA - POPRAVLJENO
            binding.btnMyLocation.setOnClickListener {
                Log.d("Click", "Moja Lokacija kliknut")
                centerOnMyLocationSilent()
            }

            // DUGO ZADRŽAVANJE "Moja lokacija" za osvežavanje
            binding.btnMyLocation.setOnLongClickListener {
                refreshMapAndRoute()
                Toast.makeText(this, "?? Mapa i ruta osvežene", Toast.LENGTH_SHORT).show()
                true
            }

            // 3. MENI DUGME
            binding.btnMenu.setOnClickListener {
                Log.d("Click", "Meni kliknut")
                showNavigationMenu()
            }

            // 4. SAÈUVANE RUTE
            binding.btnSavedRoutes.setOnClickListener {
                Log.d("Click", "Saèuvane rute kliknut")
                showSavedRoutes()
            }

            // 5. ZOOM KONTROLE
            binding.btnZoomIn.setOnClickListener {
                Log.d("Click", "Zoom In kliknut")
                zoomIn()
            }

            binding.btnZoomOut.setOnClickListener {
                Log.d("Click", "Zoom Out kliknut")
                zoomOut()
            }

            // 6. DODAVANJE TAÈKE (FAB)
            binding.fabAddPoint.setOnClickListener {
                Log.d("Click", "Dodaj taèku kliknut")
                togglePointMode()
            }

            // 7. TRACKING MODE (TEKST DUGME) - PROVERITE OVO
            binding.btnTrackingMode.setOnClickListener {
                Log.d("Click", "Tracking Mode kliknut")
                toggleTrackingMode()
            }

            // 8. NAVIGACIJA (GOOGLE MAPS)
            binding.btnNavigation.setOnClickListener {
                Log.d("Click", "Navigacija kliknut")
                openGoogleMaps()
            }

            // 9. TIP MAPE
            binding.btnMapType.setOnClickListener {
                Log.d("Click", "Tip mape kliknut")
                showMapTypeDialog()
            }

            // 10. EXPORT I RESET
            binding.btnExport?.setOnClickListener {
                Log.d("Click", "Export kliknut")
                exportRouteData()
            }
            binding.btnMyLocation?.setOnLongClickListener {
                refreshMap()
                Toast.makeText(this, "?? Mapa osvežena", Toast.LENGTH_SHORT).show()
                true
            }
            binding.btnReset?.setOnClickListener {
                Log.d("Click", "Reset kliknut")
                resetCurrentRoute()
            }
            binding.btnMapOrientation.setOnClickListener {
                toggleMapOrientation()
            }

            binding.btnFollowLocation.setOnClickListener {
                toggleAutoFollow()
            }


            Log.d("ClickSetup", "Svi click listener-i postavljeni uspešno")

        } catch (e: Exception) {
            Log.e("ClickSetup", "Greška pri postavljanju click listener-a: ${e.message}")
            e.printStackTrace()
        }
    }
    // ============================================
// MAP ORIENTATION & AUTO-FOLLOW FUNCTIONS
// ============================================

    private fun toggleMapOrientation() {
        isMapOrientationNorth = !isMapOrientationNorth

        if (isMapOrientationNorth) {
            // FIKSNA ORIJENTACIJA - SEVER GORE
            binding.mapView.mapOrientation = 0f
            binding.btnMapOrientation.setBackgroundResource(R.drawable.button_transparent_round)
            Toast.makeText(this, "?? Mapa fiksirana - Sever gore", Toast.LENGTH_SHORT).show()
            Log.d("MapOrientation", "Switched to North orientation")
        } else {
            // PRATI SMER KRETANJA
            binding.btnMapOrientation.setBackgroundResource(R.drawable.button_modern_accent)
            Toast.makeText(this, "?? Mapa prati smer kretanja", Toast.LENGTH_SHORT).show()
            Log.d("MapOrientation", "Switched to Follow direction")

            // Postavi trenutni bearing ako postoji
            lastLocation?.let { location ->
                if (location.hasBearing()) {
                    binding.mapView.mapOrientation = -location.bearing
                }
            }
        }
    }

    private fun toggleAutoFollow() {
        isAutoFollowEnabled = !isAutoFollowEnabled

        if (isAutoFollowEnabled) {
            // UKLJUÆI AUTO-PRAÆENJE
            locationOverlay.enableFollowLocation()
            binding.btnFollowLocation.setBackgroundResource(R.drawable.button_modern_accent)
            Toast.makeText(this, "?? Auto-praæenje UKLJUÈENO", Toast.LENGTH_SHORT).show()
            Log.d("AutoFollow", "Auto-follow enabled")

            // Odmah centruj na lokaciju
            centerOnMyLocationSilent()
        } else {
            // ISKLJUÈI AUTO-PRAÆENJE
            locationOverlay.disableFollowLocation()
            binding.btnFollowLocation.setBackgroundResource(R.drawable.button_transparent_round)
            Toast.makeText(this, "?? Auto-praæenje ISKLJUÈENO", Toast.LENGTH_SHORT).show()
            Log.d("AutoFollow", "Auto-follow disabled")
        }
    }

    private fun updateMapOrientation(bearing: Float) {
        if (!::binding.isInitialized || binding.mapView == null) return

        if (!isMapOrientationNorth && isAutoFollowEnabled) {
            // Rotiraj mapu prema smeru kretanja
            binding.mapView.mapOrientation = -bearing
        }
    }
    private fun centerOnMyLocationSilent() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            requestLocationPermissions()
            return
        }

        fusedLocationClient.lastLocation
            .addOnSuccessListener { location: Location? ->
                location?.let {
                    if (it.accuracy < 50.0f) {
                        val currentLocation = GeoPoint(it.latitude, it.longitude)
                        binding.mapView.controller.animateTo(currentLocation)
                        binding.mapView.controller.setZoom(18.0)

                        // ? PRIKAŽI MARKER ALI BEZ DIJALOGA
                        showAccurateLocationMarker(currentLocation, it)

                        lastLocation = it
                        Log.d("Location", "Centriranje uspešno: ${it.accuracy}m")
                    } else {
                        val currentLocation = GeoPoint(it.latitude, it.longitude)
                        binding.mapView.controller.animateTo(currentLocation)
                        binding.mapView.controller.setZoom(16.0)
                        showAccurateLocationMarker(currentLocation, it)
                    }
                } ?: run {
                    Toast.makeText(this, "?? Tražim lokaciju...", Toast.LENGTH_SHORT).show()
                    startQuickLocationUpdate()
                }
            }
            .addOnFailureListener { e ->
                Log.e("Location", "Greška pri dobijanju lokacije: ${e.message}")
                Toast.makeText(this, "?? Tražim lokaciju...", Toast.LENGTH_SHORT).show()
                startQuickLocationUpdate()
            }
    }

    // POMOÆNE FUNKCIJE ZA KONVERZIJU TILE -> COORDINATES
    private fun tile2lat(y: Int, zoom: Int): Double {
        val n = Math.PI - (2.0 * Math.PI * y) / Math.pow(2.0, zoom.toDouble())
        return Math.toDegrees(Math.atan(Math.sinh(n)))
    }

    private fun tile2lon(x: Int, zoom: Int): Double {
        return (x / Math.pow(2.0, zoom.toDouble()) * 360.0) - 180.0
    }
    private fun resetZoomToLocation() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            requestLocationPermissions()
            return
        }

        fusedLocationClient.lastLocation
            .addOnSuccessListener { location: Location? ->
                location?.let {
                    val currentLocation = GeoPoint(it.latitude, it.longitude)

                    // RESET ZOOM NA PODRAŽAJNU VREDNOST
                    binding.mapView.controller.animateTo(currentLocation)
                    binding.mapView.controller.setZoom(16.0) // Standardni zoom level

                    Toast.makeText(this, "?? Zoom resetovan na lokaciju", Toast.LENGTH_SHORT).show()
                    Log.d("ZoomReset", "Zoom resetovan na lokaciju: ${it.latitude}, ${it.longitude}")
                } ?: run {
                    Toast.makeText(this, "?? Lokacija nije dostupna", Toast.LENGTH_SHORT).show()
                    startQuickLocationUpdate()
                }
            }
            .addOnFailureListener { e ->
                Log.e("ZoomReset", "Greška pri resetovanju zooma: ${e.message}")
                Toast.makeText(this, "? Greška pri resetovanju", Toast.LENGTH_SHORT).show()
            }
    }

    private fun drawRouteOnMap() {
        polylines.forEach { binding.mapView.overlays.remove(it) }
        polylines.clear()

        if (routePoints.size < 2) {
            Log.d("Tracking", "Premalo taèaka za crtanje: ${routePoints.size}")
            binding.mapView.invalidate()
            return
        }

        try {
            val polyline = Polyline()
            polyline.setPoints(routePoints)

            polyline.outlinePaint.color = Color.parseColor("#FF3498DB")
            polyline.outlinePaint.strokeWidth = 8.0f
            polyline.outlinePaint.style = android.graphics.Paint.Style.STROKE

            binding.mapView.overlays.add(polyline)
            polylines.add(polyline)
            binding.mapView.invalidate()

            Log.d("Tracking", "Ruta nacrtana sa ${routePoints.size} taèaka")
        } catch (e: Exception) {
            Log.e("Tracking", "Greška pri crtanju rute: ${e.message}")
        }
    }

    private fun addPointToRouteSmoothly(location: GeoPoint, androidLocation: Location) {
        if (!isTracking) return

        if (!isValidLocationForTracking(location, androidLocation)) {
            return
        }

        // DODAJ U TEKUÆI SEGMENT
        currentSegment.add(location)
        routePoints.add(location)

        // ÈEŠÆE OSVEŽAVANJE ZA BOLJI PRIKAZ
        val shouldRedraw = currentSegment.size % 2 == 0 ||
                System.currentTimeMillis() - lastDrawTime > 3000 ||
                !isActivityVisible // Redraw when coming from background

        if (shouldRedraw && isActivityVisible) {
            runOnUiThread {
                drawSmoothRouteOnMap()
            }
            lastDrawTime = System.currentTimeMillis()
        }

        savePointToDatabase(location)
        Log.d("Tracking", "?? Dodata taèka ${currentSegment.size}: ${String.format("%.6f", location.latitude)}, ${String.format("%.6f", location.longitude)}")
    }
    private fun resetMapOverlays() {
        try {
            runOnUiThread {
                // Privremeno ukloni sve overlay-e
                binding.mapView.overlays.clear()

                // Ponovo dodaj kompas overlay
                val compassOverlay = CompassOverlay(this, InternalCompassOrientationProvider(this), binding.mapView)
                compassOverlay.enableCompass()
                binding.mapView.overlays.add(compassOverlay)

                // Ponovo dodaj location overlay
                locationOverlay = MyLocationNewOverlay(GpsMyLocationProvider(this), binding.mapView)
                locationOverlay.enableMyLocation()
                locationOverlay.isDrawAccuracyEnabled = false
                binding.mapView.overlays.add(locationOverlay)

                // Ponovo dodaj click listener overlay
                binding.mapView.overlays.add(object : org.osmdroid.views.overlay.Overlay() {
                    override fun onSingleTapConfirmed(e: android.view.MotionEvent?, mapView: org.osmdroid.views.MapView?): Boolean {
                        // ... postojeæi click handler kod ...
                        return false
                    }
                })

                // Ponovo iscrtaj rutu
                if (isTracking && routePoints.isNotEmpty()) {
                    drawSmoothRouteOnMap()
                }

                // Ponovo prikaži taèke interesa
                refreshPointsOfInterest()

                binding.mapView.invalidate()
                Log.d("MapReset", "?? Svi overlay-i resetovani")
            }
        } catch (e: Exception) {
            Log.e("MapReset", "?? Greška pri resetovanju overlay-a: ${e.message}")
        }
    }
    private fun refreshPointsOfInterest() {
        try {
            // Ukloni sve postojeæe markere taèaka
            pointMarkers.values.forEach { marker ->
                binding.mapView.overlays.remove(marker)
            }
            pointMarkers.clear()

            // Ponovo dodaj sve taèke interesa
            pointsOfInterest.forEach { point ->
                val location = GeoPoint(point.latitude, point.longitude)
                addMarkerToMap(location, point.name, point.id)
            }

            binding.mapView.invalidate()
            Log.d("PointsRefresh", "?? Taèke interesa osvežene: ${pointsOfInterest.size} taèaka")
        } catch (e: Exception) {
            Log.e("PointsRefresh", "?? Greška pri osvežavanju taèaka: ${e.message}")
        }
    }

    private fun drawSmoothRouteOnMap() {
        // PROVERI DA LI JE MAPA INICIJALIZOVANA
        if (!::binding.isInitialized || binding.mapView == null) {
            Log.w("RouteDrawing", "MapView nije inicijalizovan, preskaèem crtanje rute")
            return
        }

        try {
            // UKLONI SVE PRETHODNE LINIJE
            polylines.forEach { polyline ->
                binding.mapView.overlays.remove(polyline)
            }
            polylines.clear()

            // CRTANJE SVIH SEGMENATA
            routeSegments.forEachIndexed { index, segment ->
                if (segment.size >= 2) {
                    val polyline = Polyline().apply {
                        setPoints(segment)
                        outlinePaint.color = Color.parseColor("#FF2196F3")
                        outlinePaint.strokeWidth = 12.0f
                        outlinePaint.strokeCap = Paint.Cap.ROUND
                        outlinePaint.strokeJoin = Paint.Join.ROUND
                        outlinePaint.style = Paint.Style.STROKE
                    }
                    binding.mapView.overlays.add(polyline)
                    polylines.add(polyline)
                    Log.d("RouteDrawing", "?? Segment $index iscrtan sa ${segment.size} taèaka")
                }
            }

            // CRTANJE TEKUÆEG SEGMENTA
            if (currentSegment.size >= 2) {
                val currentPolyline = Polyline().apply {
                    setPoints(currentSegment)
                    outlinePaint.color = Color.parseColor("#FF2196F3")
                    outlinePaint.strokeWidth = 12.0f
                    outlinePaint.strokeCap = Paint.Cap.ROUND
                    outlinePaint.strokeJoin = Paint.Join.ROUND
                    outlinePaint.style = Paint.Style.STROKE
                }
                binding.mapView.overlays.add(currentPolyline)
                polylines.add(currentPolyline)
                Log.d("RouteDrawing", "?? Tekuæi segment iscrtan sa ${currentSegment.size} taèaka")
            }

            // FORSIRAJ OSVEŽAVANJE
            binding.mapView.invalidate()
            binding.mapView.postInvalidate()

        } catch (e: Exception) {
            Log.e("RouteDrawing", "?? Greška pri crtanju rute: ${e.message}")
        }
    }

    private var lastDrawTime: Long = 0

    private fun isValidLocationForTracking(location: GeoPoint, androidLocation: Location): Boolean {
        // PROVERA GEOGRAFSKIH GRANICA (Srbija)
        if (location.latitude < 40.0 || location.latitude > 47.0 ||
            location.longitude < 18.0 || location.longitude > 23.0) {
            return false
        }

        // PROVERA AKURATNOSTI
        if (androidLocation.accuracy > 25.0f) {
            return false
        }

        // PROVERA RAZMAKA OD PRETHODNE TAÈKE
        if (routePoints.isNotEmpty()) {
            val lastPoint = routePoints.last()
            val distance = calculateDistance(
                lastPoint.latitude, lastPoint.longitude,
                location.latitude, location.longitude
            )

            // FILTRIRAJ PREVELIKE I PREMANJE RAZMAKE
            if (distance < 3.0 || distance > 100.0) {
                return false
            }
        }

        return true
    }
    private fun showAccurateLocationMarker(location: GeoPoint, androidLocation: Location) {
        // PROVERI DA LI JE MAPVIEW INICIJALIZOVAN
        if (!::binding.isInitialized || binding.mapView == null) {
            Log.w("LocationMarker", "MapView nije inicijalizovan, preskaèem prikaz markera")
            return
        }

        // UKLONI STARI MARKER
        myLocationMarker?.let { marker ->
            binding.mapView.overlays.remove(marker)
        }

        // BOLJE IKONE - koristi uvek istu, jasnu ikonu
        val iconRes = R.drawable.ic_my_location

        // KREIRAJ NOVI MARKER
        val marker = Marker(binding.mapView).apply {
            position = location
            setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_CENTER)

            // BOLJI TITLE
            title = when {
                currentSpeed > 5.0 -> "?? Vožnja - ${String.format("%.1f", currentSpeed)} km/h"
                currentSpeed > 1.0 -> "?? Kretanje - ${String.format("%.1f", currentSpeed)} km/h"
                else -> "?? Moja lokacija"
            }

            // JASNA IKONA
            val iconDrawable = ContextCompat.getDrawable(this@MainActivity, iconRes)
            setIcon(iconDrawable)

            if (androidLocation.hasBearing()) {
                rotation = androidLocation.bearing
            }

            // CLICK LISTENER
            setOnMarkerClickListener { marker, mapView ->
                showMyLocationDetails()
                true
            }
        }

        binding.mapView.overlays.add(marker)
        myLocationMarker = marker

        // OSVEŽI PRIKAZ SAMO AKO JE MAPA VIDLJIVA
        if (isActivityVisible) {
            binding.mapView.invalidate()
        }
    }
    // PAMETNO FILTRIRANJE POKRETA
    private fun isValidMovement(distance: Double, lastLoc: Location, newLoc: Location): Boolean {
        val timeDiff = (newLoc.time - lastLoc.time) / 1000.0

        // SAMO OÈIGLEDNE GREŠKE
        if (distance < 1.0) return false  // Premali pokret
        if (distance > 500.0) return false // Preveliki skok
        if (timeDiff < 0.5) return false   // Prebrzo ažuriranje

        return true
    }
    private fun getBestLocation() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }

        // POKUŠAJTE DA DOBIJETE POSLEDNJU LOKACIJU
        fusedLocationClient.lastLocation
            .addOnSuccessListener { location: Location? ->
                location?.let {
                    // OPUSTITE USLOVE ZA PRIHVATANJE LOKACIJE
                    if (it.accuracy < 100.0f) { // SA 25 NA 100m
                        Log.d("Location", "Pronaðena dobra poslednja lokacija: ${it.accuracy}m")
                        val currentLocation = GeoPoint(it.latitude, it.longitude)
                        binding.mapView.controller.animateTo(currentLocation)
                        binding.mapView.controller.setZoom(17.0)
                        isMapCentered = true
                        lastLocation = it

                        // PRIKAŽI MARKER
                        showAccurateLocationMarker(currentLocation, it)
                    } else {
                        Log.d("Location", "Poslednja lokacija nije idealna: ${it.accuracy}m, ali je prihvatljiva")
                        // IPAK JE KORISTITE DOK SE NE DOBIJE BOLJA
                        val currentLocation = GeoPoint(it.latitude, it.longitude)
                        binding.mapView.controller.animateTo(currentLocation)
                        binding.mapView.controller.setZoom(16.0)
                        showAccurateLocationMarker(currentLocation, it)
                    }
                } ?: run {
                    Log.d("Location", "Nema poslednje lokacije - pokreæem traženje")
                    startLocationUpdates()
                }
            }
            .addOnFailureListener { e ->
                Log.e("Location", "Greška pri dobijanju poslednje lokacije: ${e.message}")
                startLocationUpdates()
            }
    }

    // BRZINA IZ UDALJENOSTI I VREMENA
    private fun calculateSpeedFromDistance(distance: Double, startTime: Long, endTime: Long): Double {
        val timeDiff = (endTime - startTime) / 1000.0 // u sekundama
        return if (timeDiff > 0) (distance / timeDiff) * 3.6 else 0.0 // km/h
    }
    // HAVERSINE FORMULA - NAJTAÈNIJA METODA
    private fun calculateHaversineDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val earthRadius = 6371000.0 // metri

        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)

        val a = sin(dLat / 2) * sin(dLat / 2) +
                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *
                sin(dLon / 2) * sin(dLon / 2)

        val c = 2 * atan2(sqrt(a), sqrt(1 - a))

        val distance = earthRadius * c

        // DEBUG LOG
        Log.d("DistanceCalc", "?? ($lat1, $lon1) -> ($lat2, $lon2) = ${String.format("%.2f", distance)}m")

        return distance
    }
    private fun showExitConfirmationDialog() {
        AlertDialog.Builder(this)
            .setTitle("Izlazak iz aplikacije")
            .setMessage("Da li ste sigurni da želite da izaðete?")
            .setPositiveButton("Da") { dialog, which ->
                finish()
            }
            .setNegativeButton("Ne", null)
            .show()
    }
    private fun toggleLocationFollowing() {
        isFollowingLocation = !isFollowingLocation

        if (isFollowingLocation) {
            locationOverlay.enableFollowLocation()
            binding.btnMyLocation.setBackgroundResource(R.drawable.button_dark_blue_accent)
            Toast.makeText(this, "??? Automatsko praæenje UKLJUÈENO", Toast.LENGTH_SHORT).show()
            Log.d("Location", "Automatsko praæenje ruèno ukljuèeno")
        } else {
            locationOverlay.disableFollowLocation()
            binding.btnMyLocation.setBackgroundResource(R.drawable.button_dark_blue)
            Toast.makeText(this, "??? Automatsko praæenje ISKLJUÈENO", Toast.LENGTH_SHORT).show()
            Log.d("Location", "Automatsko praæenje ruèno iskljuèeno")
        }
    }

    private fun showMyLocationDetails() {
        val location = locationOverlay.myLocation ?: run {
            Toast.makeText(this, "?? Lokacija nije dostupna", Toast.LENGTH_SHORT).show()
            return
        }

        val coordinates = "?? ${String.format("%.6f", location.latitude)}, ${String.format("%.6f", location.longitude)}"
        val speed = "?? Brzina: ${String.format("%.1f", currentSpeed)} km/h"
        val altitude = "?? Visina: ${String.format("%.0f", currentAltitude)} m"
        val battery = "?? Baterija: ${getBatteryLevel()}%"
        val accuracy = lastLocation?.accuracy ?: 0f
        val accuracyText = "?? Taènost: ${String.format("%.0f", accuracy)} m"

        // DODAJ SMER KRETANJA
        val bearing = lastLocation?.bearing ?: 0f
        val bearingText = if (lastLocation?.hasBearing() == true) {
            "?? Smer: ${getBearingDirection(bearing)} (${String.format("%.0f", bearing)}°)"
        } else {
            "?? Smer: Nepoznat"
        }

        val message = """
$coordinates
$accuracyText
$speed
$altitude  
$bearingText
$battery

?? Akcije:
    """.trimIndent()

        AlertDialog.Builder(this)
            .setTitle("?? Moja Lokacija")
            .setMessage(message)
            .setPositiveButton("??? Google Mape") { dialog, which ->
                openGoogleMapsForCurrentLocation()
            }
            .setNeutralButton("?? Kopiraj koordinate") { dialog, which ->
                copyCoordinatesToClipboard(location.latitude, location.longitude)
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }
    private fun openGoogleMapsForCurrentLocation() {
        val location = locationOverlay.myLocation ?: return

        try {
            val uri = "geo:${location.latitude},${location.longitude}?q=${location.latitude},${location.longitude}"
            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(uri))
            intent.setPackage("com.google.android.apps.maps")

            if (intent.resolveActivity(packageManager) != null) {
                startActivity(intent)
            } else {
                val webUri = "https://www.google.com/maps/search/?api=1&query=${location.latitude},${location.longitude}"
                val webIntent = Intent(Intent.ACTION_VIEW, Uri.parse(webUri))
                startActivity(webIntent)
            }
        } catch (e: Exception) {
            Toast.makeText(this, "? Greška pri otvaranju Google Maps", Toast.LENGTH_SHORT).show()
        }
    }


    private fun copyCoordinatesToClipboard(lat: Double, lon: Double) {
        val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        val clip = ClipData.newPlainText("coordinates", "$lat, $lon")
        clipboard.setPrimaryClip(clip)
        Toast.makeText(this, "? Koordinate kopirane", Toast.LENGTH_SHORT).show()
    }


    private fun getBearingFromLastLocation(): String {
        val currentLocation = locationOverlay.myLocation ?: return "Nepoznato"
        val lastLoc = lastLocation ?: return "Nepoznato"

        val bearing = lastLoc.bearingTo(android.location.Location("").apply {
            latitude = currentLocation.latitude
            longitude = currentLocation.longitude
        })

        return getBearingDirection(bearing)
    }

    private fun initializeMap() {
        try {
            Configuration.getInstance().cacheMapTileCount = 1000
            Configuration.getInstance().tileDownloadThreads = 3
            Configuration.getInstance().tileFileSystemThreads = 2
            Configuration.getInstance().tileDownloadMaxQueueSize = 100

            binding.mapView.setTileSource(TileSourceFactory.MAPNIK)
            binding.mapView.setMultiTouchControls(true)
            binding.mapView.minZoomLevel = 3.0
            binding.mapView.maxZoomLevel = 19.0
            binding.mapView.setTilesScaledToDpi(true)

            val compassOverlay = CompassOverlay(this, InternalCompassOrientationProvider(this), binding.mapView)
            compassOverlay.enableCompass()
            binding.mapView.overlays.add(compassOverlay)

            // ISPRAVLJENA INICIJALIZACIJA LOCATION OVERLAY
            locationOverlay = MyLocationNewOverlay(GpsMyLocationProvider(this), binding.mapView)
            locationOverlay.enableMyLocation()

            // ?? OVO JE KLJUÈNO: ISKLJUÈI ACCURACY CIRCLE
            locationOverlay.isDrawAccuracyEnabled = false

            // ?? OPCIONALNO: ISKLJUÈI I DEFAULT PERSON ICON (ako želiš samo naš marker)
            // locationOverlay.setPersonIcon(null)

            binding.mapView.overlays.add(locationOverlay)

            // Overlay za klikove ostaje isti
            binding.mapView.overlays.add(object : org.osmdroid.views.overlay.Overlay() {
                override fun onSingleTapConfirmed(e: android.view.MotionEvent?, mapView: org.osmdroid.views.MapView?): Boolean {
                    try {
                        if (mapView != null && e != null) {
                            val tappedPoint = mapView.projection.fromPixels(e.x.toInt(), e.y.toInt()) as GeoPoint

                            if (isPointMode) {
                                showAddPointDialog(tappedPoint)
                                return true
                            }

                            val myLocation = locationOverlay.myLocation
                            if (myLocation != null) {
                                val distance = calculateDistance(
                                    myLocation.latitude, myLocation.longitude,
                                    tappedPoint.latitude, tappedPoint.longitude
                                )
                                if (distance < 5.0) {
                                    showMyLocationDetails()
                                    return true
                                }
                            }
                        }
                    } catch (ex: Exception) {
                        Log.e("MainActivity", "Greška u click handler: ${ex.message}")
                    }
                    return false
                }
            })

            val nis = GeoPoint(43.3209, 21.8958)
            binding.mapView.controller.setZoom(13.0)
            binding.mapView.controller.setCenter(nis)

            Log.d("MainActivity", "Mapa uspešno inicijalizovana")

        } catch (e: Exception) {
            Log.e("MainActivity", "Greška pri inicijalizaciji mape: ${e.message}")
            Toast.makeText(this, "Greška pri uèitavanju mape", Toast.LENGTH_SHORT).show()
        }
    }
    private fun disableAccuracyCircle() {
        try {
            // PRONAÐI SVE OVERLAYE I ISKLJUÈI IM ACCURACY
            binding.mapView.overlays.forEach { overlay ->
                if (overlay is MyLocationNewOverlay) {
                    overlay.isDrawAccuracyEnabled = false
                }
            }

            // OSVEŽI PRIKAZ
            binding.mapView.invalidate()

        } catch (e: Exception) {
            Log.e("AccuracyCircle", "Greška pri iskljuèivanju accuracy circle: ${e.message}")
        }
    }
    private fun startQuickLocationUpdate() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }

        // KORISTITE BRZI LocationRequest ZA HITNO DOBIJANJE LOKACIJE
        val fastLocationRequest = LocationRequest.Builder(
            Priority.PRIORITY_HIGH_ACCURACY,
            1000L
        ).setMinUpdateIntervalMillis(500L)
            .setWaitForAccurateLocation(false)
            .setMaxUpdateDelayMillis(2000L)
            .build()

        val fastLocationCallback = object : LocationCallback() {
            override fun onLocationResult(locationResult: LocationResult) {
                val location = locationResult.lastLocation
                if (location != null) {
                    Log.d("Location", "Brza lokacija pronaðena: ${location.accuracy}m")

                    // CENTRIRAJTE SE ÈAK I AKO LOKACIJA NIJE SAVRŠENO TAÈNA
                    val currentLocation = GeoPoint(location.latitude, location.longitude)
                    binding.mapView.controller.animateTo(currentLocation)
                    binding.mapView.controller.setZoom(18.0)
                    showAccurateLocationMarker(currentLocation, location)

                    // Preðite na normalan režim nakon što dobijete lokaciju
                    fusedLocationClient.removeLocationUpdates(this)
                    startLocationUpdates()
                }
            }
        }

        try {
            fusedLocationClient.requestLocationUpdates(
                fastLocationRequest,
                fastLocationCallback,
                Looper.getMainLooper()
            )
            Log.d("Location", "Brzo pokretanje lokacije za centriranje")
        } catch (e: SecurityException) {
            Log.e("Location", "Security exception pri brzom pokretanju: ${e.message}")
        }
    }
    private fun showAddPointDialog(location: GeoPoint) {
        val editText = EditText(this).apply {
            hint = "Ime taèke"
        }

        AlertDialog.Builder(this)
            .setTitle("Dodaj taèku")
            .setView(editText)
            .setPositiveButton("Dodaj") { dialog, _ ->
                val name = editText.text?.toString()?.takeIf { it.isNotBlank() } ?: "Nova taèka"
                addPointOfInterest(name, location)
            }
            .setNegativeButton("Otkaži", null)
            .show()
    }

    private fun addPointOfInterest(name: String, location: GeoPoint) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val userEmail = getCurrentUserFromPrefs()
                val user = app.userRepository.getUserByEmail(userEmail)

                if (user != null && !FeatureManager.canCreateUnlimitedPoints(user)) {
                    val currentPoints = app.pointRepository.getUserPoints(user.id)
                    val maxPoints = FeatureManager.getMaxPoints(user)

                    if (currentPoints.size >= maxPoints) {
                        runOnUiThread {
                            showPointsLimitReachedDialog(maxPoints)
                        }
                        return@launch
                    }
                }

                // NASTAVAK POSTOJEÆEG KODA...
                val existingPoints = app.pointRepository.getUserPoints(getCurrentUserId())
                val duplicatePoint = existingPoints.find { it.name.equals(name, ignoreCase = true) }

                if (duplicatePoint != null) {
                    runOnUiThread {
                        Toast.makeText(this@MainActivity, "? Taèka sa imenom '$name' veæ postoji!", Toast.LENGTH_LONG).show()
                    }
                    return@launch
                }

                val point = PointOfInterest(
                    userId = getCurrentUserId(),
                    name = name,
                    latitude = location.latitude,
                    longitude = location.longitude,
                    createdAt = System.currentTimeMillis()
                )

                app.pointRepository.addPoint(point)

                runOnUiThread {
                    // 1. OSVEŽI LISTU TAÈAKA
                    loadPointsOfInterest() // Ovo æe ponovo uèitati sve taèke iz baze

                    // 2. DODAJ MARKER NA MAPU
                    addMarkerToMap(location, name, point.id)

                    // 3. PRIKAŽI POTVRDU
                    notificationHelper.showPointAdded(name)

                    val message = """
                ? Taèka '$name' dodata!
                
                ?? ${String.format("%.6f", location.latitude)}, ${String.format("%.6f", location.longitude)}
                
                Klikni na taèku za više opcija.
            """.trimIndent()

                    Toast.makeText(this@MainActivity, message, Toast.LENGTH_LONG).show()

                    // 4. OSVEŽI MAPU
                    binding.mapView.invalidate()
                }

            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Greška pri èuvanju taèke: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun addMarkerToMap(location: GeoPoint, title: String, pointId: String) {
        // Kreirajte custom marker sa tekstom
        val marker = object : Marker(binding.mapView) {
            override fun draw(canvas: Canvas, mapView: MapView, shadow: Boolean) {
                super.draw(canvas, mapView, shadow)

                // Nacrtajte tekst ispod markera
                if (!shadow) {
                    val project = mapView.projection
                    val point = project.toPixels(position, null)

                    val textPaint = android.graphics.Paint().apply {
                        color = Color.WHITE
                        textSize = 36f  // Velièina teksta
                        isAntiAlias = true
                        textAlign = android.graphics.Paint.Align.CENTER
                        setShadowLayer(3f, 0f, 0f, Color.BLACK)
                    }

                    val backgroundPaint = android.graphics.Paint().apply {
                        color = Color.argb(180, 255, 0, 0)  // Crvena pozadina
                        style = android.graphics.Paint.Style.FILL
                    }

                    // Izmerite tekst
                    val textBounds = android.graphics.Rect()
                    textPaint.getTextBounds(title, 0, title.length, textBounds)

                    val padding = 8f  // PROMENJENO: 8f umesto 8
                    val backgroundRect = android.graphics.RectF(
                        point.x - textBounds.width() / 2 - padding,  // ISPRAVLJENO: point.x je Int
                        point.y + 40f,  // Pozicija ispod markera
                        point.x + textBounds.width() / 2 + padding,  // ISPRAVLJENO: point.x je Int
                        point.y + 40f + textBounds.height() + padding * 2
                    )

                    // Nacrtajte pozadinu
                    canvas.drawRoundRect(backgroundRect, 8f, 8f, backgroundPaint)

                    // Nacrtajte tekst
                    canvas.drawText(
                        title,
                        point.x.toFloat(),  // ISPRAVLJENO: konvertujte u Float
                        point.y + 40f + textBounds.height() + padding,
                        textPaint
                    )
                }
            }
        }

        marker.position = location
        marker.setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)
        marker.title = "?? $title"
        marker.snippet = "Klikni za opcije"
        marker.setIcon(ContextCompat.getDrawable(this, R.drawable.ic_point_blue))

        marker.setOnMarkerClickListener { marker, mapView ->
            marker.showInfoWindow()
            showPointOptionsDialog(pointId, title, location)
            true
        }

        binding.mapView.overlays.add(marker)
        pointMarkers[pointId] = marker
        binding.mapView.invalidate()
    }

    private fun showPointOptionsDialog(pointId: String, pointName: String, location: GeoPoint) {
        val options = arrayOf(
            "Prikaži detalje",
            "Navigiraj do taèke",
            "Preimenuj taèku",
            "Obriši taèku",
            "Otkaži"
        )

        AlertDialog.Builder(this)
            .setTitle("Taèka: $pointName")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> showPointDetails(pointName, location)
                    1 -> navigateToPoint(location)
                    2 -> renamePoint(pointId, pointName)
                    3 -> deletePoint(pointId, pointName)
                }
            }
            .show()
    }

    private fun renamePoint(pointId: String, currentName: String) {
        val editText = EditText(this).apply {
            setText(currentName)
            hint = "Unesite novo ime taèke"
            setSelectAllOnFocus(true)
        }

        AlertDialog.Builder(this)
            .setTitle("Preimenuj taèku")
            .setMessage("Trenutno ime: $currentName")
            .setView(editText)
            .setPositiveButton("Saèuvaj") { dialog, _ ->
                val newName = editText.text.toString().trim()
                if (newName.isBlank()) {
                    Toast.makeText(this, "Ime ne može biti prazno!", Toast.LENGTH_SHORT).show()
                    return@setPositiveButton
                }
                if (newName == currentName) {
                    Toast.makeText(this, "Ime nije promenjeno", Toast.LENGTH_SHORT).show()
                    return@setPositiveButton
                }
                if (isPointNameDuplicate(newName, pointId)) {
                    Toast.makeText(this, "Taèka sa imenom '$newName' veæ postoji!", Toast.LENGTH_LONG).show()
                    return@setPositiveButton
                }
                updatePointName(pointId, currentName, newName)
            }
            .setNegativeButton("Otkaži", null)
            .show()
    }

    private fun isPointNameDuplicate(newName: String, currentPointId: String): Boolean {
        return pointsOfInterest.any {
            it.name.equals(newName, ignoreCase = true) && it.id != currentPointId
        }
    }

    private fun updatePointName(pointId: String, oldName: String, newName: String) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as jovannedeljkovic.gps_tracker_pro.App
                val point = app.pointRepository.getPointById(pointId)
                point?.let { existingPoint ->
                    val updatedPoint = existingPoint.copy(name = newName)
                    app.pointRepository.updatePoint(updatedPoint)
                    runOnUiThread {
                        val index = pointsOfInterest.indexOfFirst { it.id == pointId }
                        if (index != -1) {
                            pointsOfInterest[index] = updatedPoint
                        }
                        updateMarkerName(pointId, newName)
                        notificationHelper.showPointRenamed(oldName, newName)
                        Toast.makeText(
                            this@MainActivity,
                            "Taèka '$oldName' preimenovana u '$newName'",
                            Toast.LENGTH_LONG
                        ).show()
                    }
                } ?: run {
                    runOnUiThread {
                        Toast.makeText(
                            this@MainActivity,
                            "Greška: Taèka nije pronaðena!",
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(
                        this@MainActivity,
                        "Greška pri preimenovanju: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }

    private fun updateMarkerName(pointId: String, newName: String) {
        pointMarkers[pointId]?.let { marker ->
            marker.title = newName
            if (marker.isInfoWindowShown) {
                marker.closeInfoWindow()
                marker.showInfoWindow()
            }
            binding.mapView.invalidate()
        }
    }

    private fun showPointDetails(pointName: String, location: GeoPoint) {
        val distance = calculateDistanceToPoint(PointOfInterest(
            id = "",
            userId = getCurrentUserId(),
            name = pointName,
            latitude = location.latitude,
            longitude = location.longitude,
            createdAt = System.currentTimeMillis()
        ))

        val currentUser = getUserName()
        val details = """
        ?? $pointName
        
        ?? Kreirao: $currentUser
        ?? ${SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault()).format(Date())}
        
        Koordinate:
        ${String.format("%.6f", location.latitude)}, ${String.format("%.6f", location.longitude)}
        
        Udaljenost od vas:
        ${formatDistance(distance)}
    """.trimIndent()

        AlertDialog.Builder(this)
            .setTitle("Detalji taèke")
            .setMessage(details)
            .setPositiveButton("Podeli taèku") { dialog, which ->
                sharePoint(pointName, location)
            }
            .setNegativeButton("Zatvori", null)
            .show()
    }

    private fun sharePoint(pointName: String, location: GeoPoint) {
        val shareText = """
        ?? $pointName
        
        Lokacija: 
        ${String.format("%.6f", location.latitude)}, ${String.format("%.6f", location.longitude)}
        
        Google Maps:
        https://www.google.com/maps/search/?api=1&query=${location.latitude},${location.longitude}
        
        Deljeno iz GPS Tracker aplikacije
    """.trimIndent()

        val intent = Intent(Intent.ACTION_SEND).apply {
            type = "text/plain"
            putExtra(Intent.EXTRA_TEXT, shareText)
            putExtra(Intent.EXTRA_SUBJECT, "Taèka: $pointName")
        }
        startActivity(Intent.createChooser(intent, "Podeli taèku"))
    }

    private fun deletePoint(pointId: String, pointName: String) {
        AlertDialog.Builder(this)
            .setTitle("Brisanje taèke")
            .setMessage("Da li ste sigurni da želite da obrišete taèku '$pointName'?")
            .setPositiveButton("Obriši") { dialog, which ->
                lifecycleScope.launch(Dispatchers.IO) {
                    try {
                        val app = application as jovannedeljkovic.gps_tracker_pro.App
                        val point = app.pointRepository.getPointById(pointId)
                        point?.let {
                            app.pointRepository.deletePoint(it)
                            runOnUiThread {
                                pointMarkers[pointId]?.let { marker ->
                                    binding.mapView.overlays.remove(marker)
                                }
                                pointMarkers.remove(pointId)
                                binding.mapView.invalidate()
                                Toast.makeText(this@MainActivity, "Taèka '$pointName' obrisana", Toast.LENGTH_SHORT).show()
                            }
                        }
                    } catch (e: Exception) {
                        runOnUiThread {
                            Toast.makeText(this@MainActivity, "Greška pri brisanju: ${e.message}", Toast.LENGTH_SHORT).show()
                        }
                    }
                }
            }
            .setNegativeButton("Otkaži", null)
            .show()
    }

    private fun navigateToPoint(location: GeoPoint) {
        try {
            val uri = "google.navigation:q=${location.latitude},${location.longitude}"
            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(uri))
            intent.setPackage("com.google.android.apps.maps")
            if (intent.resolveActivity(packageManager) != null) {
                startActivity(intent)
            } else {
                val mapsUri = "https://www.google.com/maps/dir/?api=1&destination=${location.latitude},${location.longitude}"
                val mapsIntent = Intent(Intent.ACTION_VIEW, Uri.parse(mapsUri))
                startActivity(mapsIntent)
            }
        } catch (e: Exception) {
            Toast.makeText(this, "Greška pri navigaciji: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }
// DODAJTE OVE METODE U MAIN ACTIVITY:

    private fun startBackgroundTracking() {
        if (isTracking) {
            // REGISTRUJ RECEIVER PRVO
            val filter = IntentFilter("BACKGROUND_LOCATION_UPDATE")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                registerReceiver(backgroundLocationReceiver, filter, RECEIVER_EXPORTED)
            } else {
                registerReceiver(backgroundLocationReceiver, filter)
            }
            isReceivingBackgroundUpdates = true

            // POKRENI SERVIS
            val intent = Intent(this, TrackingService::class.java).apply {
                action = TrackingService.ACTION_START_TRACKING
            }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                startForegroundService(intent)
            } else {
                startService(intent)
            }

            Log.d("Tracking", "?? Pozadinsko snimanje pokrenuto")
        }
    }
    private fun stopBackgroundTracking() {
        // UKLONI RECEIVER
        if (isReceivingBackgroundUpdates) {
            try {
                unregisterReceiver(backgroundLocationReceiver)
                isReceivingBackgroundUpdates = false
            } catch (e: Exception) {
                Log.e("Tracking", "Greška pri uklanjanju receivera: ${e.message}")
            }
        }

        // ZAUSTAVI SERVIS
        val intent = Intent(this, TrackingService::class.java).apply {
            action = TrackingService.ACTION_STOP_TRACKING
        }
        stopService(intent)
        Log.d("Tracking", "?? Pozadinsko snimanje zaustavljeno")
    }

    // TRACKING FUNCTIONALITY
    private fun startTracking() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val userEmail = getCurrentUserFromPrefs()
                val user = app.userRepository.getUserByEmail(userEmail)

                if (user != null && !FeatureManager.canCreateUnlimitedRoutes(user)) {
                    val dailyRoutes = getTodayRouteCount(user.id)
                    val maxRoutes = FeatureManager.getMaxDailyRoutes(user)

                    if (dailyRoutes >= maxRoutes) {
                        runOnUiThread {
                            showDailyLimitReachedDialog(maxRoutes)
                        }
                        return@launch
                    }
                }

                runOnUiThread {
                    Log.d("Tracking", "=== START TRACKING ===")
                    isTracking = true
                    trackingStartTime = System.currentTimeMillis()
                    trackingSeconds = 0
                    totalDistance = 0.0
                    routePoints.clear()
                    lastLocation = null

                    // OVO JE KLJUÈNO - PRIKAŽI TRACKING PANEL
                    binding.trackingPanel.visibility = View.VISIBLE

                    // INICIJALIZUJ SEGMENTE
                    routeSegments.clear()
                    currentSegment = mutableListOf()

                    // ODMH AŽURIRAJ UI SA POÈETNIM VREDNOSTIMA
                    updateTrackingStats(0.0, 0.0)
                    updateTrackingTime()

                    // POKRENI TIMER ODMH
                    startTrackingTimer()

                    // POKRENI POZADINSKI SERVIS PRVO!
                    startBackgroundTracking()

                    lifecycleScope.launch(Dispatchers.IO) {
                        val app = application as App
                        currentRoute = Route(
                            userId = getCurrentUserId(),
                            name = "Ruta ${SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault()).format(Date())}",
                            startTime = System.currentTimeMillis(),
                            distance = 0.0,
                            duration = 0L,
                            isCompleted = false
                        )
                        val routeId = app.routeRepository.createRoute(currentRoute!!)
                        currentRoute = currentRoute!!.copy(id = routeId)

                        withContext(Dispatchers.Main) {
                            if (!locationOverlay.isFollowLocationEnabled) {
                                locationOverlay.enableFollowLocation()
                                isFollowingLocation = true
                            }

                            centerOnMyLocationSilent()
                            startLocationUpdates()
                            startTrackingNotification()
                            window.addFlags(android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)

                            binding.btnStartTracking.isEnabled = false
                            binding.btnStopTracking.isEnabled = true
                            binding.btnStartTracking.alpha = 0.5f
                            binding.btnStopTracking.alpha = 1.0f

                            Log.d("Tracking", "Snimanje potpuno pokrenuto")
                        }
                    }
                }

            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Greška: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
    private suspend fun getTodayRouteCount(userId: String): Int {
        return try {
            val app = application as App
            val allRoutes = app.routeRepository.getUserRoutes(userId)

            val today = Calendar.getInstance().apply {
                set(Calendar.HOUR_OF_DAY, 0)
                set(Calendar.MINUTE, 0)
                set(Calendar.SECOND, 0)
                set(Calendar.MILLISECOND, 0)
            }.timeInMillis

            allRoutes.count { route ->
                route.startTime >= today
            }
        } catch (e: Exception) {
            0
        }
    }

    private fun showDailyLimitReachedDialog(maxRoutes: Int) {
        AlertDialog.Builder(this)
            .setTitle("?? Dnevni limit dostignut")
            .setMessage(
                """
            Dostigli ste dnevni limit od $maxRoutes ruta za BASIC nalog.
            
            ?? Nadogradi na PREMIUM za:
            • Neogranièeno praæenje ruta
            • Neogranièene taèke interesa
            • Sve vrste mapa
            • Offline mape
            
            Želite li da nadogradite na PREMIUM?
            """.trimIndent()
            )
            .setPositiveButton("?? Nadogradi") { dialog, which ->
                showPremiumUpgradeDialog()
            }
            .setNegativeButton("Nastavi BASIC", null)
            .show()
    }
    private fun showPointsLimitReachedDialog(maxPoints: Int) {
        AlertDialog.Builder(this)
            .setTitle("?? Limit taèaka dostignut")
            .setMessage(
                """
            Dostigli ste limit od $maxPoints taèaka za BASIC nalog.
            
            ?? Nadogradi na PREMIUM za:
            • Neogranièene taèke interesa
            • Neogranièeno praæenje ruta  
            • Sve vrste mapa
            • Offline mape
            
            Želite li da nadogradite na PREMIUM?
            """.trimIndent()
            )
            .setPositiveButton("?? Nadogradi") { dialog, which ->
                showPremiumUpgradeDialog()
            }
            .setNegativeButton("Nastavi BASIC", null)
            .show()
    }
    private fun showModernTrackingDialog() {
        val dialog = AlertDialog.Builder(this, R.style.TransparentDialogTheme).apply {
            setCancelable(false)
        }.create()

        val view = LayoutInflater.from(this).inflate(R.layout.dialog_tracking_modern, null)
        dialog.setView(view)

        // JAKA TRANSPARENTNOST
        dialog.window?.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
        dialog.window?.clearFlags(android.view.WindowManager.LayoutParams.FLAG_DIM_BEHIND)
        dialog.window?.setDimAmount(0f)

        // Postavi poziciju
        val params = dialog.window?.attributes
        params?.gravity = Gravity.TOP or Gravity.CENTER_HORIZONTAL
        params?.y = 200
        dialog.window?.attributes = params
        // ... ostatak metode ostaje isti ...
        val progressBar = view.findViewById<ProgressBar>(R.id.progressBar)
        val tvDialogTime = view.findViewById<TextView>(R.id.tvDialogTime)
        val tvDialogDistance = view.findViewById<TextView>(R.id.tvDialogDistance)
        val tvDialogSpeed = view.findViewById<TextView>(R.id.tvDialogSpeed)
        val tvStatus = view.findViewById<TextView>(R.id.tvStatus)

        progressBar?.isIndeterminate = true

        val handler = Handler(Looper.getMainLooper())
        var dialogSeconds = 0

        val dialogRunnable = object : Runnable {
            override fun run() {
                if (dialog.isShowing) {
                    dialogSeconds++

                    val minutes = dialogSeconds / 60
                    val seconds = dialogSeconds % 60
                    tvDialogTime?.text = String.format("%02d:%02d", minutes, seconds)
                    tvDialogDistance?.text = formatDistance(totalDistance)
                    tvDialogSpeed?.text = "${String.format("%.1f", currentSpeed)} km/h"

                    val status = when {
                        currentSpeed > 1.0 -> "?? Pratimo kretanje..."
                        lastLocation != null -> "? GPS signal stabilan"
                        else -> "?? Tražim GPS signal..."
                    }
                    tvStatus?.text = status

                    handler.postDelayed(this, 1000)
                }
            }
        }

        dialog.show()
        handler.post(dialogRunnable)

        handler.postDelayed({
            if (dialog.isShowing) {
                dialog.dismiss()
                handler.removeCallbacks(dialogRunnable)
                showTrackingToast()
            }
        }, 3000)
    }

    private fun showTrackingToast() {
        Toast.makeText(this, "?? GPS aktiviran - snimamo rutu!", Toast.LENGTH_SHORT).show()
    }
    private val trackingHandler = Handler(Looper.getMainLooper())

    private fun startTrackingTimer() {
        trackingHandler.postDelayed(object : Runnable {
            override fun run() {
                if (isTracking) {
                    trackingSeconds++
                    updateTrackingTime()
                    trackingHandler.postDelayed(this, 1000)
                }
            }
        }, 1000)
    }

    private fun showTrackingStartedDialog() {
        val dialogView = LayoutInflater.from(this).inflate(R.layout.dialog_tracking_modern, null)

        val dialog = AlertDialog.Builder(this)
            .setView(dialogView)
            .setCancelable(false)
            .create()

        // Postavite prozirnu pozadinu
        dialog.window?.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
        dialog.window?.setDimAmount(0.7f)

        val progressBar = dialogView.findViewById<ProgressBar>(R.id.progressBar)
        //val tvMessage = dialogView.findViewById<TextView>(R.id.tvMessage)
        val tvDialogTime = dialogView.findViewById<TextView>(R.id.tvDialogTime)
        val tvDialogDistance = dialogView.findViewById<TextView>(R.id.tvDialogDistance)
        val tvDialogSpeed = dialogView.findViewById<TextView>(R.id.tvDialogSpeed)
        val tvStatus = dialogView.findViewById<TextView>(R.id.tvStatus)

        // Animirajte progress bar
        progressBar.isIndeterminate = true

        // Timer za ažuriranje dijaloga
        val dialogHandler = Handler(Looper.getMainLooper())
        var dialogSeconds = 0

        val dialogRunnable = object : Runnable {
            override fun run() {
                if (dialog.isShowing) {
                    dialogSeconds++

                    // Ažuriraj vreme u dijalogu
                    val minutes = dialogSeconds / 60
                    val seconds = dialogSeconds % 60
                    tvDialogTime.text = String.format("%02d:%02d", minutes, seconds)

                    // Ažuriraj udaljenost i brzinu iz glavnih podataka
                    tvDialogDistance.text = formatDistance(totalDistance)
                    tvDialogSpeed.text = "${String.format("%.1f", currentSpeed)} km/h"

                    // Ažuriraj status na osnovu GPS signala
                    val status = when {
                        currentSpeed > 1.0 -> "?? Pratimo kretanje..."
                        lastLocation != null -> "? GPS signal stabilan"
                        else -> "?? Tražim GPS signal..."
                    }
                    tvStatus.text = status

                    dialogHandler.postDelayed(this, 1000)
                }
            }
        }

        dialog.show()
        dialogHandler.post(dialogRunnable)

        // Automatski zatvori dijalog nakon 3 sekunde
        dialogHandler.postDelayed({
            if (dialog.isShowing) {
                dialog.dismiss()
                dialogHandler.removeCallbacks(dialogRunnable)
                Toast.makeText(this, "?? GPS aktiviran - snimamo rutu!", Toast.LENGTH_SHORT).show()
            }
        }, 3000)
    }
    private fun startTrackingService() {
        val intent = Intent(this, TrackingService::class.java).apply {
            action = TrackingService.ACTION_START_TRACKING
            // Prosledi tekuæu rutu ako postoji
            putExtra("ROUTE_ID", currentRoute?.id)
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            startForegroundService(intent)
        } else {
            startService(intent)
        }
    }
    private fun stopTrackingService() {
        val intent = Intent(this, TrackingService::class.java).apply {
            action = TrackingService.ACTION_STOP_TRACKING
        }
        stopService(intent)
    }


    private fun stopTracking() {
        // ZAUSTAVI POZADINSKI SERVIS PRVO!
        stopBackgroundTracking()

        Log.d("Tracking", "=== STOP TRACKING ===")
        isTracking = false

        // SAKRIJ TRACKING PANEL
        binding.trackingPanel.visibility = View.GONE

        // UKLONI SVE CALLBACKS
        trackingHandler.removeCallbacksAndMessages(null)

        binding.btnStartTracking.isEnabled = true
        binding.btnStopTracking.isEnabled = false
        binding.btnStartTracking.alpha = 1.0f
        binding.btnStopTracking.alpha = 0.5f

        currentRoute?.let { route ->
            val duration = trackingSeconds * 1000
            val completedRoute = route.copy(
                isCompleted = true,
                endTime = System.currentTimeMillis(),
                distance = totalDistance,
                duration = duration.toLong()
            )
            lifecycleScope.launch(Dispatchers.IO) {
                val app = application as App
                app.routeRepository.updateRoute(completedRoute)
            }
        }

        stopTrackingNotification()
        window.clearFlags(android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)

        val minutes = trackingSeconds / 60
        val seconds = trackingSeconds % 60

        Toast.makeText(
            this,
            "Snimanje zaustavljeno!\nUdaljenost: ${formatDistance(totalDistance)}\nVreme: ${minutes}m ${seconds}s",
            Toast.LENGTH_LONG
        ).show()

        Log.d("Tracking", "Snimanje zaustavljeno")
    }
    private val locationReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (intent.action == "LOCATION_UPDATE") {
                val latitude = intent.getDoubleExtra("latitude", 0.0)
                val longitude = intent.getDoubleExtra("longitude", 0.0)
                val accuracy = intent.getFloatExtra("accuracy", 0f)
                val speed = intent.getFloatExtra("speed", 0f)

                val location = Location("service").apply {
                    this.latitude = latitude
                    this.longitude = longitude
                    this.accuracy = accuracy
                    this.speed = speed
                }

                val geoPoint = GeoPoint(latitude, longitude)

                // AŽURIRAJTE RUTU SA NOVOM LOKACIJOM
                if (isTracking) {
                    addPointToRouteSmoothly(geoPoint, location)
                    updateDistanceAndSpeedAccurate(location)
                }
            }
        }
    }
    private fun addPointToRoute(location: GeoPoint, androidLocation: Location) {
        if (!isTracking) return

        // POBOLJŠANO FILTRIRANJE - IZBEGAVAJTE OŠTRE UGLOVE
        if (routePoints.isNotEmpty()) {
            val lastPoint = routePoints.last()
            val distance = calculateDistance(
                lastPoint.latitude, lastPoint.longitude,
                location.latitude, location.longitude
            )

            // FILTRIRAJ PREVELIKE I PREMANJE RAZMAKE
            if (distance < 3.0 || distance > 50.0) {
                Log.d("Tracking", "Preskoèena taèka: ${String.format("%.1f", distance)}m")
                return
            }

            // PROVERA ZA OŠTRE UGLOVE - koristite bearing za detekciju naglih skretanja
            lastLocation?.let { lastLoc ->
                if (lastLoc.hasBearing() && androidLocation.hasBearing()) {
                    val bearingDiff = Math.abs(lastLoc.bearing - androidLocation.bearing)
                    if (bearingDiff > 90 && bearingDiff < 270) { // Nagli zaokret
                        Log.d("Tracking", "Nagli zaokret detektovan: ${String.format("%.1f", bearingDiff)}°")
                        // Možete dodati dodatnu logiku ovde ako želite
                    }
                }
            }
        }

        routePoints.add(location)
        runOnUiThread {
            drawSmoothRouteOnMap()
        }

        savePointToDatabase(location)
        Log.d("Tracking", "Dodata taèka ${routePoints.size}: ${String.format("%.6f", location.latitude)}, ${String.format("%.6f", location.longitude)}")
    }
    private fun savePointToDatabase(location: GeoPoint) {
        currentRoute?.let { route ->
            lifecycleScope.launch(Dispatchers.IO) {
                try {
                    val app = application as jovannedeljkovic.gps_tracker_pro.App
                    val point = LocationPoint(
                        routeId = route.id,
                        latitude = location.latitude,
                        longitude = location.longitude,
                        timestamp = System.currentTimeMillis()
                    )
                    app.routeRepository.addLocationPoint(point)
                    Log.d("Tracking", "Taèka saèuvana u bazi: ${point.id}")
                } catch (e: Exception) {
                    Log.e("Tracking", "Greška pri èuvanju taèke: ${e.message}")
                }
            }
        }
    }
    private fun getUserName(): String {
        return try {
            val sharedPreferences = getSharedPreferences("user_prefs", MODE_PRIVATE)
            val userEmail = sharedPreferences.getString("user_email", "Korisnik")
            userEmail?.substringBefore("@") ?: "Korisnik"
        } catch (e: Exception) {
            "Korisnik"
        }
    }
    private fun formatDistance(meters: Double): String {
        return if (meters < 1000) {
            String.format("%.0f m", meters)
        } else {
            String.format("%.2f km", meters / 1000)
        }
    }
    private fun updateTrackingTime() {
        val minutes = trackingSeconds / 60
        val seconds = trackingSeconds % 60
        binding.tvTime.text = String.format("%02d:%02d", minutes, seconds)
    }

    private fun updateTrackingStats(distance: Double, speed: Double) {
        runOnUiThread {
            // Brzina sa bojama za bezbednost
            val speedColor = when {
                speed > 120 -> "#FFFF5252" // Crvena - prebrzo
                speed > 80 -> "#FFFF9800"  // Narandžasta - brzo
                else -> "#FF4CAF50"        // Zelena - normalno
            }

            binding.tvSpeed.text = String.format("%.1f", speed)
            binding.tvSpeed.setTextColor(Color.parseColor(speedColor))

            // Udaljenost
            binding.tvDistance.text = formatDistance(distance)

            // Ažuriraj progres taènosti
            updateAccuracyProgress()
        }
    }
    private fun updateAccuracyProgress() {
        lastLocation?.let { location ->
            val accuracy = location.accuracy
            val progress = when {
                accuracy < 10 -> 100
                accuracy < 20 -> 80
                accuracy < 30 -> 60
                accuracy < 50 -> 40
                else -> 20
            }

            // Ako imate progress bar u tracking panelu, ažurirajte ga ovde
            // binding.accuracyProgress?.progress = progress
            // binding.tvAccuracy?.text = when {
            //     accuracy < 10 -> "Odlièno"
            //     accuracy < 20 -> "Dobro"
            //     accuracy < 30 -> "Zadovoljava"
            //     else -> "Slabo"
            // }

            Log.d("Accuracy", "GPS taènost: ${accuracy}m, progress: $progress")
        }
    }
    private var isMapRotating = false

    private fun toggleMapRotation() {
        isMapRotating = !isMapRotating

        if (isMapRotating) {
            // Omoguæi rotaciju prema smeru kretanja
            locationOverlay.enableFollowLocation()
            locationOverlay.isDrawAccuracyEnabled = true


            Toast.makeText(this, "?? Auto-rotate ON - prati smer kretanja", Toast.LENGTH_SHORT).show()
        } else {
            // Onemoguæi rotaciju - fiksna orijentacija
            locationOverlay.disableFollowLocation()

            Toast.makeText(this, "?? Auto-rotate OFF - fiksna orijentacija", Toast.LENGTH_SHORT).show()
        }

        binding.mapView.invalidate()
    }
    private fun showMapTypeDialog() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val userEmail = getCurrentUserFromPrefs()
                val user = app.userRepository.getUserByEmail(userEmail)

                runOnUiThread {
                    val mapTypes = mutableListOf(
                        "??? OSM Standard (Preporuèeno)"
                    )

                    // ZAMENJENO: Satelitski sa Pregled Offline mapa
                    if (user == null || FeatureManager.canUseSatelliteMaps(user)) {
                        mapTypes.add("?? Pregled Offline Mapa")
                    } else {
                        mapTypes.add("?? Pregled Offline Mapa (PREMIUM)")
                    }

                    if (user == null || FeatureManager.canUseTopoMaps(user)) {
                        mapTypes.add("?? OSM Topo Planine")
                    } else {
                        mapTypes.add("?? OSM Topo Planine (PREMIUM)")
                    }

                    // ZAMENJENO: Offline Mape sa Upravljaj offline mapama
                    if (user == null || FeatureManager.canUseOfflineMaps(user)) {
                        mapTypes.add("?? Upravljaj Offline Mapama")
                    } else {
                        mapTypes.add("?? Upravljaj Offline Mapama (PREMIUM)")
                    }

                    mapTypes.add("?? OSM Art Style")

                    AlertDialog.Builder(this@MainActivity)
                        .setTitle("??? Dostupni Tipovi Mapa")
                        .setItems(mapTypes.toTypedArray()) { dialog, which ->
                            when (which) {
                                0 -> setHighQualityStandardMap()
                                1 -> {
                                    if (user == null || FeatureManager.canUseSatelliteMaps(user)) {
                                        showOfflineMapsList() // PROMENJENO: umesto setSatelliteMap()
                                    } else {
                                        showPremiumRequiredDialog("pregled offline mapa")
                                    }
                                }
                                2 -> {
                                    if (user == null || FeatureManager.canUseTopoMaps(user)) {
                                        setOsmTopoMap()
                                    } else {
                                        showPremiumRequiredDialog("topo mape")
                                    }
                                }
                                3 -> {
                                    if (user == null || FeatureManager.canUseOfflineMaps(user)) {
                                        showOfflineMapsDialog() // PROMENJENO: ostaje isto ali je preimenovano u meniju
                                    } else {
                                        showPremiumRequiredDialog("upravljanje offline mapama")
                                    }
                                }
                                4 -> setOsmArtMap()
                            }
                        }
                        .setNegativeButton("? Zatvori", null)
                        .show()
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Greška: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
// DODAJ OVE METODE NA KRAJ MAIN ACTIVITY:
private fun showPremiumRequiredDialog(featureName: String) {
    AlertDialog.Builder(this)
        .setTitle("?? Premium Funkcionalnost")
        .setMessage(
            """
            $featureName su dostupne samo PREMIUM korisnicima.
            
            ?? Nadogradi na PREMIUM za:
            • Neogranièene rute i taèke
            • Sve vrste mapa (satelitske, topo, offline)
            • Napredni eksport (GPX, KML)
            • Cloud backup
            
            Želite li da nadogradite na PREMIUM?
            """.trimIndent()
        )
        .setPositiveButton("?? Nadogradi") { dialog, which ->
            showPremiumUpgradeDialog()
        }
        .setNegativeButton("Nastavi BASIC", null)
        .show()
}
    private fun showPremiumUpgradeDialog() {
        val benefits = listOf(
            "? Neogranièeno praæenje ruta",
            "? Neogranièene taèke interesa",
            "? Sve vrste mapa (satelitske, topo, offline)",
            "? Napredni eksport (GPX, KML, PDF)",
            "? Cloud backup podataka",
            "? Detaljne statistike i analize",
            "? Prioritetna podrška"
        )

        val benefitsText = benefits.joinToString("\n")

        AlertDialog.Builder(this)
            .setTitle("?? Nadogradnja na PREMIUM")
            .setMessage(
                """
            Premium funkcionalnosti:
            
            $benefitsText
            
            ?? Cenovnik:
            • Meseèna pretplata: $2.99
            • Godišnja pretplata: $24.99 (30% jeftinije)
            • Doživotni pristup: $49.99
            
            Odaberite opciju:
            """.trimIndent()
            )
            .setPositiveButton("?? Meseèna ($2.99)") { dialog, which ->
                initiatePremiumPurchase("premium_monthly")
            }
            .setNeutralButton("?? Godišnja ($24.99)") { dialog, which ->
                initiatePremiumPurchase("premium_yearly")
            }
            .setNegativeButton("? Kasnije", null)
            .show()
    }

    private fun initiatePremiumPurchase(productId: String) {
        // Ovo æemo implementirati kada dodamo Google Play Billing
        Toast.makeText(this, "Premium kupovina æe biti dostupna uskoro!", Toast.LENGTH_LONG).show()

        // Za sada, simuliraj uspešnu kupovinu
        simulatePremiumUpgrade()
    }

    private fun simulatePremiumUpgrade() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val userEmail = getCurrentUserFromPrefs()
                val user = app.userRepository.getUserByEmail(userEmail)

                if (user != null) {
                    val success = app.userRepository.upgradeToPremium(user.id, 30) // 30 dana besplatno za test

                    runOnUiThread {
                        if (success) {
                            Toast.makeText(
                                this@MainActivity,
                                "?? Sada ste PREMIUM korisnik! Uživajte u svim funkcionalnostima!",
                                Toast.LENGTH_LONG
                            ).show()

                            // Osveži UI
                            checkUserFeatures()
                        }
                    }
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Greška: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun showOfflineMapsDialog() {
        val options = arrayOf(
            "?? Preuzmi Offline Mapu (Srbija)",
            "?? Pregled Offline Mapama",
            "??? Obriši Offline Mape",
            "?? Informacije o Offline Mapama"
        )

        AlertDialog.Builder(this)
            .setTitle("?? Upravljaj Offline Mapama")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> downloadOfflineMap()
                    1 -> showOfflineMapsList()
                    2 -> deleteOfflineMaps()
                    3 -> showOfflineMapsInfo()
                }
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }

    private fun downloadOfflineMap() {
        val regions = arrayOf(
            "??? Srbija - Standardna mapa",
            "??? Srbija - Satelitska mapa",  // ?? DODAJ SATELITSKU OPCIJU
            "??? Beograd - Standardna mapa",
            "??? Beograd - Satelitska mapa", // ?? DODAJ SATELITSKU OPCIJU
            "?? Niš - Standardna mapa",
            "??? Niš - Satelitska mapa",     // ?? DODAJ SATELITSKU OPCIJU
            "?? Custom Region - izaberi taèno šta ti treba",
            "??? Trenutno vidljivo podruèje (Satelitska)",
            "??? Trenutno vidljivo podruèje (Standardna)"
        )

        AlertDialog.Builder(this)
            .setTitle("??? Preuzmi Offline Mapu")
            .setItems(regions) { dialog, which ->
                when (which) {
                    0 -> downloadRegionSerbia()
                    1 -> downloadRegionSerbiaSatellite()  // ?? NOVA METODA
                    2 -> downloadRegionBelgrade()
                    3 -> downloadRegionBelgradeSatellite() // ?? NOVA METODA
                    4 -> downloadRegionNis()
                    5 -> downloadRegionNisSatellite()     // ?? NOVA METODA
                    6 -> selectCustomRegion()
                    7 -> downloadCurrentViewport()
                }
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun downloadRegionSerbiaSatellite() {
        val bbox = org.osmdroid.util.BoundingBox(45.5, 21.0, 43.0, 19.0)
        downloadSatelliteTilesForRegion(bbox, 8, 14, "Srbija Satelitska")
    }

    private fun downloadRegionBelgradeSatellite() {
        val bbox = org.osmdroid.util.BoundingBox(44.9, 20.6, 44.7, 20.3)
        downloadSatelliteTilesForRegion(bbox, 10, 16, "Beograd Satelitska")
    }

    private fun downloadRegionNisSatellite() {
        val bbox = org.osmdroid.util.BoundingBox(43.35, 21.95, 43.3, 21.85)
        downloadSatelliteTilesForRegion(bbox, 12, 18, "Niš Satelitska")
    }

    private fun downloadSatelliteTilesForRegion(bbox: org.osmdroid.util.BoundingBox, minZoom: Int, maxZoom: Int, regionName: String) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("??? Preuzimanje: $regionName")
            .setMessage("Priprema satelitskih tile-ova...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                var totalTiles = 0
                var downloadedTiles = 0

                // IZRAÈUNAJ UKUPAN BROJ TILE-OVA
                for (zoom in minZoom..maxZoom) {
                    totalTiles += calculateTilesForZoom(bbox, zoom)
                }

                withContext(Dispatchers.Main) {
                    progressDialog.setMessage("Preuzimanje: $regionName\nSatelitski tile-ovi\n0/$totalTiles")
                }

                // PREUZIMANJE SATELITSKIH TILE-OVA
                for (zoom in minZoom..maxZoom) {
                    val downloaded = downloadSatelliteZoomLevel(bbox, zoom, regionName, progressDialog, downloadedTiles, totalTiles)
                    downloadedTiles += downloaded
                }

                // SAÈUVAJ METAPODATKE SA OZNAKOM DA JE SATELITSKA
                saveSatelliteRegionMetadata(bbox, minZoom, maxZoom, regionName, downloadedTiles)

                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    showSatelliteDownloadSuccess(regionName, downloadedTiles)
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    private suspend fun downloadSatelliteZoomLevel(
        bbox: org.osmdroid.util.BoundingBox,
        zoom: Int,
        regionName: String,
        progressDialog: AlertDialog,
        alreadyDownloaded: Int,
        totalTiles: Int
    ): Int {
        var downloaded = 0
        val northTile = lat2tile(bbox.latNorth, zoom)
        val southTile = lat2tile(bbox.latSouth, zoom)
        val eastTile = lon2tile(bbox.lonEast, zoom)
        val westTile = lon2tile(bbox.lonWest, zoom)

        for (x in westTile..eastTile) {
            for (y in northTile..southTile) {
                try {
                    downloadSatelliteSingleTile(x, y, zoom)
                    downloaded++

                    // AŽURIRAJ PROGRESS
                    if (downloaded % 5 == 0) {
                        val currentTotal = alreadyDownloaded + downloaded
                        withContext(Dispatchers.Main) {
                            progressDialog.setMessage(
                                "Preuzimanje: $regionName\n" +
                                        "Satelitski tile-ovi\n" +
                                        "$currentTotal/$totalTiles tile-ova\n" +
                                        "Progress: ${(currentTotal * 100 / totalTiles)}%"
                            )
                        }
                    }

                } catch (e: Exception) {
                    Log.e("SatelliteTile", "Greška pri satelitskom tile $zoom/$x/$y: ${e.message}")
                }
            }
        }

        return downloaded
    }

    private fun downloadSatelliteSingleTile(x: Int, y: Int, zoom: Int) {
        Log.d("DownloadDebug", "??? POÈINJEM preuzimanje satelitskog tila: zoom=$zoom, x=$x, y=$y")

        // ArcGIS World Imagery servis
        val tileUrl = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/$zoom/$y/$x"

        Log.d("DownloadDebug", "?? URL: $tileUrl")

        val client = OkHttpClient.Builder()
            .connectTimeout(15, java.util.concurrent.TimeUnit.SECONDS)
            .readTimeout(15, java.util.concurrent.TimeUnit.SECONDS)
            .build()

        val request = Request.Builder()
            .url(tileUrl)
            .header("User-Agent", "Mozilla/5.0 (Android GPS Tracker)")
            .build()

        try {
            val response = client.newCall(request).execute()
            Log.d("DownloadDebug", "?? HTTP Status: ${response.code}")

            if (response.isSuccessful) {
                val tileData = response.body?.bytes()
                if (tileData != null && tileData.isNotEmpty()) {
                    Log.d("DownloadDebug", "? Primljeno ${tileData.size} bajtova")
                    saveSatelliteTileToCache(x, y, zoom, tileData)
                    Log.d("DownloadDebug", "?? Saèuvan tile: $zoom/$x/$y")
                } else {
                    Log.e("DownloadDebug", "? Tile data je NULL ili prazna")
                }
            } else {
                Log.e("DownloadDebug", "? HTTP greška: ${response.code} - ${response.message}")
            }
            response.close()
        } catch (e: Exception) {
            Log.e("DownloadDebug", "?? Greška pri preuzimanju: ${e.message}")
            e.printStackTrace()
        }
    }
    /*private fun debugTileCache() {
        try {
            val satelliteDir = File(filesDir, "osmdroid/tiles/World_Imagery")
            val tileCount = countTilesInDirectory(satelliteDir)

            // Proveri da li folder postoji
            val folderExists = satelliteDir.exists()
            val folderPath = satelliteDir.absolutePath

            // Proveri permisije
            val canWrite = satelliteDir.canWrite()
            val canRead = satelliteDir.canRead()

            val message = """
            ??? DEBUG CACHE INFORMACIJE:
            
            ?? Folder postoji: ${if (folderExists) "?" else "?"}
            ?? Putanja: $folderPath
            ?? Može da piše: ${if (canWrite) "?" else "?"}
            ??? Može da èita: ${if (canRead) "?" else "?"}
            
            ?? Satelitski tile-ovi: $tileCount
            
            ?? Ako je 0 tile-ova:
            • Tile-ovi se ne preuzimaju ILI
            • Nema dozvola za pisanje ILI  
            • Folder ne postoji
        """.trimIndent()

            Log.d("TileDebug", message)

            AlertDialog.Builder(this)
                .setTitle("??? Debug Cache")
                .setMessage(message)
                .setPositiveButton("Test Preuzimanje") { dialog, which ->
                    testSimpleDownload()
                }
                .setNegativeButton("OK", null)
                .show()

        } catch (e: Exception) {
            Log.e("TileDebug", "Greška: ${e.message}")
            Toast.makeText(this, "? Greška pri debug-u: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }*/

    private fun createSatelliteTileSource(): org.osmdroid.tileprovider.tilesource.ITileSource {
        return object : org.osmdroid.tileprovider.tilesource.XYTileSource(
            "World_Imagery",
            0,
            19,
            256,
            ".png",
            arrayOf(
                "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
            )
        ) {
            override fun getTileURLString(pMapTileIndex: Long): String {
                val zoom = MapTileIndex.getZoom(pMapTileIndex)
                val x = MapTileIndex.getX(pMapTileIndex)
                val y = MapTileIndex.getY(pMapTileIndex)
                return "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/$zoom/$y/$x"
            }
        }
    }
    private fun saveSatelliteTileToCache(x: Int, y: Int, zoom: Int, tileData: ByteArray) {
        try {
            // KORISTITE OSMdroid cache putanju
            val cacheDir = File(Configuration.getInstance().osmdroidBasePath, "tiles/World_Imagery")

            if (!cacheDir.exists()) {
                val created = cacheDir.mkdirs()
                Log.d("TileSave", "?? Kreiran cache folder: ${cacheDir.absolutePath} - $created")
            }

            val tileFile = File(cacheDir, "$zoom/$x/$y.png")
            tileFile.parentFile?.mkdirs()

            Log.d("TileSave", "?? Èuvam tile: ${tileFile.absolutePath}")

            // Proverite da li možete da pišete u fajl
            if (tileFile.parentFile?.canWrite() != true) {
                Log.e("TileSave", "? Nema dozvola za pisanje u: ${tileFile.parentFile?.absolutePath}")
                return
            }

            tileFile.writeBytes(tileData)

            // Proverite da li je fajl zaista saèuvan
            val saved = tileFile.exists()
            val savedSize = tileFile.length()

            Log.d("TileSave", "? Tile SAÈUVAN: $saved, velièina: $savedSize bajtova")
            Log.d("TileSave", "?? Putanja: ${tileFile.absolutePath}")

        } catch (e: Exception) {
            Log.e("TileSave", "?? GREŠKA pri èuvanju tila: ${e.message}")
            e.printStackTrace()
        }
    }
    private fun checkStoragePermissions(): Boolean {
        // Za sada vraæamo true jer koristimo samo interni storage
        Log.d("Permissions", "Koristim interni storage - dozvole nisu potrebne")
        return true
    }

    private fun requestStoragePermissions() {
        // SAMO ZA ANDROID 9 I NIŽE
        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.P) {
            if (shouldShowRequestPermissionRationale(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                AlertDialog.Builder(this)
                    .setTitle("?? Dozvole za skladištenje")
                    .setMessage("Aplikaciji su potrebne dozvole za pristup Download folderu (samo za Android 9 i niže).")
                    .setPositiveButton("Dozvoli") { dialog, which ->
                        requestPermissions(
                            arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE),
                            LOCATION_PERMISSION_REQUEST_CODE + 100
                        )
                    }
                    .setNegativeButton("Kasnije", null)
                    .show()
            } else {
                requestPermissions(
                    arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE),
                    LOCATION_PERMISSION_REQUEST_CODE + 100
                )
            }
        } else {
            // ANDROID 10+ - KORISTI MediaStore BEZ DOZVOLA
            queryGpxFilesWithMediaStoreAndroid10()
        }
    }
    private fun showNoGpxFilesFound() {
        AlertDialog.Builder(this)
            .setTitle("?? Nema GPX fajlova")
            .setMessage("""
        Nema GPX fajlova u Download folderu.
        
        Kako dodati GPX fajlove:
        
        1. ?? Preuzmite GPX fajl sa interneta
        2. ?? Saèuvajte ga u Download folder
        3. ?? Vratite se ovde i osvežite listu
        
        Preporuèeno: Koristite "File Picker" opciju za bolju kompatibilnost.
        """.trimIndent())
            .setPositiveButton("?? File Picker") { dialog, which ->
                importRouteFromFile()
            }
            .setNeutralButton("?? Osveži") { dialog, which ->
                importGpxFromDownloads()
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }
    private fun importRouteFromFile() {
        Log.d("ImportDebug", "?? POZIVAM importRouteFromFile()")
        try {
            val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
                addCategory(Intent.CATEGORY_OPENABLE)
                type = "*/*"
                putExtra(Intent.EXTRA_MIME_TYPES, arrayOf(
                    "application/gpx+xml",
                    "application/xml",
                    "text/xml",
                    "text/plain",
                    "application/octet-stream"
                ))
                putExtra(Intent.EXTRA_ALLOW_MULTIPLE, false)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                addFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION)
            }

            try {
                startActivityForResult(intent, IMPORT_GPX_REQUEST_CODE)
                Toast.makeText(this, "?? Izaberite GPX fajl sa rutom", Toast.LENGTH_SHORT).show()
                Log.d("ImportDebug", "? USPEO: Pokrenut File Picker za rutu")
            } catch (e: Exception) {
                Log.w("ImportDebug", "OPEN_DOCUMENT nije dostupan, koristim GET_CONTENT: ${e.message}")
                // FALLBACK: Koristi stari intent za stare Androide
                val fallbackIntent = Intent(Intent.ACTION_GET_CONTENT).apply {
                    addCategory(Intent.CATEGORY_OPENABLE)
                    type = "*/*"
                    putExtra(Intent.EXTRA_MIME_TYPES, arrayOf(
                        "application/gpx+xml",
                        "application/xml",
                        "text/xml",
                        "text/plain"
                    ))
                }
                startActivityForResult(fallbackIntent, IMPORT_GPX_REQUEST_CODE)
                Toast.makeText(this, "?? Izaberite GPX fajl", Toast.LENGTH_SHORT).show()
            }

        } catch (e: Exception) {
            Log.e("ImportDebug", "? GREŠKA pri otvaranju file pickera: ${e.message}")
            Toast.makeText(this, "? Greška: ${e.message}", Toast.LENGTH_SHORT).show()

            // FALLBACK: Pokaži opciju za direktan pristup Download folderu
            showImportFallbackOptions()
        }
    }
    private fun showImportFallbackForPoints() {
        AlertDialog.Builder(this)
            .setTitle("? File Picker nije dostupan")
            .setMessage("Želite li da pokušate sa Download folderom za taèke?")
            .setPositiveButton("?? Da, Download folder") { dialog, which ->
                // OVDE MOŽEŠ DODATI LOGIKU ZA UVOZ TAÈAKA IZ DOWNLOAD FOLDERA
                Toast.makeText(this, "?? Uvoz taèaka iz Download foldera æe biti dostupan uskoro", Toast.LENGTH_LONG).show()

                // Za sada, pokaži obaveštenje
                AlertDialog.Builder(this)
                    .setTitle("?? Funkcionalnost u izradi")
                    .setMessage("Uvoz taèaka iz Download foldera æe biti dostupan u narednoj verziji aplikacije.")
                    .setPositiveButton("OK", null)
                    .show()
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun countTilesInDirectory(dir: File): Int {
        if (!dir.exists()) return 0

        var count = 0
        dir.walk().forEach { file ->
            if (file.isFile && file.name.endsWith(".png")) {
                count++
            }
        }
        return count
    }

    private fun saveSatelliteRegionMetadata(bbox: org.osmdroid.util.BoundingBox, minZoom: Int, maxZoom: Int, regionName: String, tileCount: Int) {
        val metadata = mapOf(
            "regionName" to regionName,
            "north" to bbox.latNorth,
            "south" to bbox.latSouth,
            "east" to bbox.lonEast,
            "west" to bbox.lonWest,
            "minZoom" to minZoom,
            "maxZoom" to maxZoom,
            "tileCount" to tileCount,
            "downloadDate" to System.currentTimeMillis(),
            "isSatellite" to true  // OVO JE KLJUÈNO!
        )

        val metadataDir = File(getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), "offline_regions")
        if (!metadataDir.exists()) {
            metadataDir.mkdirs()
        }

        val metadataFile = File(metadataDir, "${regionName.replace(" ", "_")}.json")
        metadataFile.writeText(Gson().toJson(metadata))

        Log.d("SatelliteSave", "? Saèuvana satelitska mapa: $regionName, isSatellite: true")
    }

    private fun showSatelliteDownloadSuccess(regionName: String, tileCount: Int) {
        AlertDialog.Builder(this)
            .setTitle("?? $regionName Preuzeta!")
            .setMessage("""
            Uspešno preuzeto $tileCount satelitskih tile-ova!
            
            ??? Sada možete koristiti satelitski prikaz BEZ interneta.
            
            Želite li odmah preæi na satelitski offline mod?
        """.trimIndent())
            .setPositiveButton("? Koristi Satelitski") { dialog, which ->
                enableSatelliteOfflineMode(regionName)
            }
            .setNegativeButton("?? Ostani Online", null)
            .show()
    }
    private fun downloadRegionHighways() {
        // Autoputevi Srbije: A1, A2, A3, A4
        val bbox = org.osmdroid.util.BoundingBox(46.0, 22.0, 42.5, 18.5)
        downloadTilesForRegion(bbox, 10, 14, "Autoputevi Srbije")
    }

    private fun downloadRegionRivers() {
        // Glavne reke Srbije
        val bbox = org.osmdroid.util.BoundingBox(45.5, 21.5, 43.5, 19.0)
        downloadTilesForRegion(bbox, 10, 14, "Reke Srbije")
    }
    private fun downloadRegionSerbia() {
        // Centralna Srbija: Beograd, Niš, Novi Sad
        val bbox = org.osmdroid.util.BoundingBox(45.5, 21.0, 43.0, 19.0) // north, east, south, west
        downloadTilesForRegion(bbox, 8, 14, "Srbija Centralna")
    }

    private fun downloadRegionBelgrade() {
        // Beograd i okolina
        val bbox = org.osmdroid.util.BoundingBox(44.9, 20.6, 44.7, 20.3)
        downloadTilesForRegion(bbox, 10, 16, "Beograd")
    }

    private fun downloadRegionNis() {
        // Niš i okolina
        val bbox = org.osmdroid.util.BoundingBox(43.35, 21.95, 43.3, 21.85)
        downloadTilesForRegion(bbox, 12, 18, "Niš")
    }

    private fun downloadRegionNationalParks() {
        // Fruška gora + Tara
        val bbox = org.osmdroid.util.BoundingBox(45.2, 19.9, 44.0, 19.4)
        downloadTilesForRegion(bbox, 10, 16, "Nacionalni Parkovi")
    }

    private fun downloadCurrentViewport() {
        val bbox = binding.mapView.boundingBox
        val currentZoom = binding.mapView.zoomLevel.toInt()

        val options = arrayOf("??? Trenutno vidljivo podruèje (Satelitska)", "??? Trenutno vidljivo podruèje (Standardna)")

        AlertDialog.Builder(this)
            .setTitle("?? Preuzmi Trenutni Prikaz")
            .setMessage("Izaberite tip mape za preuzimanje:")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> { // Satelitska
                        // DODAJ OZNAKU DA JE SATELITSKA
                        downloadSatelliteTilesForRegion(bbox, currentZoom, currentZoom + 2, "Trenutni Prikaz Satelitski")
                    }
                    1 -> { // Standardna
                        downloadTilesForRegion(bbox, currentZoom, currentZoom + 2, "Trenutni Prikaz Standardni")
                    }
                }
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun downloadTilesForRegion(bbox: org.osmdroid.util.BoundingBox, minZoom: Int, maxZoom: Int, regionName: String) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Preuzimanje: $regionName")
            .setMessage("Priprema...\nZoom: $minZoom-$maxZoom")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                var totalTiles = 0

                // IZRAÈUNAJ UKUPAN BROJ TILE-OVA
                for (zoom in minZoom..maxZoom) {
                    totalTiles += calculateTilesForZoom(bbox, zoom)
                }

                // JEDNOSTAVNA KALKULACIJA VELIÈINE
                val estimatedSizeMB = (totalTiles * 35) / 1024.0
                val displaySize = "~${String.format("%.1f", estimatedSizeMB)} MB"

                withContext(Dispatchers.Main) {
                    progressDialog.setMessage("Preuzimanje: $regionName\nZoom: $minZoom-$maxZoom\nTile-ova: $totalTiles\nVelièina: $displaySize\n0%")
                }

                var downloadedTiles = 0

                // PREUZIMANJE TILE-OVA ZA SVAKI ZOOM LEVEL
                for (zoom in minZoom..maxZoom) {
                    val downloaded = downloadZoomLevel(bbox, zoom, regionName, progressDialog, downloadedTiles, totalTiles)
                    downloadedTiles += downloaded
                }

                // SAÈUVAJ METAPODATKE
                saveRegionMetadata(bbox, minZoom, maxZoom, regionName, downloadedTiles)

                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    showDownloadSuccess(regionName, downloadedTiles)
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }


    private fun calculateTilesForZoom(bbox: org.osmdroid.util.BoundingBox, zoom: Int): Int {
        val northTile = lat2tile(bbox.latNorth, zoom)
        val southTile = lat2tile(bbox.latSouth, zoom)
        val eastTile = lon2tile(bbox.lonEast, zoom)
        val westTile = lon2tile(bbox.lonWest, zoom)

        return (eastTile - westTile + 1) * (southTile - northTile + 1)
    }

    private suspend fun downloadZoomLevel(
        bbox: org.osmdroid.util.BoundingBox,
        zoom: Int,
        regionName: String,
        progressDialog: AlertDialog,
        alreadyDownloaded: Int,
        totalTiles: Int
    ): Int {
        var downloaded = 0
        val northTile = lat2tile(bbox.latNorth, zoom)
        val southTile = lat2tile(bbox.latSouth, zoom)
        val eastTile = lon2tile(bbox.lonEast, zoom)
        val westTile = lon2tile(bbox.lonWest, zoom)

        for (x in westTile..eastTile) {
            for (y in northTile..southTile) {
                try {
                    downloadSingleTile(x, y, zoom)
                    downloaded++

                    // AŽURIRAJ PROGRESS
                    if (downloaded % 10 == 0) { // Ažuriraj na svakih 10 tile-ova
                        val currentTotal = alreadyDownloaded + downloaded
                        withContext(Dispatchers.Main) {
                            progressDialog.setMessage(
                                "Preuzimanje: $regionName\n" +
                                        "Zoom: $zoom\n" +
                                        "$currentTotal/$totalTiles tile-ova\n" +
                                        "Progress: ${(currentTotal * 100 / totalTiles)}%"
                            )
                        }
                    }

                } catch (e: Exception) {
                    Log.e("TileDownload", "Greška pri preuzimanju tile $zoom/$x/$y: ${e.message}")
                }
            }
        }

        return downloaded
    }

    private fun downloadSingleTile(x: Int, y: Int, zoom: Int) {
        val tileUrl = "https://tile.openstreetmap.org/$zoom/$x/$y.png"
        val client = OkHttpClient()
        val request = Request.Builder().url(tileUrl).build()

        client.newCall(request).execute().use { response ->
            if (response.isSuccessful) {
                // SAÈUVAJ TILE U OSMdroid CACHE
                val tileData = response.body?.bytes()
                tileData?.let { data -> saveTileToCache(x, y, zoom, data) }
            }
        }
    }

    private fun saveTileToCache(x: Int, y: Int, zoom: Int, tileData: ByteArray) {
        val cacheDir = File(Configuration.getInstance().osmdroidBasePath, "tiles/OpenStreetMap")
        if (!cacheDir.exists()) {
            cacheDir.mkdirs()
        }

        val tileFile = File(cacheDir, "$zoom/$x/$y.png")
        tileFile.parentFile?.mkdirs()
        tileFile.writeBytes(tileData)
    }

    private fun saveRegionMetadata(bbox: org.osmdroid.util.BoundingBox, minZoom: Int, maxZoom: Int, regionName: String, tileCount: Int) {
        val metadata = mapOf(
            "regionName" to regionName,
            "north" to bbox.latNorth,
            "south" to bbox.latSouth,
            "east" to bbox.lonEast,
            "west" to bbox.lonWest,
            "minZoom" to minZoom,
            "maxZoom" to maxZoom,
            "tileCount" to tileCount,
            "downloadDate" to System.currentTimeMillis()
        )

        val metadataDir = File(getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), "offline_regions")
        if (!metadataDir.exists()) {
            metadataDir.mkdirs()
        }

        val metadataFile = File(metadataDir, "${regionName.replace(" ", "_")}.json")
        metadataFile.writeText(Gson().toJson(metadata))
    }

    private fun showDownloadSuccess(regionName: String, tileCount: Int) {
        AlertDialog.Builder(this)
            .setTitle("?? $regionName Preuzeta!")
            .setMessage("""
            Uspešno preuzeto $tileCount tile-ova!
            
            ??? Sada možete koristiti ovaj region BEZ interneta.
            
            Želite li preæi na offline mod?
        """.trimIndent())
            .setPositiveButton("? Koristi Offline") { dialog, which ->
                enableOfflineMode(regionName)
            }
            .setNegativeButton("?? Ostani Online", null)
            .show()
    }

    private fun enableOfflineMode(regionName: String) {
        try {
            Log.d("OfflineDebug", "?? Pokreæem offline mod za: $regionName")

            // PROVERITE DA LI JE SATELITSKA ILI STANDARDNA MAPA
            val isSatellite = regionName.contains("satelit", ignoreCase = true) ||
                    regionName.contains("satellite", ignoreCase = true)

            Log.d("OfflineDebug", "?? Je li satelitska: $isSatellite")

            if (isSatellite) {
                // PROVERITE TILE-OVE PRVO
                val satelliteDir = File(Configuration.getInstance().osmdroidBasePath, "tiles/World_Imagery")
                val tileCount = countTilesInDirectory(satelliteDir)
                Log.d("OfflineDebug", "??? Satelitski tile-ovi: $tileCount")

                if (tileCount > 0) {
                    // POKUŠAJTE SA PRAVIM TILE SOURCE-OM
                    val satelliteSource = createSatelliteTileSource()
                    binding.mapView.setTileSource(satelliteSource)
                    Log.d("OfflineDebug", "? Postavljen satelitski tile source")
                } else {
                    Toast.makeText(this, "? Nema satelitskih tile-ova!", Toast.LENGTH_LONG).show()
                    return
                }
            } else {
                // STANDARDNA MAPA
                binding.mapView.setTileSource(TileSourceFactory.MAPNIK)
                Log.d("OfflineDebug", "? Postavljena standardna mapa")
            }

            // BITNO: ISKLJUÈITE INTERNET ZA OFFLINE MOD
            binding.mapView.setUseDataConnection(false)
            Log.d("OfflineDebug", "?? Internet iskljuèen za offline mod")

            binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)

            // OSVEŽITE PRIKAZ
            binding.mapView.invalidate()
            binding.mapView.postInvalidate()

            Toast.makeText(this, "??? Offline: $regionName", Toast.LENGTH_LONG).show()
            Log.d("OfflineDebug", "?? Offline mod uspešno aktiviran!")

        } catch (e: Exception) {
            Log.e("OfflineDebug", "?? Greška: ${e.message}")
            Toast.makeText(this, "? Greška: ${e.message}", Toast.LENGTH_SHORT).show()
            setHighQualityStandardMap()
        }
    }
    // POMOÆNE FUNKCIJE ZA TILE KALKULACIJE
    private fun lat2tile(lat: Double, zoom: Int): Int {
        return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * (1 shl zoom)).toInt()
    }

    private fun lon2tile(lon: Double, zoom: Int): Int {
        return Math.floor((lon + 180) / 360 * (1 shl zoom)).toInt()
    }
    private fun showOfflineMapsList() {
        val metadataDir = File(getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), "offline_regions")
        val regionFiles = metadataDir.listFiles { file ->
            file.name.endsWith(".json")
        }

        if (!metadataDir.exists() || regionFiles.isNullOrEmpty()) {
            Toast.makeText(this, "?? Nema preuzetih offline mapa", Toast.LENGTH_LONG).show()
            downloadOfflineMap()
            return
        }

        val regionNames = regionFiles.map { file ->
            try {
                val metadata = Gson().fromJson(file.readText(), Map::class.java)
                val tileCount = metadata["tileCount"] as? Int ?: 0
                val isSatellite = metadata["isSatellite"] as? Boolean ?: false

                // ZAMENJENI ?? SA IKONAMA
                if (isSatellite) {
                    "??? ${metadata["regionName"]} ($tileCount tile-ova)"
                } else {
                    "??? ${metadata["regionName"]} ($tileCount tile-ova)"
                }
            } catch (e: Exception) {
                "? Nevažeæa mapa"
            }
        }.toTypedArray()

        AlertDialog.Builder(this)
            .setTitle("?? Dostupne Offline Mape")
            .setItems(regionNames) { dialog, which ->
                val selectedFile = regionFiles[which]
                try {
                    val metadata = Gson().fromJson(selectedFile.readText(), Map::class.java)
                    val regionName = metadata["regionName"] as String
                    val isSatellite = metadata["isSatellite"] as? Boolean ?: false

                    if (isSatellite) {
                        enableSatelliteOfflineMode(regionName)
                    } else {
                        enableOfflineMode(regionName)
                    }
                } catch (e: Exception) {
                    Toast.makeText(this, "? Greška pri uèitavanju", Toast.LENGTH_SHORT).show()
                }
            }
            .setPositiveButton("?? Preuzmi Novu") { dialog, which ->
                downloadOfflineMap()
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }

    private fun deleteAllOfflineMaps() {
        AlertDialog.Builder(this)
            .setTitle("??? Brisanje Svih Offline Mapa")
            .setMessage("Da li ste sigurni? Ovo æe obrisati sve preuzete tile-ove i region podatke.")
            .setPositiveButton("? Obriši Sve") { dialog, which ->
                lifecycleScope.launch(Dispatchers.IO) {
                    try {
                        // OBRIŠI METADATA
                        val metadataDir = File(getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), "offline_regions")
                        if (metadataDir.exists()) {
                            metadataDir.deleteRecursively()
                        }

                        withContext(Dispatchers.Main) {
                            Toast.makeText(this@MainActivity, "??? Sve offline mape obrisane", Toast.LENGTH_LONG).show()
                            binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue) // Resetuj background
                        }
                    } catch (e: Exception) {
                        withContext(Dispatchers.Main) {
                            Toast.makeText(this@MainActivity, "? Greška pri brisanju", Toast.LENGTH_SHORT).show()
                        }
                    }
                }
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun startOfflineMapDownload() {
        // POKAŽI PROGRESS DIALOG
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Preuzimanje mape...")
            .setMessage("Molimo saèekajte...\n\nSrbija ~50MB\n\nNe zatvarajte aplikaciju!")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                // SIMULIRAJ DOWNLOAD (u realnoj app, ovde bi bio pravi download)
                for (i in 1..10) {
                    delay(1000) // 1 sekunda po koraku

                    withContext(Dispatchers.Main) {
                        val progress = i * 10
                        progressDialog.setMessage("Preuzimanje... $progress%\n\nSrbija ~50MB\n\nNe zatvarajte aplikaciju!")
                    }
                }

                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Offline mapa uspešno preuzeta!", Toast.LENGTH_LONG).show()
                    showOfflineMapReadyDialog()
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška pri preuzimanju: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    private fun selectCustomRegion() {
        AlertDialog.Builder(this)
            .setTitle("?? Izaberi Custom Region")
            .setMessage("""
            Kako izabrati region:
            
            1. Zoom-uj na željeno podruèje
            2. Pomeri mapu da vidiš taèno šta želiš
            3. Klikni OK da preuzmeš trenutno vidljivo podruèje
            
            ?? Savet: Zoom level 12-16 je idealan za offline
        """.trimIndent())
            .setPositiveButton("? Preuzmi Trenutni Prikaz") { dialog, which ->
                downloadCurrentViewportCustom()
            }
            .setNeutralButton("?? Podesi Taèno") { dialog, which ->
                showCustomRegionSelector()
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun downloadCurrentViewportCustom() {
        val bbox = binding.mapView.boundingBox
        val currentZoom = binding.mapView.zoomLevel.toInt()

        val regionInfo = """
        ?? Region: ${String.format("%.2f", bbox.latNorth)}°N - ${String.format("%.2f", bbox.latSouth)}°S
                  ${String.format("%.2f", bbox.lonWest)}°W - ${String.format("%.2f", bbox.lonEast)}°E
        ?? Zoom: $currentZoom
        ??? Približna lokacija: ${getRegionName(bbox)}
    """.trimIndent()

        // DODAJ IZBOR TIPA MAPE
        val options = arrayOf("??? Satelitska", "??? Standardna")

        AlertDialog.Builder(this)
            .setTitle("?? Preuzmi Custom Region")
            .setMessage(regionInfo)
            .setSingleChoiceItems(options, 0) { dialog, which ->
                val isSatellite = (which == 0)
            }
            .setPositiveButton("?? Preuzmi") { dialog, which ->
                val isSatellite = (dialog as AlertDialog).listView.checkedItemPosition == 0
                if (isSatellite) {
                    downloadSatelliteTilesForRegion(bbox, currentZoom, currentZoom + 2, "Custom Region Satelitski")
                } else {
                    downloadTilesForRegion(bbox, currentZoom, currentZoom + 2, "Custom Region Standardni")
                }
            }
            .setNegativeButton("?? Promeni", null)
            .show()
    }
    private fun getRegionName(bbox: org.osmdroid.util.BoundingBox): String {
        // JEDNOSTAVNA DETEKCIJA LOKACIJE PO KOORDINATAMA
        val centerLat = (bbox.latNorth + bbox.latSouth) / 2
        val centerLon = (bbox.lonEast + bbox.lonWest) / 2

        return when {
            centerLat > 44.5 && centerLon > 20.0 -> "Severna Srbija (Beograd)"
            centerLat > 43.0 && centerLon > 21.0 -> "Južna Srbija (Niš)"
            centerLat > 45.0 -> "Vojvodina"
            centerLat < 43.0 -> "Južna Srbija/Kosovo"
            else -> "Centralna Srbija"
        }
    }
    private fun showCustomRegionSelector() {
        val zoomLevels = arrayOf(
            "?? Niski detalji (zoom 8-10) - Celokupna Srbija",
            "?? Srednji detalji (zoom 10-13) - Gradovi",
            "?? Visoki detalji (zoom 13-16) - Ulice",
            "?? Veoma visoki detalji (zoom 16-18) - Zgrade"
        )

        AlertDialog.Builder(this)
            .setTitle("??? Nivo Detalja")
            .setItems(zoomLevels) { dialog, which ->
                val (minZoom, maxZoom) = when (which) {
                    0 -> 8 to 10
                    1 -> 10 to 13
                    2 -> 13 to 16
                    3 -> 16 to 18
                    else -> 12 to 15
                }

                // DODAJ IZBOR TIPA MAPE
                val mapTypes = arrayOf("??? Satelitska", "??? Standardna")

                AlertDialog.Builder(this@MainActivity)
                    .setTitle("??? Tip Mape")
                    .setSingleChoiceItems(mapTypes, 0, null)
                    .setPositiveButton("?? Preuzmi") { innerDialog, innerWhich ->
                        val isSatellite = (innerDialog as AlertDialog).listView.checkedItemPosition == 0
                        val regionName = "Custom ${getRegionName(binding.mapView.boundingBox)}"

                        if (isSatellite) {
                            downloadSatelliteTilesForRegion(binding.mapView.boundingBox, minZoom, maxZoom, "$regionName Satelitski")
                        } else {
                            downloadTilesForRegion(binding.mapView.boundingBox, minZoom, maxZoom, "$regionName Standardni")
                        }
                    }
                    .setNegativeButton("? Otkaži", null)
                    .show()
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun showOfflineMapReadyDialog() {
        AlertDialog.Builder(this)
            .setTitle("?? Offline Mapa Spremana!")
            .setMessage("""
            Srbija mapa je uspešno preuzeta!
            
            Sada možete koristiti mapu BEZ interneta.
            
            ?? Online mape: bogatije informacije
            ?? Offline mape: brže, pouzdanije
            
            Želite li preæi na offline mapu?
        """.trimIndent())
            .setPositiveButton("? Koristi Offline") { dialog, which ->
                switchToOfflineMap()
            }
            .setNegativeButton("?? Ostani Online") { dialog, which ->
                // Ostani na online mapi
            }
            .show()
    }

    private fun switchToOfflineMap() {
        try {
            // PROVERI DA LI POSTOJE OFFLINE TILE-OVI
            val metadataDir = File(getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), "offline_regions")
            val regionFiles = metadataDir.listFiles { file -> file.name.endsWith(".json") }

            if (!metadataDir.exists() || regionFiles.isNullOrEmpty()) {
                Toast.makeText(this, "?? Nema preuzetih offline mapa", Toast.LENGTH_LONG).show()
                downloadOfflineMap()
                return
            }

            // PRIKAŽI LISTU REGIONA SA PROVEROM DOSTUPNOSTI
            val availableRegions = mutableListOf<String>()
            val regionNames = regionFiles.mapNotNull { file ->
                try {
                    val metadata = Gson().fromJson(file.readText(), Map::class.java)
                    val regionName = metadata["regionName"] as String
                    if (checkOfflineTilesAvailable(regionName)) {
                        availableRegions.add("??? $regionName")
                        regionName
                    } else {
                        "? $regionName (nema tile-ova)"
                        null
                    }
                } catch (e: Exception) {
                    "? Nevažeæa mapa"
                    null
                }
            }.toTypedArray()

            if (availableRegions.isEmpty()) {
                Toast.makeText(this, "?? Nema dostupnih offline tile-ova", Toast.LENGTH_LONG).show()
                downloadOfflineMap()
                return
            }

            AlertDialog.Builder(this)
                .setTitle("?? Dostupne Offline Mape")
                .setItems(regionNames) { dialog, which ->
                    val selectedFile = regionFiles[which]
                    try {
                        val metadata = Gson().fromJson(selectedFile.readText(), Map::class.java)
                        val regionName = metadata["regionName"] as String

                        if (regionName.contains("satelit", ignoreCase = true)) {
                            enableSatelliteOfflineMode(regionName)
                        } else {
                            enableOfflineMode(regionName)
                        }
                    } catch (e: Exception) {
                        Toast.makeText(this, "? Greška pri uèitavanju", Toast.LENGTH_SHORT).show()
                    }
                }
                .setPositiveButton("? Preuzmi Novu") { dialog, which ->
                    downloadOfflineMap()
                }
                .setNegativeButton("? Zatvori", null)
                .show()

        } catch (e: Exception) {
            Toast.makeText(this, "? Greška: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }
    private fun showOfflineStatus(isOffline: Boolean) {
        if (isOffline) {
            // MOŽEŠ DODATI TEKST ILI INDIKATOR DA JE OFFLINE MODE
            Toast.makeText(this, "?? Offline Mode - bez interneta", Toast.LENGTH_SHORT).show()
        }
    }

    private fun deleteOfflineMaps() {
        AlertDialog.Builder(this)
            .setTitle("??? Brisanje Offline Mapa")
            .setMessage("Da li ste sigurni da želite da obrišete sve offline mape? (~50MB)")
            .setPositiveButton("? Obriši") { dialog, which ->
                // SIMULIRANO BRISANJE
                Toast.makeText(this, "??? Offline mape obrisane", Toast.LENGTH_LONG).show()
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun showOfflineMapsInfo() {
        AlertDialog.Builder(this)
            .setTitle("?? O Offline Mapama")
            .setMessage("""
            ??? OFFLINE MAPE
            
            Prednosti:
            ?? Radi bez interneta
            ? Brži prikaz
            ?? Ušteda protoka
            ??? Pouzdano u prirodi
            
            Ogranièenja:
            ?? Ažurira se samo ruèno
            ?? Manje detalja nego online
            ?? Zauzima prostor
            
            Savet: Preuzmite mape pre putovanja!
        """.trimIndent())
            .setPositiveButton("? Razumem", null)
            .show()
    }

    private fun setOsmTopoMap() {
        try {
            // Pokušaj sa OpenTopo, ako ne uspe, koristi fallback
            binding.mapView.setTileSource(TileSourceFactory.OpenTopo)
            binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)
            Toast.makeText(this, "??? OSM Topo - Planine i reljef", Toast.LENGTH_LONG).show()
            binding.mapView.invalidate()
        } catch (e: Exception) {
            setHighQualityStandardMap()
            Toast.makeText(this, "Topo mapa nedostupna", Toast.LENGTH_SHORT).show()
        }
    }

    private fun setOsmArtMap() {
        try {
            // KORISTI DEFAULT STYLE ZA ÈIST PRIKAZ
            binding.mapView.setTileSource(TileSourceFactory.DEFAULT_TILE_SOURCE)
            binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)

            // VIZUELNI EFEKTI
            binding.mapView.setBackgroundColor(Color.parseColor("#F5F5DC")) // Bež pozadina

            Toast.makeText(this, "?? OSM Art Style - minimalistièki prikaz", Toast.LENGTH_LONG).show()
            binding.mapView.invalidate()
        } catch (e: Exception) {
            setHighQualityStandardMap()
        }
    }
    private fun setSatelliteMap() {
        try {
            // KORISTI USGS_SAT KOJI RADI
            binding.mapView.setTileSource(TileSourceFactory.USGS_SAT)
            binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)

            // PODEŠAVANJA ZA BOLJI PRIKAZ
            binding.mapView.maxZoomLevel = 16.0  // Limit zoom za satelitsku
            binding.mapView.controller.setZoom(10.0)  // Automatski zoom out

            Toast.makeText(this, "??? Satelitski prikaz - koristite za pregled terena", Toast.LENGTH_LONG).show()
            binding.mapView.invalidate()
        } catch (e: Exception) {
            Log.e("SatelliteMap", "Satelitska mapa nije dostupna: ${e.message}")
            setHighQualityStandardMap()
            Toast.makeText(this, "?? Satelitski prizak trenutno nedostupan", Toast.LENGTH_SHORT).show()
        }
    }


    private fun setOsmCycleMap() {
        try {
            // POKUŠAJ SA DOSTUPNIM CYCLE SOURCE-OVIMA
            val cycleSources = arrayOf(
                "https://tile.thunderforest.com/cycle/{z}/{x}/{y}.png?apikey=your_api_key",
                "https://a.tile.opencyclemap.org/cycle/{z}/{x}/{y}.png",
                "https://tile.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png"
            )

            var success = false
            for (sourceUrl in cycleSources) {
                try {
                    val source = org.osmdroid.tileprovider.tilesource.XYTileSource(
                        "CycleMap",
                        0, 18, 256, ".png",
                        arrayOf(sourceUrl)
                    )
                    binding.mapView.setTileSource(source)
                    success = true
                    break
                } catch (e: Exception) {
                    continue
                }
            }

            if (success) {
                binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)
                Toast.makeText(this, "?? OSM Biciklistièke Staze", Toast.LENGTH_LONG).show()
                binding.mapView.invalidate()
            } else {
                throw Exception("Nijedan cycle source nije dostupan")
            }

        } catch (e: Exception) {
            Log.e("CycleMap", "Cycle mape nedostupne: ${e.message}")
            setHighQualityStandardMap()
            Toast.makeText(this, "?? Biciklistièke mape trenutno nedostupne", Toast.LENGTH_LONG).show()
        }
    }
    private fun setOsmMaxDetail() {
        try {
            binding.mapView.setTileSource(TileSourceFactory.MAPNIK)
            binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)

            // POVEÆAJ max zoom za više detalja
            binding.mapView.maxZoomLevel = 22.0
            binding.mapView.controller.setZoom(18.0) // Automatski zumiraj

            // Vizuelni efekat - tamnija pozadina
            binding.mapView.setBackgroundColor(Color.parseColor("#2E2E2E"))

            Toast.makeText(this, "?? OSM Max detalja (Zoom 22x)", Toast.LENGTH_LONG).show()
            binding.mapView.invalidate()
        } catch (e: Exception) {
            Toast.makeText(this, "Greška pri detaljnoj mapi", Toast.LENGTH_SHORT).show()
            setStandardMap()
        }
    }

    private fun setOsmFast() {
        try {
            binding.mapView.setTileSource(TileSourceFactory.MAPNIK)
            binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)

            // SMANJI max zoom za brzinu
            binding.mapView.maxZoomLevel = 16.0
            binding.mapView.controller.setZoom(12.0) // Smanji zoom

            // Vizuelni efekat - svetlija pozadina
            binding.mapView.setBackgroundColor(Color.WHITE)

            Toast.makeText(this, "? OSM Brza (Zoom 16x)", Toast.LENGTH_LONG).show()
            binding.mapView.invalidate()
        } catch (e: Exception) {
            Toast.makeText(this, "Greška pri brzoj mapi", Toast.LENGTH_SHORT).show()
            setStandardMap()
        }
    }

    private fun setOsmNoLabels() {
        try {
            // Koristi OSM bez labela (èistiji prikaz)
            binding.mapView.setTileSource(TileSourceFactory.DEFAULT_TILE_SOURCE)
            binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)

            binding.mapView.maxZoomLevel = 19.0

            // Vizuelni efekat - sepia ton
            binding.mapView.setBackgroundColor(Color.parseColor("#F5F5DC"))

            Toast.makeText(this, "?? OSM Bez naziva", Toast.LENGTH_LONG).show()
            binding.mapView.invalidate()
        } catch (e: Exception) {
            Toast.makeText(this, "Greška pri mapi bez naziva", Toast.LENGTH_SHORT).show()
            setStandardMap()
        }
    }

    // DODAJ OVU FUNKCIJU - ONA JE NEDOSTAJALA
    // U MainActivity.kt zameni postojeæu setOsmTransport() funkciju:

    private fun setOsmTransport() {
        try {
            // POKUŠAJ SA DOSTUPNIM TRANSPORT SOURCE-OVIMA
            val transportSources = arrayOf(
                TileSourceFactory.PUBLIC_TRANSPORT,
                org.osmdroid.tileprovider.tilesource.XYTileSource(
                    "Transport", 0, 18, 256, ".png",
                    arrayOf("https://tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey=your_api_key")
                ),
                org.osmdroid.tileprovider.tilesource.XYTileSource(
                    "OSM_Transport", 0, 18, 256, ".png",
                    arrayOf("https://a.tile.opencyclemap.org/transport/{z}/{x}/{y}.png")
                )
            )

            var success = false
            for (source in transportSources) {
                try {
                    binding.mapView.setTileSource(source)
                    success = true
                    break
                } catch (e: Exception) {
                    continue
                }
            }

            if (success) {
                binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)
                Toast.makeText(this, "?? Transport/Saobraæaj", Toast.LENGTH_LONG).show()
                binding.mapView.invalidate()
            } else {
                throw Exception("Nijedan transport source nije dostupan")
            }

        } catch (e: Exception) {
            Log.e("TransportMap", "Transport mape nedostupne: ${e.message}")
            setHighQualityStandardMap()
            Toast.makeText(this, "?? Transport mape trenutno nedostupne", Toast.LENGTH_LONG).show()
        }
    }

    private fun setHighQualityMapSource() {
        try {
            // EKSPERIMENTIŠITE SA RAZLIÈITIM SOURCE-OVIMA ZA BOLJI QUALITY:
            val highQualitySources = arrayOf(
                TileSourceFactory.MAPNIK to "??? OSM Standard (HQ)",
                TileSourceFactory.OpenTopo to "??? OSM Topo",
                TileSourceFactory.USGS_TOPO to "?? USGS Topo",
                TileSourceFactory.USGS_SAT to "??? USGS Satelit"
            )

            // Prvo probaj MAPNIK (najpouzdaniji)
            binding.mapView.setTileSource(TileSourceFactory.MAPNIK)
            Log.d("MapSource", "Korišæen MAPNIK source")

        } catch (e: Exception) {
            Log.e("MapSource", "HQ source nije dostupan: ${e.message}")
            binding.mapView.setTileSource(TileSourceFactory.DEFAULT_TILE_SOURCE)
        }
    }
    // DODAJ I OVU FUNKCIJU ZA PREVIEW

    private fun showOsmPreview() {
        val previewText = """
    ??? OSM PREVIEW STILOVI:
    
    ?? MAX DETALJA (22x zoom):
    • Vidite pojedinaène zgrade
    • Detaljne ulice
    • Pojaèana oštrina
    • Tamnija pozadina
    
    ? BRZA (16x zoom):
    • Brže uèitavanje
    • Manje detalja  
    • Svetlija pozadina
    • Idealno za vožnju
    
    ?? BEZ NAZIVA:
    • Èist prikaz bez labela
    • Sepia pozadina
    • Fokus na geometriju
    
    ?? TRANSPORT:
    • Istaknute saobraæajnice
    • Javni prevoz
    • Biciklistièke staze
""".trimIndent()

        AlertDialog.Builder(this)
            .setTitle("OSM Stilovi - Preview")
            .setMessage(previewText)
            .setPositiveButton("Prikaži stilove") { dialog, which ->
                showMapTypeDialog()
            }
            .setNegativeButton("Zatvori", null)
            .show()
    }
    private fun showLayerControlDialog() {
        val layers = arrayOf(
            "??? Osnovna mapa",
            "?? Moja lokacija",
            "??? Trenutna ruta",
            "?? Saèuvane taèke"
        )

        val checkedItems = booleanArrayOf(true, true, true, true)

        AlertDialog.Builder(this)
            .setTitle("Upravljaj slojevima")
            .setMultiChoiceItems(layers, checkedItems) { dialog, which, isChecked ->
                when (which) {
                    0 -> toggleBaseMap(isChecked)
                    1 -> toggleMyLocation(isChecked)
                    2 -> toggleCurrentRoute(isChecked)
                    3 -> toggleSavedPoints(isChecked)
                }
            }
            .setPositiveButton("Saèuvaj", null)
            .show()
    }

    private fun toggleBaseMap(show: Boolean) {
        if (show) {
            binding.mapView.setTileSource(TileSourceFactory.MAPNIK)
        } else {
            // Ako je mapa iskljuèena, prikaži praznu mapu
            binding.mapView.setTileSource(TileSourceFactory.DEFAULT_TILE_SOURCE)
        }
        binding.mapView.invalidate()
    }

    private fun toggleMyLocation(show: Boolean) {
        if (show) {
            locationOverlay.enableMyLocation()
            locationOverlay.enableFollowLocation()
        } else {
            locationOverlay.disableMyLocation()
            locationOverlay.disableFollowLocation()
        }
        binding.mapView.invalidate()
    }

    private fun measureDistanceToPoint() {
        Toast.makeText(this, "Izaberite taèku na mapi za merenje rastojanja", Toast.LENGTH_LONG).show()

        // Privremeno omoguæi dodavanje taèki za merenje
        val originalPointMode = isPointMode
        isPointMode = true

        binding.mapView.overlays.add(object : org.osmdroid.views.overlay.Overlay() {
            override fun onSingleTapConfirmed(e: android.view.MotionEvent?, mapView: org.osmdroid.views.MapView?): Boolean {
                if (mapView != null && e != null) {
                    val tappedPoint = mapView.projection.fromPixels(e.x.toInt(), e.y.toInt()) as GeoPoint
                    val myLocation = locationOverlay.myLocation

                    if (myLocation != null) {
                        val distance = calculateDistance(
                            myLocation.latitude, myLocation.longitude,
                            tappedPoint.latitude, tappedPoint.longitude
                        )

                        AlertDialog.Builder(this@MainActivity)
                            .setTitle("Rastojanje do taèke")
                            .setMessage("Rastojanje od vaše lokacije do izabrane taèke: ${formatDistance(distance)}")
                            .setPositiveButton("U redu", null)
                            .show()
                    } else {
                        Toast.makeText(this@MainActivity, "Lokacija nije dostupna", Toast.LENGTH_SHORT).show()
                    }

                    // Ukloni overlay nakon korišæenja
                    binding.mapView.overlays.remove(this)
                    isPointMode = originalPointMode
                    return true
                }
                return false
            }
        })
    }


    private fun showTrackingStatistics() {
        if (savedRoutes.isEmpty()) {
            Toast.makeText(this, "Nema saèuvanih ruta za statistiku", Toast.LENGTH_SHORT).show()
            return
        }

        val totalRoutes = savedRoutes.size
        val totalDistance = savedRoutes.sumOf { it.distance }
        val totalDuration = savedRoutes.sumOf { it.duration } / 1000 / 60 // u minutima
        val longestRoute = savedRoutes.maxByOrNull { it.distance }
        val averageDistance = totalDistance / totalRoutes

        val stats = """
        ?? Statistika praæenja:
        
        ?? Ukupno ruta: $totalRoutes
        ??? Ukupna udaljenost: ${formatDistance(totalDistance)}
        ?? Ukupno vreme: ${totalDuration} minuta
        ?? Proseèna dužina: ${formatDistance(averageDistance)}
        
        ?? Najduža ruta: 
        ${longestRoute?.name ?: "N/A"}
        ${formatDistance(longestRoute?.distance ?: 0.0)}
        
        ?? Aktivno praæenje: ${if (isTracking) "DA" else "NE"}
    """.trimIndent()

        AlertDialog.Builder(this)
            .setTitle("Statistika praæenja")
            .setMessage(stats)
            .setPositiveButton("U redu", null)
            .show()
    }

    private fun toggleCurrentRoute(show: Boolean) {
        if (!show) {
            polylines.forEach { binding.mapView.overlays.remove(it) }
            polylines.clear()
        } else if (isTracking && routePoints.size >= 2) {
            drawRouteOnMap()
        }
        binding.mapView.invalidate()
    }

    private fun toggleSavedPoints(show: Boolean) {
        pointMarkers.values.forEach { marker ->
            binding.mapView.overlays.remove(marker)
        }

        if (show) {
            pointMarkers.values.forEach { marker ->
                binding.mapView.overlays.add(marker)
            }
        }
        binding.mapView.invalidate()
    }

    private fun setStandardMap() {
        // Koristi default OSM koji je najbrži
        binding.mapView.setTileSource(TileSourceFactory.MAPNIK)
        binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue)
        Toast.makeText(this, "Standardna mapa", Toast.LENGTH_SHORT).show()
        binding.mapView.invalidate()
    }

    private fun setMapTileSourceWithFallback(source: XYTileSource, fallback: org.osmdroid.tileprovider.tilesource.ITileSource = TileSourceFactory.MAPNIK) {
        try {
            binding.mapView.setTileSource(source)
            binding.mapView.invalidate()
        } catch (e: Exception) {
            // ISPRAVLJENA LINIJA: koristi name() umesto name
            Log.w("MainActivity", "Tile source ${source.name()} failed, using fallback")
            binding.mapView.setTileSource(fallback)
            binding.mapView.invalidate()
        }
    }
    private fun setMapTypeWithProgress(mapType: String, source: org.osmdroid.tileprovider.tilesource.ITileSource) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("Uèitavanje mape")
            .setMessage("Molimo saèekajte...")
            .setCancelable(false)
            .create()

        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                delay(500) // Daj vremena za prikaz progress dialoga

                withContext(Dispatchers.Main) {
                    binding.mapView.setTileSource(source)
                    binding.btnMapType.setBackgroundResource(R.drawable.button_dark_blue_accent)
                    Toast.makeText(this@MainActivity, mapType, Toast.LENGTH_SHORT).show()
                    binding.mapView.invalidate()
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@MainActivity, "Greška: ${e.message}", Toast.LENGTH_SHORT).show()
                    setStandardMap()
                }
            } finally {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                }
            }
        }
    }

    private fun zoomIn() {
        val currentZoom = binding.mapView.zoomLevelDouble
        val newZoom = currentZoom + 1.0

        if (newZoom <= binding.mapView.maxZoomLevel) {
            // ANIMIRANI ZOOM SA BOLJIM TIMING-OM
            binding.mapView.controller.animateTo(
                binding.mapView.mapCenter,
                newZoom,
                300L  // duže trajanje za glatkiji zoom
            )

            // PRIKAZI INFORMACIJU O ZOOM LEVEL-U
            showZoomInfo(newZoom)

            // OPTIMIZACIJA ZA VISOKI ZOOM
            if (newZoom > 18.0) {
                optimizeForHighZoom(newZoom)
            }
        } else {
            Toast.makeText(this, "?? Maksimalno uveæanje dostignuto!", Toast.LENGTH_SHORT).show()
        }
    }
    private fun zoomOut() {
        val currentZoom = binding.mapView.zoomLevelDouble
        val newZoom = currentZoom - 1.0

        if (newZoom >= binding.mapView.minZoomLevel) {
            binding.mapView.controller.animateTo(
                binding.mapView.mapCenter,
                newZoom,
                300L
            )
            showZoomInfo(newZoom)
        } else {
            Toast.makeText(this, "?? Minimalno uveæanje!", Toast.LENGTH_SHORT).show()
        }
    }

    private fun optimizeForHighZoom(zoom: Double) {
        if (zoom > 18.0) {
            // NA VISOKOM ZOOM-U: poveæaj cache i optimizuj
            Configuration.getInstance().cacheMapTileCount = 5000
            binding.mapView.setUseDataConnection(true)

            // FORSIRAJ REFRESH TILE-OVA
            binding.mapView.invalidate()
        }
    }
    private fun centerOnMyLocation() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            requestLocationPermissions()
            return
        }

        // POKUŠAJTE SA POSLEDNJOM POZNATOM LOKACIJOM PRVO
        fusedLocationClient.lastLocation
            .addOnSuccessListener { location: Location? ->
                location?.let {
                    if (it.accuracy < 50.0f) {
                        val currentLocation = GeoPoint(it.latitude, it.longitude)
                        binding.mapView.controller.animateTo(currentLocation)
                        binding.mapView.controller.setZoom(18.0)

                        // PRIKAŽI MARKER
                        showAccurateLocationMarker(currentLocation, it)

                        // OTVORI DIALOG AUTOMATSKI - OVO OSTAVLJAMO!
                        showMyLocationDetails() // OVO OSTAJE!

                        lastLocation = it
                        Log.d("Location", "Centriranje uspešno: ${it.accuracy}m")
                    } else {
                        // AKO NIJE TAÈNA, POKAŽI DIALOG SA UPOTREBOM
                        val currentLocation = GeoPoint(it.latitude, it.longitude)
                        binding.mapView.controller.animateTo(currentLocation)
                        binding.mapView.controller.setZoom(16.0)
                        showAccurateLocationMarker(currentLocation, it)
                        showMyLocationDetails() // OVO OSTAJE!
                    }
                } ?: run {
                    // AKO NEMA LOKACIJE, POKAŽI DIALOG
                    Toast.makeText(this, "?? Tražim lokaciju...", Toast.LENGTH_SHORT).show()
                    startQuickLocationUpdate()
                }
            }
            .addOnFailureListener { e ->
                Log.e("Location", "Greška pri dobijanju lokacije: ${e.message}")
                Toast.makeText(this, "?? Tražim lokaciju...", Toast.LENGTH_SHORT).show()
                startQuickLocationUpdate()
            }
    }
    private fun setupPointOfInterestMode() {
        binding.fabAddPoint.setOnClickListener {
            togglePointMode()
        }
    }
    private fun togglePointMode() {
        isPointMode = !isPointMode
        if (isPointMode) {
            binding.fabAddPoint.setBackgroundResource(R.drawable.button_dark_blue)
            Toast.makeText(this, "Režim dodavanja taèaka - klikni na mapu", Toast.LENGTH_SHORT).show()
        } else {
            binding.fabAddPoint.setBackgroundResource(R.drawable.button_dark_blue_accent)
            Toast.makeText(this, "Režim dodavanja taèaka iskljuèen", Toast.LENGTH_SHORT).show()
        }
    }
    private fun resetZoom() {
        try {
            val myLocation = locationOverlay.myLocation
            if (myLocation != null) {
                binding.mapView.controller.animateTo(myLocation, 16.0, 500L)
                Toast.makeText(this, "Zoom resetovan na lokaciju", Toast.LENGTH_SHORT).show()
            } else {
                val nis = GeoPoint(43.3209, 21.8958)
                binding.mapView.controller.animateTo(nis, 13.0, 500L)
                Toast.makeText(this, "Zoom resetovan na Niš", Toast.LENGTH_SHORT).show()
            }
        } catch (e: Exception) {
            Toast.makeText(this, "Greška pri resetovanju zooma", Toast.LENGTH_SHORT).show()
        }
    }
    private fun loadPointsOfInterest() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val points = app.pointRepository.getUserPoints(getCurrentUserId())

                runOnUiThread {
                    // 1. OÈISTI POSTOJEÆE TAÈKE
                    pointsOfInterest.clear()
                    pointsOfInterest.addAll(points)

                    // 2. UKLONI SVE POSTOJEÆE MARKERE
                    pointMarkers.values.forEach { marker ->
                        binding.mapView.overlays.remove(marker)
                    }
                    pointMarkers.clear()

                    // 3. DODAJ NOVE MARKERE
                    points.forEach { point ->
                        addMarkerToMap(
                            GeoPoint(point.latitude, point.longitude),
                            point.name,
                            point.id
                        )
                    }

                    // 4. OSVEŽI MAPU
                    binding.mapView.invalidate()

                    Log.d("PointsLoad", "? Uèitano ${points.size} taèaka")
                }
            } catch (e: Exception) {
                Log.e("PointsLoad", "? Greška pri uèitavanju taèaka: ${e.message}")
            }
        }
    }
    private fun loadSavedRoutes() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as jovannedeljkovic.gps_tracker_pro.App
                savedRoutes = app.routeRepository.getUserRoutes(getCurrentUserId()).toMutableList()
            } catch (e: Exception) {
                Log.d("MainActivity", "Nema saèuvanih ruta: ${e.message}")
            }
        }
    }
    private fun showUserInfoDialog() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val userEmail = getCurrentUserFromPrefs()
                val user = app.userRepository.getUserByEmail(userEmail)

                if (user != null) {
                    val benefits = FeatureManager.getRoleBenefits(user)
                    val benefitsText = benefits.joinToString("\n")

                    runOnUiThread {
                        AlertDialog.Builder(this@MainActivity)
                            .setTitle("?? Korisnièki nalog")
                            .setMessage(
                                """
                            Email: ${user.email}
                            Uloga: ${FeatureManager.getUserRoleDisplayName(user)}
                            
                            Dostupne funkcionalnosti:
                            $benefitsText
                            """.trimIndent()
                            )
                            .setPositiveButton("OK", null)
                            .show()
                    }
                }
            } catch (e: Exception) {
                Log.e("MainActivity", "Greška pri prikazu korisnièkih informacija: ${e.message}")
            }
        }
    }



    // NOTIFICATION METHODS
    private fun startTrackingNotification() {
        notificationHelper.showTrackingNotification(
            formatDistance(totalDistance),
            "${String.format("%.1f", currentSpeed)} km/h"
        )
    }

    private fun updateTrackingNotification() {
        notificationHelper.updateTrackingNotification(
            formatDistance(totalDistance),
            "${String.format("%.1f", currentSpeed)} km/h"
        )
    }

    private fun stopTrackingNotification() {
        notificationHelper.cancelTrackingNotification()
    }

    private fun toggleTrackingMode() {
        try {
            // Trenutni režimi: "self" (sopstveno praæenje), "other" (praæenje drugog ureðaja)
            trackingMode = if (trackingMode == "self") "other" else "self"

            when (trackingMode) {
                "self" -> {
                    binding.btnTrackingMode.text = " Pratim sebe"
                    binding.btnTrackingMode.setBackgroundResource(R.drawable.button_dark_blue)
                    Toast.makeText(this, "?? Režim: Praæenje sebe", Toast.LENGTH_SHORT).show()
                    Log.d("TrackingMode", "Prebaèen na režim praæenja sebe")
                }
                "other" -> {
                    binding.btnTrackingMode.text = "???? Pratim Drugog"
                    binding.btnTrackingMode.setBackgroundResource(R.drawable.button_dark_blue_accent)
                    Toast.makeText(this, "\uD83D\uDC64\uD83D\uDC64 Režim: Praæenje drugog ureðaja", Toast.LENGTH_SHORT).show()
                    Log.d("TrackingMode", "Prebaèen na režim praæenja drugog")
                }
            }

            // Ažuriraj UI prema režimu
            updateTrackingModeUI()

        } catch (e: Exception) {
            Log.e("TrackingMode", "Greška pri promeni režima: ${e.message}")
            Toast.makeText(this, "Greška pri promeni režima", Toast.LENGTH_SHORT).show()
        }
    }
    private fun updateTrackingModeUI() {
        when (trackingMode) {
            "self" -> {
                // Režim praæenja sebe - prikaži sve kontrole
                binding.btnStartTracking.visibility = View.VISIBLE
                binding.btnStopTracking.visibility = View.VISIBLE
                binding.trackingPanel.visibility = if (isTracking) View.VISIBLE else View.GONE
            }
            "other" -> {
                // Režim praæenja drugog - sakrij nepotrebne kontrole
                if (isTracking) {
                    stopTracking() // Zaustavi sopstveno praæenje ako je aktivno
                }
                binding.btnStartTracking.visibility = View.GONE
                binding.btnStopTracking.visibility = View.GONE
                binding.trackingPanel.visibility = View.GONE

                // OVDE MOŽETE DODATI LOGIKU ZA PRAÆENJE DRUGOG UREÐAJA
                //showOtherDeviceTrackingDialog()
            }
        }
    }
    private fun openGoogleMaps() {
        try {
            val location = locationOverlay.myLocation
            if (location != null) {
                val uri = "geo:${location.latitude},${location.longitude}?q=${location.latitude},${location.longitude}"
                val intent = Intent(Intent.ACTION_VIEW, Uri.parse(uri))
                intent.setPackage("com.google.android.apps.maps")
                if (intent.resolveActivity(packageManager) != null) {
                    startActivity(intent)
                } else {
                    val webUri = "https://www.google.com/maps/search/?api=1&query=${location.latitude},${location.longitude}"
                    val webIntent = Intent(Intent.ACTION_VIEW, Uri.parse(webUri))
                    startActivity(webIntent)
                }
            } else {
                Toast.makeText(this, "Lokacija nije dostupna", Toast.LENGTH_SHORT).show()
            }
        } catch (e: Exception) {
            Toast.makeText(this, "Greška pri otvaranju mapa: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }

    private fun showToolsDialog() {
        val tools = arrayOf(
            "??? OSM Preview Stilovi",
            "?? Upravljaj taèkama",
            "?? Eksport podataka",
            "?? Uvezi podatke",
            "?? Kompas On/Off",
            "?? Izmeri rastojanje",
            "?? Statistika praæenja",
            "?? Reset zoom",
            "?? Auto-rotate mapa"
        )

        AlertDialog.Builder(this)
            .setTitle("??? Alatke za Mapu")
            .setItems(tools) { dialog, which ->
                when (which) {
                    0 -> showOsmPreview()
                    1 -> showPointsManagementDialog()
                    2 -> exportRouteData()
                    3 -> showImportOptions()
                    4 -> toggleCompass()
                    5 -> measureDistanceToPoint()
                    6 -> showTrackingStatistics()
                    7 -> resetZoom()
                    8 -> toggleMapRotation()
                }
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }
    private fun showImportOptions() {
        val importOptions = arrayOf(
            "??? Uvezi rutu (GPX) - File Picker",
            "?? Uvezi taèke (GPX)",
            "?? Uvezi taèke (CSV)",
            "?? Uvezi sve iz backup-a",
            "?? Pomoc pri uvozu"
        )

        AlertDialog.Builder(this)
            .setTitle("?? Uvoz podataka")
            .setItems(importOptions) { dialog, which ->
                when (which) {
                    0 -> importRouteFromFile()           // File Picker za rute
                    1 -> importPointsFromGpx()           // GPX za taèke
                    2 -> importPointsFromFile()          // CSV za taèke
                    3 -> importFromBackup()              // Backup
                    4 -> showImportHelpDialog()          // Pomoc
                }
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }
    private fun importPointsFromGpx() {
        try {
            val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
                addCategory(Intent.CATEGORY_OPENABLE)
                type = "*/*"
                putExtra(Intent.EXTRA_MIME_TYPES, arrayOf(
                    "application/gpx+xml",
                    "application/xml",
                    "text/xml"
                ))
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }

            startActivityForResult(intent, IMPORT_GPX_POINTS_REQUEST_CODE)
            Toast.makeText(this, "?? Izaberite GPX fajl sa taèkama", Toast.LENGTH_SHORT).show()

        } catch (e: Exception) {
            Log.e("Import", "Greška pri otvaranju file pickera: ${e.message}")
            Toast.makeText(this, "? Greška: ${e.message}", Toast.LENGTH_SHORT).show()

            // FALLBACK: Pokaži opciju za Download folder
            showImportFallbackForPoints()
        }
    }

    private fun importFromBackup() {
        Log.d("ImportDebug", "?? POZIVAM importFromBackup()")
        try {
            val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
                addCategory(Intent.CATEGORY_OPENABLE)
                type = "*/*"
                putExtra(Intent.EXTRA_MIME_TYPES, arrayOf(
                    "application/zip",
                    "application/json"
                ))
            }

            startActivityForResult(intent, IMPORT_BACKUP_REQUEST_CODE)
            Toast.makeText(this, "?? Izaberite backup fajl", Toast.LENGTH_SHORT).show()
        } catch (e: Exception) {
            Toast.makeText(this, "? Greška: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }
    private fun importPointsFromFile() {
        try {
            val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
                addCategory(Intent.CATEGORY_OPENABLE)
                type = "*/*"
                putExtra(Intent.EXTRA_MIME_TYPES, arrayOf(
                    "text/csv",
                    "text/comma-separated-values",
                    "text/plain"
                ))
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }

            startActivityForResult(intent, IMPORT_CSV_REQUEST_CODE)
            Toast.makeText(this, "?? Izaberite CSV fajl sa taèkama", Toast.LENGTH_SHORT).show()

        } catch (e: Exception) {
            Log.e("Import", "Greška pri otvaranju file pickera: ${e.message}")
            Toast.makeText(this, "? Greška: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }
    private fun showPointsManagementDialog() {
        // DODAJ OVO: OSVEŽI PODATKE PRE PRIKAZA
        loadPointsOfInterest()

        if (pointsOfInterest.isEmpty()) {
            Toast.makeText(this, "?? Nema taèaka za upravljanje", Toast.LENGTH_SHORT).show()
            return
        }
        if (pointsOfInterest.isEmpty()) {
            Toast.makeText(this, "Nema taèaka za upravljanje", Toast.LENGTH_SHORT).show()
            return
        }

        val pointNames = pointsOfInterest.map {
            "${it.name}\n   ?? ${SimpleDateFormat("dd.MM. HH:mm", Locale.getDefault()).format(Date(it.createdAt))}"
        }.toTypedArray()

        val selectedPoints = BooleanArray(pointsOfInterest.size) { false }

        AlertDialog.Builder(this)
            .setTitle("Upravljanje taèkama (${pointsOfInterest.size})")
            .setMultiChoiceItems(pointNames, selectedPoints) { dialog, which, isChecked ->
                selectedPoints[which] = isChecked
            }
            .setPositiveButton("??? Obriši selektovane") { dialog, which ->
                val pointsToDelete = pointsOfInterest.filterIndexed { index, _ ->
                    selectedPoints[index]
                }
                if (pointsToDelete.isNotEmpty()) {
                    showBulkDeleteConfirmation(pointsToDelete)
                } else {
                    Toast.makeText(this, "Nijedna taèka nije selektovana", Toast.LENGTH_SHORT).show()
                }
            }
            .setNeutralButton("??? Pregledaj sve") { dialog, which ->
                showAllPointsPreview()
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }
    private fun showBulkDeleteConfirmation(pointsToDelete: List<PointOfInterest>) {
        val pointsList = pointsToDelete.joinToString("\n") { "?? ${it.name}" }
        AlertDialog.Builder(this)
            .setTitle("Brisanje taèaka")
            .setMessage("Da li ste sigurni da želite da obrišete ${pointsToDelete.size} taèku/a?\n\n$pointsList")
            .setPositiveButton("? Obriši sve") { dialog, which ->
                deleteMultiplePoints(pointsToDelete)
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun deleteMultiplePoints(pointsToDelete: List<PointOfInterest>) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as jovannedeljkovic.gps_tracker_pro.App
                pointsToDelete.forEach { point ->
                    app.pointRepository.deletePoint(point)
                }
                runOnUiThread {
                    pointsToDelete.forEach { point ->
                        pointMarkers[point.id]?.let { marker ->
                            binding.mapView.overlays.remove(marker)
                            pointMarkers.remove(point.id)
                        }
                        pointsOfInterest.remove(point)
                    }
                    binding.mapView.invalidate()
                    Toast.makeText(this@MainActivity, "Obrisano ${pointsToDelete.size} taèaka", Toast.LENGTH_LONG).show()
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Greška pri brisanju: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    private fun showAllPointsPreview() {
        val pointsInfo = pointsOfInterest.joinToString("\n\n") { point ->
            val distance = calculateDistanceToPoint(point)
            "?? ${point.name}\n" +
                    "   ?? ${formatDistance(distance)} od vas\n" +
                    "   ?? ${SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault()).format(Date(point.createdAt))}\n" +
                    "   ?? ${String.format("%.6f", point.latitude)}, ${String.format("%.6f", point.longitude)}"
        }

        AlertDialog.Builder(this)
            .setTitle("Sve taèke (${pointsOfInterest.size})")
            .setMessage(pointsInfo.takeIf { it.isNotBlank() } ?: "Nema taèaka")
            .setPositiveButton("? U redu", null)
            .show()
    }

    private fun calculateDistanceToPoint(point: PointOfInterest): Double {
        val myLocation = locationOverlay.myLocation ?: return 0.0
        return calculateDistance(
            myLocation.latitude,
            myLocation.longitude,
            point.latitude,
            point.longitude
        )
    }

    private fun calculateDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val earthRadius = 6371000.0
        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)
        val a = sin(dLat / 2) * sin(dLat / 2) +
                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *
                sin(dLon / 2) * sin(dLon / 2)
        val c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return earthRadius * c
    }

    private fun showSavedRoutes() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as jovannedeljkovic.gps_tracker_pro.App
                savedRoutes = app.routeRepository.getUserRoutes(getCurrentUserId()).toMutableList()
                runOnUiThread {
                    if (savedRoutes.isEmpty()) {
                        Toast.makeText(this@MainActivity, "Nema saèuvanih ruta", Toast.LENGTH_SHORT).show()
                    } else {
                        showAdvancedRoutesDialog()
                    }
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Greška pri uèitavanju ruta", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun showAdvancedRoutesDialog() {
        val routesInfo = savedRoutes.joinToString("\n\n") { route ->
            val duration = route.duration / 1000
            val minutes = duration / 60
            val seconds = duration % 60
            "??? ${route.name}\n" +
                    "?? ${formatDistance(route.distance)}\n" +
                    "?? ${minutes}m ${seconds}s\n" +
                    "?? ${SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault()).format(Date(route.startTime))}"
        }

        AlertDialog.Builder(this)
            .setTitle("??? Saèuvane rute (${savedRoutes.size})")
            .setMessage(routesInfo)
            .setPositiveButton("?? Prikaži sve") { dialog, which ->
                showRoutesManagementDialog()
            }
            .setNeutralButton("?? Najduža ruta") { dialog, which ->
                showLongestRoute()
            }
            // DODAJ OVO NOVO DUGME ZA EKSPORT
            .setNegativeButton("?? Eksport") { dialog, which ->
                showExportRoutesOptions()
            }
            .show()
    }
    private fun showExportRoutesOptions() {
        if (savedRoutes.isEmpty()) {
            Toast.makeText(this, "? Nema ruta za eksport", Toast.LENGTH_SHORT).show()
            return
        }

        val exportOptions = arrayOf(
            "??? Izvezi pojedinaène rute (GPX)",
            "??? Izvezi pojedinaène rute (CSV)",
            "?? Izvezi sve rute (GPX)",
            "?? Izvezi sve rute (CSV)",
            "? Otkaži"
        )

        AlertDialog.Builder(this)
            .setTitle("?? Eksport ruta")
            .setItems(exportOptions) { dialog, which ->
                when (which) {
                    0 -> showRouteSelectionForExport("GPX")  // Pojedinaène GPX
                    1 -> showRouteSelectionForExport("CSV")  // Pojedinaène CSV
                    2 -> exportAllRoutes("GPX")             // Sve GPX
                    3 -> exportAllRoutes("CSV")             // Sve CSV
                    // 4 -> Otkaži (ne radi ništa)
                }
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }
    private fun showRouteSelectionForExport(format: String) {
        if (savedRoutes.isEmpty()) {
            Toast.makeText(this, "? Nema ruta za eksport", Toast.LENGTH_SHORT).show()
            return
        }

        val routeNames = savedRoutes.map { route ->
            val duration = route.duration / 1000 / 60
            "${route.name}\n   ?? ${formatDistance(route.distance)} • ?? ${duration}min • ?? ${formatDate(route.startTime)}"
        }.toTypedArray()

        val selectedRoutes = BooleanArray(savedRoutes.size) { false }

        AlertDialog.Builder(this)
            .setTitle("?? Izaberite rute za eksport ($format)")
            .setMultiChoiceItems(routeNames, selectedRoutes) { dialog, which, isChecked ->
                selectedRoutes[which] = isChecked
            }
            .setPositiveButton("?? Eksportuj selektovane") { dialog, which ->
                val routesToExport = savedRoutes.filterIndexed { index, _ ->
                    selectedRoutes[index]
                }

                if (routesToExport.isNotEmpty()) {
                    when (format) {
                        "GPX" -> exportSelectedRoutesAsGpx(routesToExport)
                        "CSV" -> exportSelectedRoutesAsCsv(routesToExport)
                    }
                } else {
                    Toast.makeText(this, "?? Nijedna ruta nije selektovana", Toast.LENGTH_SHORT).show()
                }
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun exportSelectedRoutesAsGpx(routes: List<Route>) {
        if (!checkStoragePermissionsForExport()) {
            Toast.makeText(this, "?? Potrebne su dozvole za pristup skladištu", Toast.LENGTH_LONG).show()
            requestStoragePermissions()
            return
        }

        val progressDialog = AlertDialog.Builder(this)
            .setTitle("??? Eksport ruta u GPX...")
            .setMessage("Pripremam ${routes.size} rutu/a...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val allPoints = mutableListOf<LocationPoint>()

                routes.forEach { route ->
                    val points = app.routeRepository.getRoutePoints(route.id)
                    allPoints.addAll(points)
                }

                if (allPoints.isEmpty()) {
                    runOnUiThread {
                        progressDialog.dismiss()
                        Toast.makeText(this@MainActivity, "? Nema podataka za eksport", Toast.LENGTH_SHORT).show()
                    }
                    return@launch
                }

                val gpxContent = generateMultipleRoutesGPX(routes, allPoints)
                val fileName = if (routes.size == 1) {
                    "ruta_${routes.first().name.replace(" ", "_")}_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.gpx"
                } else {
                    "multiple_routes_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.gpx"
                }

                // KLJUÈNA PROMENA: Koristi Download folder
                val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                val gpxFile = File(downloadsDir, fileName)

                FileWriter(gpxFile).use { writer ->
                    writer.write(gpxContent)
                }

                runOnUiThread {
                    progressDialog.dismiss()

                    if (gpxFile.exists()) {
                        val fileSize = String.format("%.1f", gpxFile.length() / 1024.0)
                        Toast.makeText(
                            this@MainActivity,
                            "? ${routes.size} ruta uspešno izveženo u GPX!\n?? Download/${fileName}\n?? ${fileSize}KB",
                            Toast.LENGTH_LONG
                        ).show()
                        Log.d("ExportDebug", "?? Multiple ruta saèuvana u: ${gpxFile.absolutePath}")
                    } else {
                        Toast.makeText(this@MainActivity, "? Greška pri èuvanju fajla", Toast.LENGTH_SHORT).show()
                    }
                }

            } catch (e: Exception) {
                runOnUiThread {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška pri GPX eksportu: ${e.message}", Toast.LENGTH_LONG).show()
                    Log.e("ExportDebug", "?? Greška pri multiple export: ${e.message}")
                }
            }
        }
    }

    private fun exportSelectedRoutesAsCsv(routes: List<Route>) {
        if (!checkStoragePermissionsForExport()) {
            Toast.makeText(this, "?? Potrebne su dozvole za pristup skladištu", Toast.LENGTH_LONG).show()
            requestStoragePermissions()
            return
        }

        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Eksport ruta u CSV...")
            .setMessage("Pripremam ${routes.size} rutu/a...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val fileName = if (routes.size == 1) {
                    "ruta_${routes.first().name.replace(" ", "_")}_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.csv"
                } else {
                    "multiple_routes_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.csv"
                }

                // KLJUÈNA PROMENA: Koristi Download folder
                val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                val csvFile = File(downloadsDir, fileName)

                FileWriter(csvFile).use { writer ->
                    writer.append("Ruta,Vreme,Širina,Dužina,Taènost\n")

                    routes.forEach { route ->
                        val points = app.routeRepository.getRoutePoints(route.id)
                        points.forEach { point ->
                            val time = SimpleDateFormat("dd.MM.yyyy HH:mm:ss", Locale.getDefault()).format(Date(point.timestamp))
                            writer.append("${route.name},$time,${point.latitude},${point.longitude},${point.accuracy}\n")
                        }
                    }
                }

                runOnUiThread {
                    progressDialog.dismiss()

                    if (csvFile.exists()) {
                        val fileSize = String.format("%.1f", csvFile.length() / 1024.0)
                        Toast.makeText(
                            this@MainActivity,
                            "? ${routes.size} ruta uspešno izveženo u CSV!\n?? Download/${fileName}\n?? ${fileSize}KB",
                            Toast.LENGTH_LONG
                        ).show()
                        Log.d("ExportDebug", "?? Multiple CSV ruta saèuvana u: ${csvFile.absolutePath}")
                    } else {
                        Toast.makeText(this@MainActivity, "? Greška pri èuvanju CSV fajla", Toast.LENGTH_SHORT).show()
                    }
                }

            } catch (e: Exception) {
                runOnUiThread {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška pri CSV eksportu: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    private fun debugExportPath() {
        val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
        Log.d("ExportDebug", "?? Download folder path: ${downloadsDir.absolutePath}")
        Log.d("ExportDebug", "?? Download folder exists: ${downloadsDir.exists()}")
        Log.d("ExportDebug", "?? Download folder canWrite: ${downloadsDir.canWrite()}")

        // Proba da kreira test fajl
        val testFile = File(downloadsDir, "test_export.txt")
        try {
            testFile.writeText("Test export - ${Date()}")
            Log.d("ExportDebug", "? Test file created: ${testFile.exists()}")
            testFile.delete()
        } catch (e: Exception) {
            Log.e("ExportDebug", "? Test file failed: ${e.message}")
        }
    }
    private fun exportAllRoutes(format: String) {
        if (savedRoutes.isEmpty()) {
            Toast.makeText(this, "? Nema ruta za eksport", Toast.LENGTH_SHORT).show()
            return
        }

        AlertDialog.Builder(this)
            .setTitle("?? Eksport svih ruta")
            .setMessage("Da li želite da izvezete SVIH ${savedRoutes.size} rutu/a u $format format?")
            .setPositiveButton("? Da, eksportuj sve") { dialog, which ->
                when (format) {
                    "GPX" -> exportSelectedRoutesAsGpx(savedRoutes)
                    "CSV" -> exportSelectedRoutesAsCsv(savedRoutes)
                }
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }
    private fun generateMultipleRoutesGPX(routes: List<Route>, allPoints: List<LocationPoint>): String {
        val builder = StringBuilder()

        builder.append("""<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPS Tracker DS" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>Multiple Routes Export</name>
    <time>${SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.getDefault()).format(Date())}</time>
  </metadata>
""")

        // DODAJ SVAKU RUTU KAO POSEBNI TRK
        routes.forEach { route ->
            val routePoints = allPoints.filter { it.routeId == route.id }

            if (routePoints.isNotEmpty()) {
                builder.append("""
  <trk>
    <name>${escapeXml(route.name)}</name>
    <desc>Udaljenost: ${formatDistance(route.distance)}, Vreme: ${route.duration / 1000 / 60} minuta</desc>
    <trkseg>
""")

                routePoints.forEach { point ->
                    val time = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.getDefault()).format(Date(point.timestamp))
                    builder.append("""      <trkpt lat="${point.latitude}" lon="${point.longitude}">
        <time>$time</time>
        <ele>0</ele>
      </trkpt>
""")
                }

                builder.append("""    </trkseg>
  </trk>
""")
            }
        }

        builder.append("</gpx>")
        return builder.toString()
    }

    private fun showRoutesManagementDialog() {
        val options = arrayOf(
            "?? Pregled svih ruta",
            "??? Brisanje selektovanih ruta",
            "?? Brisanje svih ruta",
            "? Zatvori"
        )

        AlertDialog.Builder(this)
            .setTitle("?? Upravljanje rutama (${savedRoutes.size})")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> showAllRoutesPreview()
                    1 -> showMultiSelectRoutesDialog()
                    2 -> deleteAllRoutesConfirmation()
                }
            }
            .show()
    }

    private fun showAllRoutesPreview() {
        if (savedRoutes.isEmpty()) {
            Toast.makeText(this, "? Nema saèuvanih ruta", Toast.LENGTH_SHORT).show()
            return
        }

        val routeNames = savedRoutes.sortedByDescending { it.startTime }
            .map { route ->
                val duration = route.duration / 1000
                val minutes = duration / 60
                val seconds = duration % 60
                "${route.name}\n?? ${formatDistance(route.distance)} • ?? ${minutes}m ${seconds}s • ?? ${formatDate(route.startTime)}"
            }
            .toTypedArray()

        AlertDialog.Builder(this)
            .setTitle("??? Sve rute (${savedRoutes.size})")
            .setItems(routeNames) { dialog, which ->
                val selectedRoute = savedRoutes.sortedByDescending { it.startTime }[which]
                showAdvancedRouteOptions(selectedRoute)
            }
            .setPositiveButton("? U redu", null)
            .setNeutralButton("?? Upravljaj rutama") { dialog, which ->
                showRoutesManagementDialog()
            }
            .show()
    }

    private fun showMultiSelectRoutesDialog() {
        if (savedRoutes.isEmpty()) {
            Toast.makeText(this, "? Nema ruta za brisanje", Toast.LENGTH_SHORT).show()
            return
        }

        val routeNames = savedRoutes.map {
            "${it.name}\n   ?? ${formatDate(it.startTime)} - ?? ${formatDistance(it.distance)}"
        }.toTypedArray()

        val selectedRoutes = BooleanArray(savedRoutes.size) { false }

        AlertDialog.Builder(this)
            .setTitle("?? Selektuj rute za brisanje")
            .setMultiChoiceItems(routeNames, selectedRoutes) { dialog, which, isChecked ->
                selectedRoutes[which] = isChecked
            }
            .setPositiveButton("??? Obriši selektovane") { dialog, which ->
                val routesToDelete = savedRoutes.filterIndexed { index, _ ->
                    selectedRoutes[index]
                }
                if (routesToDelete.isNotEmpty()) {
                    showBulkRoutesDeleteConfirmation(routesToDelete)
                } else {
                    Toast.makeText(this, "?? Nijedna ruta nije selektovana", Toast.LENGTH_SHORT).show()
                }
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun showBulkRoutesDeleteConfirmation(routesToDelete: List<Route>) {
        val routesList = routesToDelete.joinToString("\n") {
            " • ${it.name} (?? ${formatDistance(it.distance)})"
        }
        val totalDistance = routesToDelete.sumOf { it.distance }

        AlertDialog.Builder(this)
            .setTitle("??? Brisanje ruta")
            .setMessage(
                "?? Da li ste sigurni da želite da obrišete ${routesToDelete.size} rutu/a?\n\n" +
                        "?? Ukupna udaljenost: ${formatDistance(totalDistance)}\n\n" +
                        "??? Rute za brisanje:\n$routesList"
            )
            .setPositiveButton("? Obriši sve") { dialog, which ->
                deleteMultipleRoutes(routesToDelete)
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun deleteMultipleRoutes(routesToDelete: List<Route>) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as jovannedeljkovic.gps_tracker_pro.App
                routesToDelete.forEach { route ->
                    app.routeRepository.deleteRoute(route)
                }
                runOnUiThread {
                    savedRoutes.removeAll(routesToDelete.toSet())
                    polylines.clear()
                    binding.mapView.overlays.removeAll(polylines)
                    binding.mapView.invalidate()
                    Toast.makeText(
                        this@MainActivity,
                        "Uspešno obrisano ${routesToDelete.size} ruta",
                        Toast.LENGTH_LONG
                    ).show()
                    notificationHelper.showBulkDeleteSuccess(routesToDelete.size)
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(
                        this@MainActivity,
                        "Greška pri brisanju: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }

    private fun deleteAllRoutesConfirmation() {
        if (savedRoutes.isEmpty()) {
            Toast.makeText(this, "? Nema ruta za brisanje", Toast.LENGTH_SHORT).show()
            return
        }

        val totalDistance = savedRoutes.sumOf { it.distance }
        val totalDuration = savedRoutes.sumOf { it.duration } / 1000 / 60

        AlertDialog.Builder(this)
            .setTitle("?? Brisanje svih ruta")
            .setMessage(
                "?? PAŽNJA: Ovo æe obrisati SVE vaše rute!\n\n" +
                        "?? Ukupno: ${savedRoutes.size} ruta\n" +
                        "?? Ukupna udaljenost: ${formatDistance(totalDistance)}\n" +
                        "?? Ukupno vreme: ${totalDuration} minuta\n\n" +
                        "?? Ova akcija se NE MOŽE poništiti!"
            )
            .setPositiveButton("?? OBRISI SVE") { dialog, which ->
                deleteAllRoutes()
            }
            .setNegativeButton("? Otkaži", null)
            .setIcon(android.R.drawable.ic_dialog_alert)
            .show()
    }

    private fun deleteAllRoutes() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as jovannedeljkovic.gps_tracker_pro.App
                val routesToDelete = savedRoutes.toList()
                routesToDelete.forEach { route ->
                    app.routeRepository.deleteRoute(route)
                }
                runOnUiThread {
                    polylines.clear()
                    binding.mapView.overlays.removeAll(polylines)
                    binding.mapView.invalidate()
                    savedRoutes.clear()
                    Toast.makeText(
                        this@MainActivity,
                        "Sve rute su obrisane (${routesToDelete.size})",
                        Toast.LENGTH_LONG
                    ).show()
                    notificationHelper.showAllRoutesDeleted(routesToDelete.size)
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(
                        this@MainActivity,
                        "Greška pri brisanju: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }

    private fun showAdvancedRouteOptions(route: Route) {
        Toast.makeText(this, "?? Otvaranje opcija za: ${route.name}", Toast.LENGTH_SHORT).show()
        val options = arrayOf(
            "?? Prikaži statistiku",
            "??? Prikaži na mapi",
            "?? Podeli rutu",
            "?? Preimenuj",
            "??? Obriši"
        )

        AlertDialog.Builder(this)
            .setTitle("?? ${route.name}")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> showRouteStatistics(route)
                    1 -> displayRouteOnMap(route)
                    2 -> shareRoute(route)
                    3 -> renameRoute(route)
                    4 -> deleteRoute(route)
                }
            }
            .show()
    }

    private fun renameRoute(route: Route) {
        val editText = EditText(this).apply {
            setText(route.name)
            hint = "Unesite novo ime rute"
            setSelectAllOnFocus(true)
        }

        AlertDialog.Builder(this)
            .setTitle("Preimenuj rutu")
            .setMessage("Trenutno ime: ${route.name}")
            .setView(editText)
            .setPositiveButton("Saèuvaj") { dialog, _ ->
                val newName = editText.text.toString().trim()
                if (newName.isBlank()) {
                    Toast.makeText(this, "Ime ne može biti prazno!", Toast.LENGTH_SHORT).show()
                    return@setPositiveButton
                }
                if (newName == route.name) {
                    Toast.makeText(this, "Ime nije promenjeno", Toast.LENGTH_SHORT).show()
                    return@setPositiveButton
                }
                updateRouteName(route, newName)
            }
            .setNegativeButton("Otkaži", null)
            .show()
    }

    private fun updateRouteName(route: Route, newName: String) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as jovannedeljkovic.gps_tracker_pro.App
                val updatedRoute = route.copy(name = newName)
                app.routeRepository.updateRoute(updatedRoute)
                runOnUiThread {
                    val index = savedRoutes.indexOfFirst { it.id == route.id }
                    if (index != -1) {
                        savedRoutes[index] = updatedRoute
                    }
                    Toast.makeText(
                        this@MainActivity,
                        "Ruta '${route.name}' preimenovana u '$newName'",
                        Toast.LENGTH_LONG
                    ).show()
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(
                        this@MainActivity,
                        "Greška pri preimenovanju: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }

    private fun showRouteStatistics(route: Route) {
        val duration = route.duration / 1000
        val minutes = duration / 60
        val seconds = duration % 60
        val avgSpeed = if (duration > 0) (route.distance / duration * 3.6) else 0.0

        val stats = """
        ?? Statistika rute:
        
        ?? Udaljenost: ${formatDistance(route.distance)}
        ?? Vreme: ${minutes}m ${seconds}s
        ?? Proseèna brzina: ${String.format("%.1f", avgSpeed)} km/h
        ?? Datum: ${formatDate(route.startTime)}
        
        ${if (route.isCompleted) "? Završena" else "?? U toku"}
    """.trimIndent()

        AlertDialog.Builder(this)
            .setTitle("?? Statistika: ${route.name}")
            .setMessage(stats)
            .setPositiveButton("? U redu", null)
            .show()
    }

    private fun showLongestRoute() {
        val longestRoute = savedRoutes.maxByOrNull { it.distance }
        longestRoute?.let { route ->
            Toast.makeText(this, "?? Najduža ruta: ${route.name} (?? ${formatDistance(route.distance)})", Toast.LENGTH_LONG).show()
            displayRouteOnMap(route)
        }
    }

    private fun shareRoute(route: Route) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as jovannedeljkovic.gps_tracker_pro.App
                val points = app.routeRepository.getRoutePoints(route.id)
                val routeInfo = """
                ??? Ruta: ${route.name}
                
                ?? Udaljenost: ${formatDistance(route.distance)}
                ?? Vreme: ${route.duration / 1000 / 60} minuta
                ?? Datum: ${formatDate(route.startTime)}
                
                Taèke rute (${points.size}):
                ${points.joinToString("\n") { point ->
                    "${point.latitude}, ${point.longitude}"
                }}
                
                Deljeno iz GPS Tracker aplikacije
            """.trimIndent()

                runOnUiThread {
                    val intent = Intent(Intent.ACTION_SEND).apply {
                        type = "text/plain"
                        putExtra(Intent.EXTRA_TEXT, routeInfo)
                        putExtra(Intent.EXTRA_SUBJECT, "Ruta: ${route.name}")
                    }
                    startActivity(Intent.createChooser(intent, "Podeli rutu"))
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Greška pri deljenju rute", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun displayRouteOnMap(route: Route) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as jovannedeljkovic.gps_tracker_pro.App
                val points = app.routeRepository.getRoutePoints(route.id)
                runOnUiThread {
                    val geoPoints = points.map { GeoPoint(it.latitude, it.longitude) }
                    polylines.forEach { binding.mapView.overlays.remove(it) }
                    polylines.clear()
                    if (geoPoints.size >= 2) {
                        val polyline = Polyline().apply {
                            setPoints(geoPoints)
                            color = Color.parseColor("#FFFF9800")
                            width = 8.0f
                        }
                        binding.mapView.overlays.add(polyline)
                        polylines.add(polyline)
                        binding.mapView.controller.animateTo(geoPoints.first())
                        binding.mapView.controller.setZoom(13.0)
                    }
                    binding.mapView.invalidate()
                    Toast.makeText(this@MainActivity, "Ruta '${route.name}' prikazana na mapi", Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Greška pri prikazu rute: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun deleteRoute(route: Route) {
        AlertDialog.Builder(this)
            .setTitle("Brisanje rute")
            .setMessage("Da li ste sigurni da želite da obrišete rutu '${route.name}'?")
            .setPositiveButton("Obriši") { dialog, which ->
                lifecycleScope.launch(Dispatchers.IO) {
                    try {
                        val app = application as jovannedeljkovic.gps_tracker_pro.App
                        app.routeRepository.deleteRoute(route)
                        runOnUiThread {
                            savedRoutes.remove(route)
                            Toast.makeText(this@MainActivity, "Ruta '${route.name}' obrisana", Toast.LENGTH_SHORT).show()
                        }
                    } catch (e: Exception) {
                        runOnUiThread {
                            Toast.makeText(this@MainActivity, "Greška pri brisanju: ${e.message}", Toast.LENGTH_SHORT).show()
                        }
                    }
                }
            }
            .setNegativeButton("Otkaži", null)
            .show()
    }

    private fun resetCurrentRoute() {
        val options = arrayOf(
            "?? Resetuj tekuæu rutu (snimanje)",
            "??? Obriši prikazane rute sa mape",  // ?? NOVA OPCIJA
            "?? Obriši SVE rute iz baze",
            "? Otkaži"
        )

        AlertDialog.Builder(this)
            .setTitle("?? Resetovanje ruta")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> performRouteReset()  // Reset tekuæe rute
                    1 -> showRouteDeletionOptions()  // Brisanje prikazanih ruta
                    2 -> deleteAllRoutesConfirmation()  // Brisanje svih ruta iz baze
                    // 3 -> Otkaži
                }
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }
    private fun performRouteReset() {
        currentRoute = null
        routePoints.clear()
        totalDistance = 0.0
        lastLocation = null
        polylines.forEach { binding.mapView.overlays.remove(it) }
        polylines.clear()
        binding.mapView.invalidate()
        updateTrackingStats(0.0, 0.0)

        Toast.makeText(this, "? Ruta resetovana!", Toast.LENGTH_SHORT).show()
        Log.d("RouteReset", "Ruta uspešno resetovana")
    }

    private fun exportRouteData() {
        val options = arrayOf(
            "??? Izvezi tekuæu rutu (GPX/CSV)",
            "??? Izvezi saèuvane rute (GPX/CSV)",  // ?? NOVA OPCIJA
            "?? Izvezi taèke u GPX",
            "?? Izvezi taèke u CSV",
            "?? Izvezi statistiku",
            "? Otkaži"
        )

        AlertDialog.Builder(this)
            .setTitle("?? Izvoz podataka")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> showCurrentRouteExportOptions()     // Tekuæa ruta
                    1 -> showSavedRoutesExportOptions()      // Saèuvane rute ?? NOVO
                    2 -> exportPointsToGPX()                 // Taèke GPX
                    3 -> exportPointsToCSV()                 // Taèke CSV
                    4 -> exportStatistics()                  // Statistika ?? NOVO
                    // 5 -> Otkaži
                }
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }
    private fun showCurrentRouteExportOptions() {
        if (currentRoute == null && !isTracking) {
            Toast.makeText(this, "? Nema aktivne rute za eksport", Toast.LENGTH_SHORT).show()
            return
        }

        val options = arrayOf(
            "??? GPX format (za druge aplikacije)",
            "?? CSV format (za Excel analizu)",
            "? Otkaži"
        )

        AlertDialog.Builder(this)
            .setTitle("?? Izvoz tekuæe rute")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> exportRouteToGPX()  // GPX
                    1 -> exportRouteToCSV()  // CSV
                    // 2 -> Otkaži
                }
            }
            .setNegativeButton("? Nazad", null)
            .show()
    }
    private fun showSavedRoutesExportOptions() {
        if (savedRoutes.isEmpty()) {
            Toast.makeText(this, "? Nema saèuvanih ruta", Toast.LENGTH_SHORT).show()
            showSavedRoutes() // Otvori dijalog za pregled ruta
            return
        }

        val options = arrayOf(
            "??? Izvezi pojedinaène rute (GPX)",
            "??? Izvezi pojedinaène rute (CSV)",
            "?? Izvezi sve rute (GPX)",
            "?? Izvezi sve rute (CSV)",
            "?? Pregled svih ruta",
            "? Otkaži"
        )

        AlertDialog.Builder(this)
            .setTitle("?? Izvoz saèuvanih ruta (${savedRoutes.size})")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> showRouteSelectionForExport("GPX")  // Pojedinaène GPX
                    1 -> showRouteSelectionForExport("CSV")  // Pojedinaène CSV
                    2 -> exportAllRoutes("GPX")             // Sve GPX
                    3 -> exportAllRoutes("CSV")             // Sve CSV
                    4 -> showAllRoutesPreview()             // Pregled ruta
                    // 5 -> Otkaži
                }
            }
            .setNegativeButton("? Nazad", null)
            .show()
    }
    private fun exportStatistics() {
        if (savedRoutes.isEmpty() && pointsOfInterest.isEmpty()) {
            Toast.makeText(this, "? Nema podataka za statistiku", Toast.LENGTH_SHORT).show()
            return
        }

        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Generisanje statistike...")
            .setMessage("Pripremam izveštaj...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val statsContent = generateStatisticsReport()
                val fileName = "statistika_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.txt"

                val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                val statsFile = File(downloadsDir, fileName)

                FileWriter(statsFile).use { writer ->
                    writer.write(statsContent)
                }

                runOnUiThread {
                    progressDialog.dismiss()

                    if (statsFile.exists()) {
                        val fileSize = String.format("%.1f", statsFile.length() / 1024.0)
                        Toast.makeText(
                            this@MainActivity,
                            "? Statistika izvežena!\n?? Download/${fileName}\n?? ${fileSize}KB",
                            Toast.LENGTH_LONG
                        ).show()
                    } else {
                        Toast.makeText(this@MainActivity, "? Greška pri èuvanju fajla", Toast.LENGTH_SHORT).show()
                    }
                }

            } catch (e: Exception) {
                runOnUiThread {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška pri eksportu statistike: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
    private fun generateStatisticsReport(): String {
        val builder = StringBuilder()

        builder.append("=" * 50).append("\n")
        builder.append("?? GPS TRACKER - STATISTIÈKI IZVEŠTAJ\n")
        builder.append("=" * 50).append("\n\n")

        // STATISTIKA RUTA
        builder.append("??? STATISTIKA RUTA:\n")
        builder.append("-" * 30).append("\n")

        if (savedRoutes.isNotEmpty()) {
            val totalRoutes = savedRoutes.size
            val totalDistance = savedRoutes.sumOf { it.distance }
            val totalDuration = savedRoutes.sumOf { it.duration } / 1000 / 60
            val longestRoute = savedRoutes.maxByOrNull { it.distance }
            val averageDistance = totalDistance / totalRoutes

            builder.append("• Ukupno ruta: $totalRoutes\n")
            builder.append("• Ukupna udaljenost: ${formatDistance(totalDistance)}\n")
            builder.append("• Ukupno vreme: ${totalDuration} minuta\n")
            builder.append("• Proseèna dužina: ${formatDistance(averageDistance)}\n")

            longestRoute?.let { route ->
                builder.append("• Najduža ruta: ${route.name} (${formatDistance(route.distance)})\n")
            }

            builder.append("\n")
            builder.append("?? DETALJI RUTA:\n")
            savedRoutes.sortedByDescending { it.startTime }.forEach { route ->
                val duration = route.duration / 1000 / 60
                builder.append("• ${route.name}: ${formatDistance(route.distance)} | ${duration}min | ${formatDate(route.startTime)}\n")
            }
        } else {
            builder.append("Nema saèuvanih ruta\n")
        }

        builder.append("\n")

        // STATISTIKA TAÈAKA
        builder.append("?? STATISTIKA TAÈAKA:\n")
        builder.append("-" * 30).append("\n")

        if (pointsOfInterest.isNotEmpty()) {
            builder.append("• Ukupno taèaka: ${pointsOfInterest.size}\n")
            builder.append("• Prva taèka: ${pointsOfInterest.minByOrNull { it.createdAt }?.name ?: "N/A"}\n")
            builder.append("• Poslednja taèka: ${pointsOfInterest.maxByOrNull { it.createdAt }?.name ?: "N/A"}\n")

            builder.append("\n")
            builder.append("?? SPISAK TAÈAKA:\n")
            pointsOfInterest.sortedByDescending { it.createdAt }.forEach { point ->
                builder.append("• ${point.name}: ${String.format("%.6f", point.latitude)}, ${String.format("%.6f", point.longitude)} | ${formatDate(point.createdAt)}\n")
            }
        } else {
            builder.append("Nema saèuvanih taèaka\n")
        }

        builder.append("\n")
        builder.append("=" * 50).append("\n")
        builder.append("Izveštaj generisan: ${SimpleDateFormat("dd.MM.yyyy HH:mm:ss", Locale.getDefault()).format(Date())}\n")
        builder.append("=" * 50).append("\n")

        return builder.toString()
    }

    // Pomoæna ekstenzija za ponavljanje stringa
    private operator fun String.times(n: Int): String = repeat(n)
    private fun exportRouteToGPX() {
        if (!checkStoragePermissionsForExport()) {
            Toast.makeText(this, "?? Potrebne su dozvole za pristup skladištu", Toast.LENGTH_LONG).show()
            requestStoragePermissions()
            return
        }

        if (currentRoute == null) {
            Toast.makeText(this, "? Nema rute za eksport", Toast.LENGTH_SHORT).show()
            return
        }

        val progressDialog = AlertDialog.Builder(this)
            .setTitle("??? Izvoz rute u GPX...")
            .setMessage("Pripremam GPX fajl...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val points = app.routeRepository.getRoutePoints(currentRoute!!.id)

                if (points.isEmpty()) {
                    runOnUiThread {
                        progressDialog.dismiss()
                        Toast.makeText(this@MainActivity, "? Nema podataka rute za eksport", Toast.LENGTH_SHORT).show()
                    }
                    return@launch
                }

                val routeName = currentRoute!!.name
                val gpxContent = generateRouteGPX(routeName, points)
                val fileName = "ruta_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.gpx"

                // KLJUÈNA PROMENA: Koristi Download folder
                val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                val gpxFile = File(downloadsDir, fileName)

                FileWriter(gpxFile).use { writer ->
                    writer.write(gpxContent)
                }

                runOnUiThread {
                    progressDialog.dismiss()

                    if (gpxFile.exists()) {
                        val fileSize = String.format("%.1f", gpxFile.length() / 1024.0)
                        Toast.makeText(
                            this@MainActivity,
                            "? Ruta izvežena!\n?? Download/${fileName}\n?? ${fileSize}KB",
                            Toast.LENGTH_LONG
                        ).show()
                        Log.d("ExportDebug", "?? Ruta saèuvana u: ${gpxFile.absolutePath}")
                    } else {
                        Toast.makeText(this@MainActivity, "? Greška pri èuvanju fajla", Toast.LENGTH_SHORT).show()
                        Log.e("ExportDebug", "? Fajl nije kreiran: ${gpxFile.absolutePath}")
                    }
                }

            } catch (e: Exception) {
                runOnUiThread {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška pri GPX eksportu: ${e.message}", Toast.LENGTH_SHORT).show()
                    Log.e("ExportDebug", "?? Greška: ${e.message}")
                }
            }
        }
    }
    private fun openDownloadsFolder() {
        try {
            val intent = Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(
                    Uri.fromFile(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)),
                    "resource/folder"
                )
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            }
            startActivity(intent)
        } catch (e: Exception) {
            // Ako ne može da otvori folder, pokaži putanju
            val downloadsPath = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).absolutePath
            Toast.makeText(this, "?? Fajl saèuvan u: $downloadsPath", Toast.LENGTH_LONG).show()
        }
    }
    private fun checkStoragePermissionsForExport(): Boolean {
        return if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
            // Za Android 9 i niže, proveri WRITE_EXTERNAL_STORAGE
            ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED
        } else {
            // Za Android 10+, MANAGE_EXTERNAL_STORAGE nije obavezan ali je dobro ga imati
            true
        }
    }
    private fun exportPointsToGPX() {
        if (!checkStoragePermissionsForExport()) {
            Toast.makeText(this, "?? Potrebne su dozvole za pristup skladištu", Toast.LENGTH_LONG).show()
            requestStoragePermissions()
            return
        }
        if (pointsOfInterest.isEmpty()) {
            Toast.makeText(this, "? Nema taèaka za eksport", Toast.LENGTH_SHORT).show()
            return
        }

        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Izvoz taèaka u GPX...")
            .setMessage("Pripremam GPX fajl...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val gpxContent = generatePointsGPX(pointsOfInterest)
                val fileName = "tacke_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.gpx"

                val gpxFile = File(
                    Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
                    fileName
                )

                FileWriter(gpxFile).use { writer ->
                    writer.write(gpxContent)
                }

                runOnUiThread {
                    progressDialog.dismiss()
                    shareFile(gpxFile, "application/gpx+xml", "GPX fajl taèaka")
                    notificationHelper.showExportSuccess(gpxFile.name)
                    Toast.makeText(this@MainActivity, "? Taèke uspešno izvežene u GPX!", Toast.LENGTH_SHORT).show()
                }

            } catch (e: Exception) {
                runOnUiThread {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška pri GPX eksportu: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
    private fun generateRouteGPX(routeName: String, points: List<LocationPoint>): String {
        val builder = StringBuilder()

        builder.append("""<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPS Tracker DS" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>${escapeXml(routeName)}</name>
    <time>${SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.getDefault()).format(Date())}</time>
  </metadata>
  <trk>
    <name>${escapeXml(routeName)}</name>
    <trkseg>
""")

        points.forEach { point ->
            val time = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.getDefault()).format(Date(point.timestamp))
            builder.append("""      <trkpt lat="${point.latitude}" lon="${point.longitude}">
        <time>$time</time>
        <ele>0</ele>
      </trkpt>
""")
        }

        builder.append("""    </trkseg>
  </trk>
</gpx>""")

        return builder.toString()
    }

    private fun generatePointsGPX(points: List<PointOfInterest>): String {
        val builder = StringBuilder()

        builder.append("""<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPS Tracker DS" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>Taèke interesa</name>
    <time>${SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.getDefault()).format(Date())}</time>
  </metadata>
""")

        points.forEach { point ->
            val time = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.getDefault()).format(Date(point.createdAt))
            builder.append("""  <wpt lat="${point.latitude}" lon="${point.longitude}">
    <name>${escapeXml(point.name)}</name>
    <time>$time</time>
    <desc>Taèka interesa: ${escapeXml(point.name)}</desc>
    <sym>Flag</sym>
  </wpt>
""")
        }

        builder.append("</gpx>")

        return builder.toString()
    }

    private fun escapeXml(text: String): String {
        return text.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&apos;")
    }
    private fun exportRouteToCSV() {
        if (!checkStoragePermissionsForExport()) {
            Toast.makeText(this, "?? Potrebne su dozvole za pristup skladištu", Toast.LENGTH_LONG).show()
            requestStoragePermissions()
            return
        }

        if (currentRoute == null) {
            Toast.makeText(this, "? Nema rute za eksport", Toast.LENGTH_SHORT).show()
            return
        }

        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Izvoz rute u CSV...")
            .setMessage("Pripremam CSV fajl...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val points = app.routeRepository.getRoutePoints(currentRoute!!.id)

                if (points.isEmpty()) {
                    runOnUiThread {
                        progressDialog.dismiss()
                        Toast.makeText(this@MainActivity, "? Nema podataka rute za eksport", Toast.LENGTH_SHORT).show()
                    }
                    return@launch
                }

                val fileName = "ruta_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.csv"

                // KLJUÈNA PROMENA: Koristi Download folder
                val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                val csvFile = File(downloadsDir, fileName)

                FileWriter(csvFile).use { writer ->
                    writer.append("Vreme,Širina,Dužina,Taènost\n")
                    points.forEach { point ->
                        val time = SimpleDateFormat("dd.MM.yyyy HH:mm:ss", Locale.getDefault()).format(Date(point.timestamp))
                        writer.append("$time,${point.latitude},${point.longitude},${point.accuracy}\n")
                    }
                }

                runOnUiThread {
                    progressDialog.dismiss()

                    if (csvFile.exists()) {
                        val fileSize = String.format("%.1f", csvFile.length() / 1024.0)
                        Toast.makeText(
                            this@MainActivity,
                            "? Ruta izvežena!\n?? Download/${fileName}\n?? ${fileSize}KB",
                            Toast.LENGTH_LONG
                        ).show()
                        Log.d("ExportDebug", "?? CSV ruta saèuvana u: ${csvFile.absolutePath}")
                    } else {
                        Toast.makeText(this@MainActivity, "? Greška pri èuvanju CSV fajla", Toast.LENGTH_SHORT).show()
                    }
                }

            } catch (e: Exception) {
                runOnUiThread {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška pri CSV eksportu: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun exportPointsToCSV() {
        if (!checkStoragePermissionsForExport()) {
            Toast.makeText(this, "?? Potrebne su dozvole za pristup skladištu", Toast.LENGTH_LONG).show()
            requestStoragePermissions()
            return
        }
        if (pointsOfInterest.isEmpty()) {
            Toast.makeText(this, "Nema taèaka za eksport", Toast.LENGTH_SHORT).show()
            return
        }
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val csvFile = File(
                    getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS),
                    "tacke_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.csv"
                )
                FileWriter(csvFile).use { writer ->
                    writer.append("Ime,Širina,Dužina,Datum kreiranja\n")
                    pointsOfInterest.forEach { point ->
                        val time = SimpleDateFormat("dd.MM.yyyy HH:mm:ss", Locale.getDefault()).format(Date(point.createdAt))
                        writer.append("${point.name},${point.latitude},${point.longitude},$time\n")
                    }
                }
                runOnUiThread {
                    shareFile(csvFile, "text/csv", "CSV fajl taèaka")
                    notificationHelper.showExportSuccess(csvFile.name)
                    Toast.makeText(this@MainActivity, "Taèke uspešno eksportovane!", Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Greška pri eksportu: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun shareFile(file: File, mimeType: String, title: String) {
        val uri = FileProvider.getUriForFile(
            this,
            "${packageName}.provider",
            file
        )
        val intent = Intent(Intent.ACTION_SEND).apply {
            type = mimeType
            putExtra(Intent.EXTRA_STREAM, uri)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }
        startActivity(Intent.createChooser(intent, title))
    }

    private fun formatDate(timestamp: Long): String {
        val sdf = SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault())
        return sdf.format(Date(timestamp))
    }

    private fun getBearingDirection(bearing: Float): String {
        return when {
            bearing < 22.5 || bearing >= 337.5 -> "Sever"
            bearing < 67.5 -> "Severoistok"
            bearing < 112.5 -> "Istok"
            bearing < 157.5 -> "Jugoistok"
            bearing < 202.5 -> "Jug"
            bearing < 247.5 -> "Jugozapad"
            bearing < 292.5 -> "Zapad"
            else -> "Severozapad"
        }
    }
    private fun getBatteryLevel(): Int {
        return try {
            val batteryIntent = registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))
            val level = batteryIntent?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1
            val scale = batteryIntent?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: -1
            if (level == -1 || scale == -1) 0 else (level * 100 / scale.toFloat()).toInt()
        } catch (e: Exception) {
            0
        }
    }

    private fun getCurrentUserId(): String {
        return try {
            val sharedPreferences = getSharedPreferences("user_prefs", MODE_PRIVATE)
            sharedPreferences.getString("user_email", "default-user") ?: "default-user"
        } catch (e: Exception) {
            "default-user"
        }
    }

    private fun showSettings() {
        Toast.makeText(this, "Podešavanja æe biti dostupna uskoro", Toast.LENGTH_SHORT).show()
    }

    private fun showHistory() {
        Toast.makeText(this, "Istorija æe biti dostupna uskoro", Toast.LENGTH_SHORT).show()
    }

    private fun showHelp() {
        Toast.makeText(this, "Pomoæ æe biti dostupna uskoro", Toast.LENGTH_SHORT).show()
    }

    private fun logout() {
        AlertDialog.Builder(this)
            .setTitle("Odjava")
            .setMessage("Da li ste sigurni da želite da se odjavite?")
            .setPositiveButton("Da") { dialog, which ->
                performLogout()
            }
            .setNegativeButton("Ne", null)
            .show()
    }

    private fun performLogout() {
        if (isTracking) {
            stopTracking()
        }
        stopLocationUpdates()
        notificationHelper.cancelAllNotifications()
        val intent = Intent(this, jovannedeljkovic.gps_tracker_pro.ui.auth.LoginActivity::class.java)
        startActivity(intent)
        finish()
        Toast.makeText(this, "Uspešno ste se odjavili", Toast.LENGTH_SHORT).show()
    }

    // LOCATION PERMISSIONS
    private fun checkLocationPermissions() {
        when {
            ContextCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) == PackageManager.PERMISSION_GRANTED -> {
                startLocationUpdates()
            }
            else -> {
                requestLocationPermissions()
            }
        }
    }

    private fun requestLocationPermissions() {
        ActivityCompat.requestPermissions(
            this,
            arrayOf(
                Manifest.permission.ACCESS_FINE_LOCATION,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ),
            LOCATION_PERMISSION_REQUEST_CODE
        )
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)

        when (requestCode) {
            LOCATION_PERMISSION_REQUEST_CODE -> {
                if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    startLocationUpdates()
                } else {
                    Toast.makeText(this, "Dozvola za lokaciju je neophodna za rad aplikacije", Toast.LENGTH_LONG).show()
                }
            }
            LOCATION_PERMISSION_REQUEST_CODE + 100 -> { // Nove dozvole za skladištenje
                if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(this, "? Dozvole za skladištenje odobrene!", Toast.LENGTH_SHORT).show()
                    importGpxFromDownloads() // Ponovo pokušaj
                } else {
                    Toast.makeText(this, "? Dozvole za skladištenje odbijene", Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    private fun startLocationUpdates() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            Log.e("Location", "Nema dozvola za lokaciju!")
            requestLocationPermissions()
            return
        }

        try {
            fusedLocationClient.requestLocationUpdates(
                locationRequest,
                locationCallback,
                Looper.getMainLooper()
            )
            Log.d("Location", "Location updates started")
        } catch (e: SecurityException) {
            Log.e("Location", "Security exception: ${e.message}")
            requestLocationPermissions()
        }
    }

    private fun stopLocationUpdates() {
        fusedLocationClient.removeLocationUpdates(locationCallback)
    }
    // DODAJ U MAIN ACTIVITY
    private fun getCurrentUserFromPrefs(): String {
        val sharedPreferences = getSharedPreferences("user_prefs", MODE_PRIVATE)
        return sharedPreferences.getString("user_email", "unknown") ?: "unknown"
    }

    private fun checkUserFeatures() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val app = application as App
                val userEmail = getCurrentUserFromPrefs()
                val user = app.userRepository.getUserByEmail(userEmail)

                runOnUiThread {
                    // Ažurirajte UI na osnovu korisnièkih privilegija
                    if (user?.role == "PREMIUM") {
                        // Omoguæite premium funkcionalnosti
                    }
                }
            } catch (e: Exception) {
                Log.e("UserFeatures", "Greška pri proveri korisnièkih feature-a: ${e.message}")
            }
        }
    }
    private fun safeButtonSetup() {
        // Proveri da li je binding inicijalizovan i da li dugmiæi postoje
        if (::binding.isInitialized) {
            // TRACKING DUGMIÆI
            binding.btnStartTracking?.setOnClickListener { startTracking() }
            binding.btnStopTracking?.setOnClickListener { stopTracking() }

            // LOKACIJA I ZOOM
            binding.btnMyLocation?.setOnClickListener { centerOnMyLocationSilent() }
            binding.btnMyLocation?.setOnLongClickListener {
                resetZoomToLocation()
                true
            }

            // MENI I NAVIGACIJA
            binding.btnMenu?.setOnClickListener { showNavigationMenu() }
            binding.btnSavedRoutes?.setOnClickListener { showSavedRoutes() }
            binding.btnNavigation?.setOnClickListener { openGoogleMaps() }

            // ZOOM KONTROLE
            binding.btnZoomIn?.setOnClickListener { zoomIn() }
            binding.btnZoomOut?.setOnClickListener { zoomOut() }

            // TAÈKE I MAPA
            binding.fabAddPoint?.setOnClickListener { togglePointMode() }
            binding.btnMapType?.setOnClickListener { showMapTypeDialog() }

            // TRACKING MODE I KOMPAS
            binding.btnTrackingMode?.setOnClickListener { toggleTrackingMode() }
            binding.btnCompass?.setOnClickListener { toggleCompass() }

            // ORIJENTACIJA I PRAÆENJE
            binding.btnMapOrientation?.setOnClickListener { toggleMapOrientation() }
            binding.btnFollowLocation?.setOnClickListener { toggleAutoFollow() }

            // EKSPORT I RESET
            binding.btnExport?.setOnClickListener { exportRouteData() }
            binding.btnReset?.setOnClickListener { resetCurrentRoute() }

            Log.d("SafeSetup", "? Svi dugmiæi bezbedno postavljeni")
        } else {
            Log.e("SafeSetup", "? Binding nije inicijalizovan")
        }
    }
    private fun createOfflineSatelliteTileSource(): XYTileSource {
        return object : XYTileSource(
            "OfflineSatellite",
            0, 18, 256, ".png",
            arrayOf("") // prazan URL jer koristimo cache
        ) {
            override fun getTileURLString(pMapTileIndex: Long): String {
                val zoom = MapTileIndex.getZoom(pMapTileIndex)
                val x = MapTileIndex.getX(pMapTileIndex)
                val y = MapTileIndex.getY(pMapTileIndex)

                // OSMdroid æe automatski tražiti tile u cache-u
                return "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/$zoom/$y/$x"
            }
        }
    }


    // Poboljšana metoda za taèno izraèunavanje udaljenosti
    private fun calculateAccurateDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val earthRadius = 6371000.0 // meters

        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)

        val a = sin(dLat / 2) * sin(dLat / 2) +
                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *
                sin(dLon / 2) * sin(dLon / 2)

        val c = 2 * atan2(sqrt(a), sqrt(1 - a))

        return earthRadius * c
    }

    // Ažuriraj prikaz statistike
    private fun updateStatsDisplay() {
        try {
            val distanceKm = totalDistance / 1000.0
            val speedKmh = currentSpeed * 3.6 // m/s to km/h

            runOnUiThread {
                findViewById<TextView>(R.id.tvDistance)?.text =
                    String.format("%.2f km", distanceKm)
                findViewById<TextView>(R.id.tvSpeed)?.text =
                    String.format("%.1f km/h", speedKmh)
                findViewById<TextView>(R.id.tvTime)?.text =
                    formatTime(trackingTime)
            }
        } catch (e: Exception) {
            Log.e("MainActivity", "Error updating stats", e)
        }
    }
    private fun formatTime(milliseconds: Long): String {
        val seconds = milliseconds / 1000
        val minutes = seconds / 60
        val hours = minutes / 60

        return if (hours > 0) {
            String.format("%02d:%02d:%02d", hours, minutes % 60, seconds % 60)
        } else {
            String.format("%02d:%02d", minutes, seconds % 60)
        }
    }

    // I dodaj trackingTime varijablu u deklaracije:
    private fun refreshMap() {
        // OSVEŽI PRIKAZ RUTE AKO JE AKTIVNO SNIMANJE
        if (isTracking && routePoints.size >= 2) {
            runOnUiThread {
                drawSmoothRouteOnMap()
                Log.d("MapRefresh", "?? Mapa osvežena - ${routePoints.size} taèaka")
            }
        }

        // OSVEŽI CELE MAPI
        binding.mapView.invalidate()
        binding.mapView.postInvalidate()
    }
    private fun createNewRouteSegment() {
        if (currentSegment.isNotEmpty()) {
            // SAÈUVAJ TEKUÆI SEGMENT
            routeSegments.add(currentSegment.toMutableList())

            // ZAPOÈNI NOVI SEGMENT SA POSLEDNJOM TAÈKOM
            val lastPoint = currentSegment.lastOrNull()
            currentSegment = mutableListOf<GeoPoint>()

            lastPoint?.let { point ->
                currentSegment.add(point)
                Log.d("Tracking", "?? Novi segment zapoèet sa taèkom: ${point.latitude}, ${point.longitude}")
            }
        }
    }
    private fun refreshMapAndRoute() {
        try {
            // PROVERI DA LI JE BINDING INICIJALIZOVAN
            if (!::binding.isInitialized) {
                Log.w("MapRefresh", "Binding nije inicijalizovan, preskaèem osvežavanje")
                return
            }

            Log.d("MapRefresh", "Osvežavam mapu i rutu...")

            runOnUiThread {
                // 1. OSVEŽI MAP VIEW
                binding.mapView.invalidate()
                binding.mapView.postInvalidate()

                // 2. PONOVO ISCRTAJ RUTU AKO POSTOJI
                if (isTracking && routePoints.isNotEmpty()) {
                    Log.d("RouteRefresh", "Ponovo iscrtavam rutu sa ${routePoints.size} taèaka")
                    drawSmoothRouteOnMap()
                }

                // 3. OSVEŽI LOKACIJU MARKER
                lastLocation?.let {
                    val currentLocation = GeoPoint(it.latitude, it.longitude)
                    showAccurateLocationMarker(currentLocation, it)
                }

                // 4. OSVEŽI TAÈKE INTERESA
                refreshPointsOfInterest()

                Log.d("MapRefresh", "Mapa i ruta uspešno osvežene")
            }
        } catch (e: Exception) {
            Log.e("MapRefresh", "Greška pri osvežavanju mape: ${e.message}")
        }
    }
    private fun importGpxFromDownloads() {
        Log.d("ImportDebug", "?? POZIVAM importGpxFromDownloads()")

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            // Za Android 10+ koristi MediaStore
            queryGpxFilesWithMediaStoreAndroid10()
        } else {
            // Za starije Androide koristi legacy pristup
            queryGpxFilesLegacy()
        }
    }
@RequiresApi(Build.VERSION_CODES.Q)
private fun queryGpxFilesWithMediaStoreAndroid10() {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
        queryGpxFilesLegacy()
        return
    }

    val progressDialog = AlertDialog.Builder(this)
        .setTitle("?? Tražim GPX fajlove...")
        .setMessage("Pretražujem Download folder...")
        .setCancelable(false)
        .create()
    progressDialog.show()

    lifecycleScope.launch(Dispatchers.IO) {
        try {
            val projection = arrayOf(
                MediaStore.Downloads._ID,
                MediaStore.Downloads.DISPLAY_NAME,
                MediaStore.Downloads.SIZE,
                MediaStore.Downloads.DATE_MODIFIED
            )

            val selection = "${MediaStore.Downloads.DISPLAY_NAME} LIKE ?"
            val selectionArgs = arrayOf("%.gpx")

            val sortOrder = "${MediaStore.Downloads.DATE_MODIFIED} DESC"

            val cursor = contentResolver.query(
                MediaStore.Downloads.EXTERNAL_CONTENT_URI,
                projection,
                selection,
                selectionArgs,
                sortOrder
            )

            val gpxFiles = mutableListOf<GpxFileInfo>()

            cursor?.use { c ->
                val idColumn = c.getColumnIndexOrThrow(MediaStore.Downloads._ID)
                val nameColumn = c.getColumnIndexOrThrow(MediaStore.Downloads.DISPLAY_NAME)
                val sizeColumn = c.getColumnIndexOrThrow(MediaStore.Downloads.SIZE)
                val dateColumn = c.getColumnIndexOrThrow(MediaStore.Downloads.DATE_MODIFIED)

                while (c.moveToNext()) {
                    val id = c.getLong(idColumn)
                    val name = c.getString(nameColumn)
                    val size = c.getLong(sizeColumn)
                    val dateModified = c.getLong(dateColumn)

                    gpxFiles.add(GpxFileInfo(id, name, size, dateModified))
                }
            }

            withContext(Dispatchers.Main) {
                progressDialog.dismiss()
                if (gpxFiles.isNotEmpty()) {
                    showMediaStoreGpxFilesAndroid10(gpxFiles)
                } else {
                    showNoGpxFilesFound()
                }
            }

        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                progressDialog.dismiss()
                Log.e("MediaStore", "Greška pri pretrazi: ${e.message}")
                Toast.makeText(this@MainActivity, "? Greška pri pretrazi: ${e.message}", Toast.LENGTH_LONG).show()
            }
        }
    }
}

    @RequiresApi(Build.VERSION_CODES.Q)
    private fun showMediaStoreGpxFilesAndroid10(gpxFiles: List<GpxFileInfo>) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
            return
        }

        val fileNames = gpxFiles.map { file ->
            val date = SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault()).format(Date(file.dateModified * 1000))
            val size = String.format("%.1f", file.size / 1024.0)
            "${file.name}\n   ?? $date • ?? ${size}KB"
        }.toTypedArray()

        AlertDialog.Builder(this)
            .setTitle("?? GPX fajlovi u Download folderu (${gpxFiles.size})")
            .setItems(fileNames) { dialog, which ->
                val selectedFile = gpxFiles[which]
                importGpxFromMediaStoreAndroid10(selectedFile)
            }
            .setPositiveButton("?? Osveži listu") { dialog, which ->
                queryGpxFilesWithMediaStoreAndroid10()
            }
            .setNegativeButton("? Otkaži", null)
            .show()
    }

    private fun importGpxFromMediaStoreAndroid10(gpxFile: GpxFileInfo) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
            Toast.makeText(this, "? Ova funkcija zahteva Android 10+", Toast.LENGTH_SHORT).show()
            return
        }

        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Uvoz rute...")
            .setMessage("Uèitavam GPX fajl: ${gpxFile.name}")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val uri = ContentUris.withAppendedId(
                    MediaStore.Downloads.EXTERNAL_CONTENT_URI,
                    gpxFile.id
                )

                contentResolver.openInputStream(uri)?.use { inputStream ->
                    val gpxContent = inputStream.bufferedReader().use { it.readText() }
                    val points = parseGpxContent(gpxContent)

                    withContext(Dispatchers.Main) {
                        progressDialog.dismiss()
                        if (points.isNotEmpty()) {
                            showImportedRoutePreview(points)
                        } else {
                            Toast.makeText(this@MainActivity, "? Nema taèaka u GPX fajlu", Toast.LENGTH_LONG).show()
                        }
                    }
                } ?: run {
                    throw Exception("Ne mogu da otvorim fajl: ${gpxFile.name}")
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Log.e("MediaStoreImport", "Greška pri uvozu: ${e.message}")
                    Toast.makeText(this@MainActivity, "? Greška pri uvozu: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    @Suppress("DEPRECATION")
    private fun queryGpxFilesLegacy() {
        try {
            // PROVERI DOZVOLE PRVO
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)
                != PackageManager.PERMISSION_GRANTED) {
                Log.d("ImportDebug", "?? Tražim dozvole za storage...")
                requestStoragePermissions()
                return
            }

            val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)

            Log.d("DownloadImport", "?? Pristupam Download folderu: ${downloadsDir.absolutePath}")

            if (!downloadsDir.exists() || !downloadsDir.isDirectory) {
                Toast.makeText(this, "? Download folder ne postoji", Toast.LENGTH_LONG).show()
                return
            }

            val gpxFiles = downloadsDir.listFiles { file ->
                file.isFile && (file.name.endsWith(".gpx", ignoreCase = true) ||
                        file.name.endsWith(".xml", ignoreCase = true))
            }

            Log.d("DownloadImport", "?? Pronaðeno ${gpxFiles?.size ?: 0} GPX fajlova")

            if (gpxFiles.isNullOrEmpty()) {
                showNoGpxFilesFound()
                return
            }

            val sortedFiles = gpxFiles.sortedByDescending { it.lastModified() }
            val fileNames = sortedFiles.map { file ->
                val date = SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault()).format(Date(file.lastModified()))
                val size = String.format("%.1f", file.length() / 1024.0)
                "${file.name}\n   ?? $date • ?? ${size}KB"
            }.toTypedArray()

            AlertDialog.Builder(this)
                .setTitle("?? GPX fajlovi u Download folderu (${gpxFiles.size})")
                .setItems(fileNames) { dialog, which ->
                    val selectedFile = sortedFiles[which]
                    Log.d("DownloadImport", "? Izabran fajl: ${selectedFile.name}")
                    importGpxFileDirect(selectedFile)
                }
                .setPositiveButton("?? Osveži listu") { dialog, which ->
                    queryGpxFilesLegacy() // Rekurzivni poziv za osvežavanje
                }
                .setNegativeButton("? Otkaži", null)
                .show()

        } catch (e: SecurityException) {
            Log.e("LegacyImport", "?? Bezbednosni izuzetak: ${e.message}")
            Toast.makeText(this, "? Nema dozvola za pristup fajlovima", Toast.LENGTH_LONG).show()
            requestStoragePermissions()
        } catch (e: Exception) {
            Log.e("LegacyImport", "?? Greška: ${e.message}")
            Toast.makeText(this, "? Greška: ${e.message}", Toast.LENGTH_LONG).show()
        }
    }
    private fun importGpxFileDirect(file: File) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Uvoz rute...")
            .setMessage("Uèitavam GPX fajl: ${file.name}\n\nMolimo saèekajte...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                Log.d("GPXImport", "?? Poèinjem uvoz fajla: ${file.absolutePath}")

                // PROVERI VELIÈINU FAJLA
                if (file.length() > 10 * 1024 * 1024) { // 10MB limit
                    throw Exception("Fajl je prevelik (${file.length() / 1024 / 1024}MB). Maksimalna velièina je 10MB.")
                }

                // PROVERI DA LI FAJL POSTOJI I MOŽE DA SE ÈITA
                if (!file.exists()) {
                    throw Exception("Fajl ne postoji: ${file.name}")
                }

                if (!file.canRead()) {
                    throw Exception("Nemamo dozvolu za èitanje fajla: ${file.name}")
                }

                val gpxContent = file.readText(Charsets.UTF_8)
                Log.d("GPXImport", "? Proèitao ${gpxContent.length} karaktera iz fajla")

                if (gpxContent.isBlank()) {
                    throw Exception("Fajl je prazan: ${file.name}")
                }

                val points = parseGpxContent(gpxContent)
                Log.d("GPXImport", "? Parsovano ${points.size} taèaka iz GPX fajla")

                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    if (points.isNotEmpty()) {
                        showImportedRoutePreview(points) // ISPRAVLJENO: Bez dodatnog parametra
                    } else {
                        Toast.makeText(this@MainActivity,
                            "? Nema validnih taèaka u GPX fajlu '${file.name}'",
                            Toast.LENGTH_LONG
                        ).show()
                    }
                }
            } catch (e: Exception) {
                Log.e("GPXImport", "?? Greška pri uvozu fajla '${file.name}': ${e.message}")
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    showImportErrorDialog(file.name, e.message ?: "Nepoznata greška")
                }
            }
        }
    }
    private fun updateUIForUserRole(user: User) {
        val roleDisplay = FeatureManager.getUserRoleDisplayName(user)

        // Ažuriraj UI u zavisnosti od role
        when (user.role) {
            "BASIC" -> {
                // Indikator za BASIC korisnike
                binding.btnMapType.alpha = 0.7f
                binding.btnTrackingMode.alpha = 0.7f
                binding.fabAddPoint.alpha = 0.7f

                // Dodaj badge ili indikator
                binding.tvUserRole.visibility = View.VISIBLE
                binding.tvUserRole.text = "?? BASIC"
                binding.tvUserRole.setTextColor(ContextCompat.getColor(this, R.color.blue_primary))

                // Log za debug
                Log.d("UserRole", "Korisnik: ${user.name}, Role: $roleDisplay, Ogranièenja: BASIC")
            }
            "PREMIUM" -> {
                binding.btnMapType.alpha = 1.0f
                binding.btnTrackingMode.alpha = 1.0f
                binding.fabAddPoint.alpha = 1.0f

                binding.tvUserRole.visibility = View.VISIBLE
                binding.tvUserRole.text = "? PREMIUM"
                binding.tvUserRole.setTextColor(ContextCompat.getColor(this, R.color.accent_green))

                Log.d("UserRole", "Korisnik: ${user.name}, Role: $roleDisplay, Ogranièenja: NEMA")
            }
            "ADMIN" -> {
                binding.btnMapType.alpha = 1.0f
                binding.btnTrackingMode.alpha = 1.0f
                binding.fabAddPoint.alpha = 1.0f

                binding.tvUserRole.visibility = View.VISIBLE
                binding.tvUserRole.text = "?? ADMIN"
                binding.tvUserRole.setTextColor(ContextCompat.getColor(this, R.color.accent_red))

                Log.d("UserRole", "Korisnik: ${user.name}, Role: $roleDisplay, Ogranièenja: NEMA")
            }
        }
    }
    // LIFECYCLE METHODS
    override fun onResume() {
        super.onResume()
        isActivityVisible = true
        Log.d("Lifecycle", "?? MainActivity onResume - vidljiva")
        // DODAJ OVO: OSVEŽI TAÈKE PRI POVRATKU NA APLIKACIJU
        loadPointsOfInterest()
        // Obavesti servis da je aplikacija u foregroundu
        if (isTracking) {
            val intent = Intent(this, TrackingService::class.java).apply {
                action = TrackingService.ACTION_APP_IN_FOREGROUND
            }
            startService(intent)
            Log.d("Tracking", "?? Aplikacija u foregroundu - maksimalna taènost")
        }
        // KLJUÈNO: OSVEŽI MAPU I RUTU PRI POVRATKU
        refreshMapAndRoute()
    }
    override fun onPause() {
        super.onPause()
        isActivityVisible = false
        Log.d("Lifecycle", "?? MainActivity onPause - nije vidljiva")
        // Obavesti servis da je aplikacija u pozadini
        if (isTracking) {
            val intent = Intent(this, TrackingService::class.java).apply {
                action = TrackingService.ACTION_APP_IN_BACKGROUND
            }
            startService(intent)
            Log.d("Tracking", "?? Aplikacija u pozadini - optimizujem bateriju")
        }
    }
    override fun onStop() {
        super.onStop()
        isActivityVisible = false
        Log.d("Lifecycle", "?? MainActivity onStop - nije vidljiva")
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)

        Log.d("ActivityResult", "Primljen rezultat: requestCode=$requestCode, resultCode=$resultCode")

        if (resultCode == Activity.RESULT_OK) {
            when (requestCode) {
                IMPORT_GPX_REQUEST_CODE -> {
                    data?.data?.let { uri ->
                        Log.d("ActivityResult", "GPX uvoz rute: $uri")
                        importGpxRoute(uri)
                    } ?: run {
                        Toast.makeText(this, "? Nije izabran fajl", Toast.LENGTH_SHORT).show()
                    }
                }
                IMPORT_GPX_POINTS_REQUEST_CODE -> {
                    data?.data?.let { uri ->
                        Log.d("ActivityResult", "GPX uvoz taèaka: $uri")
                        importGpxPoints(uri)  // OVO JE KLJUÈNO - OVA METODA TREBA DA POSTOJI
                    } ?: run {
                        Toast.makeText(this, "? Nije izabran fajl", Toast.LENGTH_SHORT).show()
                    }
                }
                IMPORT_CSV_REQUEST_CODE -> {
                    data?.data?.let { uri ->
                        Log.d("ActivityResult", "CSV uvoz: $uri")
                        importCsvPoints(uri)  // OVO JE KLJUÈNO - OVA METODA TREBA DA POSTOJI
                    }
                }
                IMPORT_BACKUP_REQUEST_CODE -> {
                    data?.data?.let { uri ->
                        Log.d("ActivityResult", "Backup uvoz: $uri")
                        importBackupData(uri)
                    }
                }
            }
        } else if (resultCode == Activity.RESULT_CANCELED) {
            Log.d("ActivityResult", "Korisnik je otkazao izbor fajla")
        }
    }

    private fun importGpxPoints(uri: Uri) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("?? Uvoz taèaka...")
            .setMessage("Uèitavam taèke iz GPX fajla...")
            .setCancelable(false)
            .create()
        progressDialog.show()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                contentResolver.openInputStream(uri)?.use { inputStream ->
                    val gpxContent = inputStream.bufferedReader().use { it.readText() }

                    // PARSIRAJ TAÈKE IZ GPX (waypoints)
                    val points = parseGpxPoints(gpxContent)

                    withContext(Dispatchers.Main) {
                        progressDialog.dismiss()
                        if (points.isNotEmpty()) {
                            showImportedPointsPreview(points)
                        } else {
                            Toast.makeText(this@MainActivity, "? Nema taèaka u GPX fajlu", Toast.LENGTH_LONG).show()
                        }
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(this@MainActivity, "? Greška pri uvozu taèaka: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    private suspend fun parseGpxPoints(gpxContent: String): List<PointOfInterest> {
        val points = mutableListOf<PointOfInterest>()

        try {
            // TRAŽI <wpt> (waypoints) TAGOVE - TO SU TAÈKE INTERESA
            val waypointPattern = """<wpt lat="([^"]+)" lon="([^"]+)">([\s\S]*?)</wpt>""".toRegex()
            val matches = waypointPattern.findAll(gpxContent)

            matches.forEach { match ->
                val lat = match.groupValues[1].toDoubleOrNull()
                val lon = match.groupValues[2].toDoubleOrNull()
                val content = match.groupValues[3]

                if (lat != null && lon != null) {
                    // IZVLACI IME TAÈKE
                    val namePattern = """<name>([^<]+)</name>""".toRegex()
                    val nameMatch = namePattern.find(content)
                    val name = nameMatch?.groupValues?.get(1) ?: "Taèka ${points.size + 1}"

                    // KREIRAJ POINT OF INTEREST
                    val point = PointOfInterest(
                        userId = getCurrentUserId(),
                        name = name,
                        latitude = lat,
                        longitude = lon,
                        createdAt = System.currentTimeMillis()
                    )
                    points.add(point)

                    Log.d("GPXPoints", "Pronaðena taèka: $name ($lat, $lon)")
                }
            }

            // ALTERNATIVNO: TRAŽI I <rtept> (route points) KAO TAÈKE
            val routePointPattern = """<rtept lat="([^"]+)" lon="([^"]+)">([\s\S]*?)</rtept>""".toRegex()
            val routeMatches = routePointPattern.findAll(gpxContent)

            routeMatches.forEach { match ->
                val lat = match.groupValues[1].toDoubleOrNull()
                val lon = match.groupValues[2].toDoubleOrNull()
                val content = match.groupValues[3]

                if (lat != null && lon != null) {
                    val namePattern = """<name>([^<]+)</name>""".toRegex()
                    val nameMatch = namePattern.find(content)
                    val name = nameMatch?.groupValues?.get(1) ?: "Ruta taèka ${points.size + 1}"

                    val point = PointOfInterest(
                        userId = getCurrentUserId(),
                        name = name,
                        latitude = lat,
                        longitude = lon,
                        createdAt = System.currentTimeMillis()
                    )
                    points.add(point)

                    Log.d("GPXPoints", "Pronaðena ruta taèka: $name ($lat, $lon)")
                }
            }

            Log.d("GPXPoints", "Ukupno pronaðeno ${points.size} taèaka u GPX fajlu")

        } catch (e: Exception) {
            Log.e("GPXPoints", "Greška pri parsiranju GPX taèaka: ${e.message}")
        }

        return points
    }
    private fun showNoGpxFilesHelp() {
        AlertDialog.Builder(this)
            .setTitle("?? Nema GPX fajlova")
            .setMessage("""
        Nema GPX fajlova u Download folderu.
        
        Kako dodati GPX fajlove:
        
        1. ?? Preuzmite GPX fajl sa interneta
        2. ?? Saèuvajte ga u Download folder
        3. ?? Vratite se ovde i osvežite listu
        4. ? Izaberite fajl za uvoz
        
        Ili koristite File Picker opciju.
        """.trimIndent())
            .setPositiveButton("?? File Picker") { dialog, which ->
                importRouteFromFile()
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }

    private fun showImportErrorDialog(fileName: String, error: String) {
        AlertDialog.Builder(this)
            .setTitle("? Greška pri uvozu")
            .setMessage("""
        Greška pri uvozu fajla: $fileName
        
        Problem: $error
        
        Rešenja:
        • Proverite da li je fajl ošteæen
        • Pokušajte sa drugim GPX fajlom  
        • Koristite File Picker umesto Download foldera
        """.trimIndent())
            .setPositiveButton("?? Pokušaj Ponovo") { dialog, which ->
                importGpxFromDownloads()
            }
            .setNegativeButton("? Zatvori", null)
            .show()
    }

private fun showImportHelpDialog() {
    AlertDialog.Builder(this)
        .setTitle("?? Pomoc pri uvozu GPX fajlova")
        .setMessage("""
        ?? Kako uvesti GPX rute:
        
        1. **File Picker** (Preporuèeno):
           • Otvara sistemski file browser
           • Radi sa svim folderima
           • Podržava Cloud storage
        
        2. **Download Folder**:
           • Direktan pristup Download folderu
           • Brži pristup lokalnim fajlovima
           • Može zahtevati dozvole
        
        ?? Podržani formati:
        • .gpx (GPS Exchange Format)
        • .xml (XML fajlovi sa rutama)
        
        ?? Savet: Ako jedna opcija ne radi, probajte drugu!
        """.trimIndent())
        .setPositiveButton("? Razumem", null)
        .show()
}
    override fun onDestroy() {
        super.onDestroy()
        // OÈISTI RECEIVER
        if (isReceivingBackgroundUpdates) {
            try {
                unregisterReceiver(backgroundLocationReceiver)
                isReceivingBackgroundUpdates = false
            } catch (e: Exception) {
                Log.e("MainActivity", "Greška pri uklanjanju receivera u onDestroy: ${e.message}")
            }
        }
        // ZAUSTAVI LOCATION UPDATES
        stopLocationUpdates()
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\utils\AdminManager.kt

// app/src/main/java/jovannedeljkovic/gps_tracker_pro/utils/AdminManager.kt
package jovannedeljkovic.gps_tracker_pro.utils

object AdminManager {
    // OVDE STAVI SVOJ EMAIL I BUDUÆE ADMIN EMAILOVE
    private val masterAdminEmails = setOf(
        "jocaned@gmail.com", // ZAMENI SA TVOJIM STVARNIM EMAILOM
        "admin@gpstracker.com",
        "backupadmin@localhost"
    )

    fun isMasterAdmin(email: String): Boolean {
        return masterAdminEmails.contains(email.toLowerCase())
    }

    fun getMasterAdminEmails(): Set<String> {
        return masterAdminEmails
    }

    fun isValidSecretCode(code: String): Boolean {
        return code == "ADMIN123" // Promeni ovaj kod po želji
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\utils\FeatureManager.kt

package jovannedeljkovic.gps_tracker_pro.utils

import jovannedeljkovic.gps_tracker_pro.data.entities.User

object FeatureManager {

    // PROVERE ZA RUTE
    fun canCreateUnlimitedRoutes(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    fun getMaxDailyRoutes(user: User): Int {
        return when (user.role) {
            "ADMIN", "PREMIUM" -> Int.MAX_VALUE
            else -> 3 // BASIC korisnici maksimalno 3 rute dnevno
        }
    }

    // PROVERE ZA TAÈKE
    fun canCreateUnlimitedPoints(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    fun getMaxPoints(user: User): Int {
        return when (user.role) {
            "ADMIN", "PREMIUM" -> Int.MAX_VALUE
            else -> 10 // BASIC korisnici maksimalno 10 taèaka
        }
    }

    // PROVERE ZA MAPE
    fun canUseSatelliteMaps(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    fun canUseOfflineMaps(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    fun canUseTopoMaps(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    // PROVERE ZA EKSPORT
    fun canExportGPX(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    fun canExportKML(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    fun canExportPDF(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    // PROVERE ZA NAPREDNE FUNKCIONALNOSTI
    fun canUseRealTimeTracking(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    fun canUseCloudBackup(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    fun canUseAdvancedAnalytics(user: User): Boolean {
        return user.role == "PREMIUM" || user.role == "ADMIN"
    }

    // PRIKAZ INFORMACIJA O KORISNIKU
    fun getUserRoleDisplayName(user: User): String {
        return when (user.role) {
            "ADMIN" -> "?? Administrator"
            "PREMIUM" -> "? Premium"
            else -> "?? Basic"
        }
    }

    fun getRoleBenefits(user: User): List<String> {
        return when (user.role) {
            "ADMIN" -> listOf(
                "? Neogranièene rute",
                "? Neogranièene taèke",
                "? Sve vrste mapa",
                "? Offline mape",
                "? Napredni eksport",
                "? Cloud backup",
                "?? Administratorske privilegije"
            )
            "PREMIUM" -> listOf(
                "? Neogranièene rute",
                "? Neogranièene taèke",
                "? Sve vrste mapa",
                "? Offline mape",
                "? Napredni eksport",
                "? Cloud backup"
            )
            else -> listOf(
                "? Do 3 rute dnevno",
                "? Do 10 taèaka",
                "? Osnovne mape",
                "? Offline mape",
                "? Napredni eksport",
                "? Cloud backup",
                "?? Nadogradi na Premium za više!"
            )
        }
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\utils\NotificationHelper.kt

package jovannedeljkovic.gps_tracker_pro.utils

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.core.app.NotificationCompat
import jovannedeljkovic.gps_tracker_pro.R
import jovannedeljkovic.gps_tracker_pro.ui.main.MainActivity

class NotificationHelper(private val context: Context) {

    companion object {
        const val CHANNEL_ID = "gps_tracker_channel"
        const val TRACKING_NOTIFICATION_ID = 1
        const val POINT_NOTIFICATION_ID = 2
        const val EXPORT_NOTIFICATION_ID = 3
    }

    private val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

    init {
        createNotificationChannel()
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "GPS Tracker Notifications",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Obaveštenja za praæenje lokacije i GPS funkcionalnosti"
                setShowBadge(true)
                lockscreenVisibility = Notification.VISIBILITY_PUBLIC
                enableVibration(true)
                enableLights(true)
                lightColor = context.getColor(R.color.blue_primary)
            }
            notificationManager.createNotificationChannel(channel)
        }
    }

    fun createTrackingNotification(distance: String, speed: String): Notification {
        val intent = Intent(context, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            context,
            0,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle("GPS Tracker - Aktivno praæenje")
            .setContentText("Udaljenost: $distance • Brzina: $speed")
            .setSmallIcon(R.drawable.ic_notification_gps)
            .setColor(context.getColor(R.color.blue_primary))
            .setContentIntent(pendingIntent)
            .setOngoing(true)
            .setOnlyAlertOnce(true)
            .setAutoCancel(false)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .setVibrate(longArrayOf(100, 200, 100))
            .build()
    }

    fun createPointAddedNotification(pointName: String): Notification {
        val intent = Intent(context, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            context,
            1,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle("Nova taèka dodata")
            .setContentText("Taèka: $pointName")
            .setSmallIcon(R.drawable.ic_notification_point)
            .setColor(context.getColor(R.color.blue_primary))
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setVibrate(longArrayOf(100, 100))
            .build()
    }

    fun createExportSuccessNotification(fileName: String): Notification {
        val intent = Intent(context, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            context,
            2,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle("Eksport uspešan")
            .setContentText("Fajl: $fileName")
            .setSmallIcon(R.drawable.ic_notification_export)
            .setColor(context.getColor(R.color.green_active))
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setVibrate(longArrayOf(100, 100, 100))
            .build()
    }

    // OSNOVNE METODE
    fun showTrackingNotification(distance: String, speed: String) {
        val notification = createTrackingNotification(distance, speed)
        notificationManager.notify(TRACKING_NOTIFICATION_ID, notification)
    }
// Dodaj ove metode u NotificationHelper klasu

    fun createPointRenamedNotification(oldName: String, newName: String): Notification {
        val intent = Intent(context, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            context,
            4, // Novi request code
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle("Taèka preimenovana")
            .setContentText("$oldName › $newName")
            .setSmallIcon(R.drawable.ic_notification_point)
            .setColor(context.getColor(R.color.blue_primary))
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setVibrate(longArrayOf(100, 100))
            .build()
    }

    fun showPointRenamed(oldName: String, newName: String) {
        val notification = createPointRenamedNotification(oldName, newName)
        notificationManager.notify(POINT_NOTIFICATION_ID, notification)
    }
    fun updateTrackingNotification(distance: String, speed: String) {
        showTrackingNotification(distance, speed)
    }

    fun showPointAdded(pointName: String) {
        val notification = createPointAddedNotification(pointName)
        notificationManager.notify(POINT_NOTIFICATION_ID, notification)
    }

    fun showExportSuccess(fileName: String) {
        val notification = createExportSuccessNotification(fileName)
        notificationManager.notify(EXPORT_NOTIFICATION_ID, notification)
    }

    fun cancelTrackingNotification() {
        notificationManager.cancel(TRACKING_NOTIFICATION_ID)
    }

    fun cancelAllNotifications() {
        notificationManager.cancel(TRACKING_NOTIFICATION_ID)
        notificationManager.cancel(POINT_NOTIFICATION_ID)
        notificationManager.cancel(EXPORT_NOTIFICATION_ID)
    }
    // Dodaj ove metode u NotificationHelper klasu
    fun createBulkDeleteNotification(count: Int): Notification {
        val intent = Intent(context, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            context,
            5,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle("Rute obrisane")
            .setContentText("Obrisano $count ruta")
            .setSmallIcon(R.drawable.ic_notification_point)
            .setColor(context.getColor(R.color.accent_red))
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .build()
    }

    fun createAllRoutesDeletedNotification(count: Int): Notification {
        val intent = Intent(context, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            context,
            6,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle("Sve rute obrisane")
            .setContentText("Obrisano svih $count ruta")
            .setSmallIcon(R.drawable.ic_notification_point)
            .setColor(context.getColor(R.color.accent_red))
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .build()
    }

    fun showBulkDeleteSuccess(count: Int) {
        val notification = createBulkDeleteNotification(count)
        notificationManager.notify(EXPORT_NOTIFICATION_ID, notification)
    }

    fun showAllRoutesDeleted(count: Int) {
        val notification = createAllRoutesDeletedNotification(count)
        notificationManager.notify(EXPORT_NOTIFICATION_ID, notification)
    }
}


FILE: app\src\main\java\jovannedeljkovic\gps_tracker_pro\utils\PasswordHasher.kt

package jovannedeljkovic.gps_tracker_pro.utils

import java.security.MessageDigest

object PasswordHasher {
    fun hashPassword(password: String): String {
        val bytes = password.toByteArray()
        val md = MessageDigest.getInstance("SHA-256")
        val digest = md.digest(bytes)
        return digest.fold("") { str, it -> str + "%02x".format(it) }
    }
}


FILE: app\src\main\res\anim\slide_in_bottom.xml

<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="300">
    <translate
        android:fromYDelta="100%"
        android:toYDelta="0%" />
    <alpha
        android:fromAlpha="0.0"
        android:toAlpha="1.0" />
</set>


FILE: app\src\main\res\anim\slide_out_bottom.xml

<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="300">
    <translate
        android:fromYDelta="0%"
        android:toYDelta="100%" />
    <alpha
        android:fromAlpha="1.0"
        android:toAlpha="0.0" />
</set>


FILE: app\src\main\res\drawable\btn_icar_accent.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <gradient
        android:startColor="#FF3498DB"
        android:endColor="#FF2980B9"
        android:angle="45" />
    <corners android:radius="12dp" />
    <stroke
        android:width="1dp"
        android:color="#FF3498DB" />
</shape>


FILE: app\src\main\res\drawable\btn_icar_green.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <gradient
        android:startColor="#FF27AE60"
        android:endColor="#FF229954"
        android:angle="45" />
    <corners android:radius="12dp" />
</shape>


FILE: app\src\main\res\drawable\btn_icar_primary.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <gradient
        android:startColor="#FF2C3E50"
        android:endColor="#FF34495E"
        android:angle="45" />
    <corners android:radius="12dp" />
    <stroke
        android:width="1dp"
        android:color="#FF2C3E50" />
</shape>


FILE: app\src\main\res\drawable\btn_icar_red.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <gradient
        android:startColor="#FFE74C3C"
        android:endColor="#FFC0392B"
        android:angle="45" />
    <corners android:radius="12dp" />
</shape>


FILE: app\src\main\res\drawable\button_blue_round.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="#FF2196F3" />
</shape>


FILE: app\src\main\res\drawable\button_blue_rounded.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/blue_primary" />
    <corners android:radius="18dp" />
</shape>


FILE: app\src\main\res\drawable\button_dark_blue.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/primary_dark" />
    <corners android:radius="12dp" />
    <stroke
        android:width="1dp"
        android:color="@color/primary_medium" />
</shape>


FILE: app\src\main\res\drawable\button_dark_blue_accent.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/accent_green" />
    <corners android:radius="12dp" />
</shape>


FILE: app\src\main\res\drawable\button_green_round.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="#FF4CAF50" />
</shape>


FILE: app\src\main\res\drawable\button_icar_accent.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <gradient
        android:startColor="#FF4CAF50"
        android:endColor="#FF45a049"
        android:angle="45" />
    <corners android:radius="12dp" />
</shape>


FILE: app\src\main\res\drawable\button_icar_primary.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/primary_dark" />
    <corners android:radius="12dp" />
    <stroke
        android:width="1dp"
        android:color="#FF404040" />
</shape>


FILE: app\src\main\res\drawable\button_menu_accent.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#FFFFFF" /> <!-- ?? BELA POZADINA -->
    <corners android:radius="8dp" />
    <stroke
        android:width="2dp"
        android:color="#3F51B5" /> <!-- ?? PLAVA BORDA -->
</shape>


FILE: app\src\main\res\drawable\button_modern.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#80000000" />
    <corners android:radius="28dp" />
    <stroke
        android:width="1dp"
        android:color="#60FFFFFF" />
</shape>


FILE: app\src\main\res\drawable\button_modern_accent.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#FF2196F3" />
    <corners android:radius="28dp" />
    <stroke
        android:width="1dp"
        android:color="#FF1976D2" />
</shape>


FILE: app\src\main\res\drawable\button_modern_green.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#FF4CAF50" />
    <corners android:radius="12dp" />
</shape>


FILE: app\src\main\res\drawable\button_modern_red.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#FFF44336" />
    <corners android:radius="12dp" />
</shape>


FILE: app\src\main\res\drawable\button_red_round.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="#FFF44336" />
</shape>


FILE: app\src\main\res\drawable\button_rounded_rectangle.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <corners
        android:radius="20dp" />

    <solid
        android:color="#4CAF50" />

    <padding
        android:left="16dp"
        android:top="8dp"
        android:right="16dp"
        android:bottom="8dp" />
</shape>


FILE: app\src\main\res\drawable\button_rounded_rectangle_pressed.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <corners
        android:radius="20dp" />

    <solid
        android:color="#388E3C" /> <!-- Tamnija zelena -->

    <padding
        android:left="16dp"
        android:top="8dp"
        android:right="16dp"
        android:bottom="8dp" />
</shape>


FILE: app\src\main\res\drawable\button_rounded_rectangle_selector.xml

<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:drawable="@drawable/button_rounded_rectangle_pressed"
        android:state_pressed="true" />

    <item android:drawable="@drawable/button_rounded_rectangle" />

</selector>


FILE: app\src\main\res\drawable\button_tracking_all.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="#FFFF9800" />
    <corners android:radius="30dp" />
    <stroke
        android:width="2dp"
        android:color="#FFFFFF" />
</shape>


FILE: app\src\main\res\drawable\button_tracking_self.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="#FF4CAF50" />
    <corners android:radius="30dp" />
    <stroke
        android:width="2dp"
        android:color="#FFFFFF" />
</shape>


FILE: app\src\main\res\drawable\button_transparent_round.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="#40000000" />
    <stroke
        android:width="1dp"
        android:color="#60FFFFFF" />
</shape>


FILE: app\src\main\res\drawable\button_zoom.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="#CC000000" />
    <corners android:radius="8dp" />
    <stroke
        android:width="1dp"
        android:color="#60FFFFFF" />
</shape>


FILE: app\src\main\res\drawable\card_dark_blue.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/card_dark" />
    <corners android:radius="16dp" />
</shape>


FILE: app\src\main\res\drawable\compass_background.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="#E6101E2E" />
    <stroke
        android:width="1dp"
        android:color="#80FFFFFF" />
    <padding
        android:left="8dp"
        android:top="8dp"
        android:right="8dp"
        android:bottom="8dp" />
</shape>


FILE: app\src\main\res\drawable\compass_dial.xml

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="60dp"
    android:height="60dp"
    android:viewportWidth="60"
    android:viewportHeight="60">

    <!-- Krug - ISPRAVLJEN FORMAT -->
    <path
        android:strokeWidth="2"
        android:strokeColor="#80FFFFFF"
        android:fillColor="#E6101E2E"
        android:pathData="M30,30 m -28,0 a 28,28 0 1,1 56,0 a 28,28 0 1,1 -56,0"/>

    <!-- Strelica za sever -->
    <path
        android:strokeWidth="2"
        android:strokeColor="#FF4CAF50"
        android:pathData="M30,5 L30,15 M27,12 L30,5 L33,12"/>

</vector>


FILE: app\src\main\res\drawable\compass_needle.xml

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="40dp"
    android:height="40dp"
    android:viewportWidth="40"
    android:viewportHeight="40">

    <!-- Crvena igla -->
    <path
        android:fillColor="#FFFF5252"
        android:pathData="M20,2 L24,38 L20,32 L16,38 Z"/>

    <!-- Centar igle -->
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M20,20 m -3,0 a 3,3 0 1,1 6,0 a 3,3 0 1,1 -6,0"/>

</vector>


FILE: app\src\main\res\drawable\dialog_background_modern.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/primary_darker" />
    <corners android:radius="16dp" />
    <stroke
        android:width="1dp"
        android:color="#40FFFFFF" />
</shape>


FILE: app\src\main\res\drawable\dialog_tracking_background.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#E0F5F5F5" />
    <corners android:radius="12dp" />
    <stroke
        android:width="1dp"
        android:color="#80CCCCCC" />
</shape>


FILE: app\src\main\res\drawable\dialog_tracking_modern.xml

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="260dp"
    android:layout_height="wrap_content"
    android:layout_gravity="center"
    android:orientation="vertical"
    android:padding="12dp"
    android:background="@drawable/dialog_tracking_background"
    android:elevation="8dp">

    <!-- Progress Bar -->
    <ProgressBar
        android:id="@+id/progressBar"
        style="?android:attr/progressBarStyleHorizontal"
        android:layout_width="match_parent"
        android:layout_height="4dp"
        android:layout_marginBottom="12dp"
        android:indeterminate="true" />

    <!-- Tracking Info Row -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:layout_marginBottom="4dp">

        <!-- Vreme -->
        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="VREME"
                android:textSize="10sp"
                android:textColor="#80666666"
                android:textStyle="bold" />

            <TextView
                android:id="@+id/tvDialogTime"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="00:00"
                android:textSize="16sp"
                android:textColor="#FF333333"
                android:textStyle="bold" />
        </LinearLayout>

        <!-- Udaljenost -->
        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="UDALJENOST"
                android:textSize="10sp"
                android:textColor="#80666666"
                android:textStyle="bold" />

            <TextView
                android:id="@+id/tvDialogDistance"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="0 m"
                android:textSize="16sp"
                android:textColor="#FF333333"
                android:textStyle="bold" />
        </LinearLayout>

        <!-- Brzina -->
        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="BRZINA"
                android:textSize="10sp"
                android:textColor="#80666666"
                android:textStyle="bold" />

            <TextView
                android:id="@+id/tvDialogSpeed"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="0.0 km/h"
                android:textSize="16sp"
                android:textColor="#FF333333"
                android:textStyle="bold" />
        </LinearLayout>
    </LinearLayout>

    <!-- Status -->
    <TextView
        android:id="@+id/tvStatus"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Tražim GPS signal..."
        android:textSize="12sp"
        android:textColor="#FF333333"
        android:gravity="center"
        android:layout_marginTop="4dp" />

</LinearLayout>


FILE: app\src\main\res\drawable\icar_zoom_panel.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#40000000" />
    <corners android:radius="22dp" />
    <stroke
        android:width="1dp"
        android:color="#60FFFFFF" />
</shape>


FILE: app\src\main\res\drawable\ic_add_white.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M19,13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
</vector>


FILE: app\src\main\res\drawable\ic_compass_white.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2A10,10 0,0 0,2 12A10,10 0,0 0,12 22A10,10 0,0 0,22 12A10,10 0,0 0,12 2M12,4A8,8 0,0 1,20 12A8,8 0,0 1,12 20A8,8 0,0 1,4 12A8,8 0,0 1,12 4M12,6A6,6 0,0 0,6 12A6,6 0,0 0,12 18A6,6 0,0 0,18 12A6,6 0,0 0,12 6Z"/>
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,8L14.67,10.67L12,13.34L9.33,10.67L12,8Z"/>
</vector>


FILE: app\src\main\res\drawable\ic_export.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M19,12v7L5,19L5,5h7V3L5,3c-1.11,0 -2,0.9 -2,2v14c0,1.1 0.89,2 2,2h14c1.1,0 2,-0.9 2,-2v-7h-2zM14,3v2h3.59l-9.83,9.83 1.41,1.41L19,6.41V10h2V3h-7z"/>
</vector>


FILE: app\src\main\res\drawable\ic_google_maps.xml

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2C8.13,2 5,5.13 5,9c0,5.25 7,13 7,13s7,-7.75 7,-13c0,-3.87 -3.13,-7 -7,-7zM12,11.5c-1.38,0 -2.5,-1.12 -2.5,-2.5s1.12,-2.5 2.5,-2.5 2.5,1.12 2.5,2.5 -1.12,2.5 -2.5,2.5z"/>
</vector>


FILE: app\src\main\res\drawable\ic_gps_animated.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="64dp"
    android:height="64dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#3498DB">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,8c-2.21,0 -4,1.79 -4,4s1.79,4 4,4 4,-1.79 4,-4 -1.79,-4 -4,-4zM20.94,11c-0.46,-4.17 -3.77,-7.48 -7.94,-7.94V1h-2v2.06C6.83,3.52 3.52,6.83 3.06,11H1v2h2.06c0.46,4.17 3.77,7.48 7.94,7.94V23h2v-2.06c4.17,-0.46 7.48,-3.77 7.94,-7.94H23v-2h-2.06zM12,19c-3.87,0 -7,-3.13 -7,-7s3.13,-7 7,-7 7,3.13 7,7 -3.13,7 -7,7z"/>
</vector>


FILE: app\src\main\res\drawable\ic_gps_fixed.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#3498DB">
    <group android:name="rotationGroup"
        android:pivotX="12"
        android:pivotY="12">
        <path
            android:fillColor="@android:color/white"
            android:pathData="M12,8c-2.21,0 -4,1.79 -4,4s1.79,4 4,4 4,-1.79 4,-4 -1.79,-4 -4,-4zM20.94,11c-0.46,-4.17 -3.77,-7.48 -7.94,-7.94V1h-2v2.06C6.83,3.52 3.52,6.83 3.06,11H1v2h2.06c0.46,4.17 3.77,7.48 7.94,7.94V23h2v-2.06c4.17,-0.46 7.48,-3.77 7.94,-7.94H23v-2h-2.06zM12,19c-3.87,0 -7,-3.13 -7,-7s3.13,-7 7,-7 7,3.13 7,7 -3.13,7 -7,7z"/>
    </group>
</vector>


FILE: app\src\main\res\drawable\ic_hamburger_modern.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M4,18h16c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1L4,16c-0.55,0 -1,0.45 -1,1s0.45,1 1,1zM4,13h16c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1L4,11c-0.55,0 -1,0.45 -1,1s0.45,1 1,1zM4,6l16,0c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1L4,4c-0.55,0 -1,0.45 -1,1s0.45,1 1,1z"/>
</vector>


FILE: app\src\main\res\drawable\ic_list_white.xml

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M3,13h2v-2H3v2zM3,17h2v-2H3v2zM3,9h2V7H3v2zM7,13h14v-2H7v2zM7,17h14v-2H7v2zM7,7v2h14V7H7z"/>
</vector>


FILE: app\src\main\res\drawable\ic_menu_white.xml

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#3F51B5"> <!-- ?? PLAVA BOJA - VIDLJIVIJA NA ZELENOJ -->

    <!-- GORNJA TAÈKA -->
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,8c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9 -2,2 0.9,2 2,2z"/>

    <!-- SREDNJA TAÈKA -->
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,14c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9 -2,2 0.9,2 2,2z"/>

    <!-- DONJA TAÈKA -->
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,20c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9 -2,2 0.9,2 2,2z"/>
</vector>


FILE: app\src\main\res\drawable\ic_more_vert_white.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">

    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,8c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9 -2,2 0.9,2 2,2zM12,10c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2zM12,16c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2z" />
</vector>


FILE: app\src\main\res\drawable\ic_my_location.xml

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,8c-2.21,0 -4,1.79 -4,4s1.79,4 4,4 4,-1.79 4,-4 -1.79,-4 -4,-4zM20.94,11c-0.46,-4.17 -3.77,-7.48 -7.94,-7.94V1h-2v2.06C6.83,3.52 3.52,6.83 3.06,11H1v2h2.06c0.46,4.17 3.77,7.48 7.94,7.94V23h2v-2.06c4.17,-0.46 7.48,-3.77 7.94,-7.94H23v-2h-2.06zM12,19c-3.87,0 -7,-3.13 -7,-7s3.13,-7 7,-7 7,3.13 7,7 -3.13,7 -7,7z"/>
</vector>


FILE: app\src\main\res\drawable\ic_my_location_red.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FF0000">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2C8.13,2 5,5.13 5,9c0,5.25 7,13 7,13s7,-7.75 7,-13c0,-3.87 -3.13,-7 -7,-7zM12,11.5c-1.38,0 -2.5,-1.12 -2.5,-2.5s1.12,-2.5 2.5,-2.5 2.5,1.12 2.5,2.5 -1.12,2.5 -2.5,2.5z"/>
</vector>


FILE: app\src\main\res\drawable\ic_navigation_arrow.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2L4.5,20.29l0.71,0.71L12,18l6.79,3l0.71,-0.71L12,2z"/>
</vector>


FILE: app\src\main\res\drawable\ic_navigation_line.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#4CAF50">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2L4.5,20.29l0.71,0.71L12,18l6.79,3 0.71,-0.71z"/>
</vector>


FILE: app\src\main\res\drawable\ic_navigation_white.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2L4.5,20.29L5.21,21L12,18L18.79,21L19.5,20.29L12,2Z"/>
</vector>


FILE: app\src\main\res\drawable\ic_notification_export.xml

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M19,12v7L5,19L5,5h7V3L5,3c-1.11,0 -2,0.9 -2,2v14c0,1.1 0.89,2 2,2h14c1.1,0 2,-0.9 2,-2v-7h-2zM14,3v2h3.59l-9.83,9.83 1.41,1.41L19,6.41V10h2V3h-7z"/>
</vector>


FILE: app\src\main\res\drawable\ic_notification_gps.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,8c-2.21,0 -4,1.79 -4,4s1.79,4 4,4 4,-1.79 4,-4 -1.79,-4 -4,-4zM20.94,11c-0.46,-4.17 -3.77,-7.48 -7.94,-7.94V1h-2v2.06C6.83,3.52 3.52,6.83 3.06,11H1v2h2.06c0.46,4.17 3.77,7.48 7.94,7.94V23h2v-2.06c4.17,-0.46 7.48,-3.77 7.94,-7.94H23v-2h-2.06zM12,19c-3.87,0 -7,-3.13 -7,-7s3.13,-7 7,-7 7,3.13 7,7 -3.13,7 -7,7z"/>
</vector>


FILE: app\src\main\res\drawable\ic_notification_point.xml

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2C8.13,2 5,5.13 5,9c0,5.25 7,13 7,13s7,-7.75 7,-13c0,-3.87 -3.13,-7 -7,-7z"/>
</vector>


FILE: app\src\main\res\drawable\ic_play.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M8,5v14l11,-7z"/>
</vector>


FILE: app\src\main\res\drawable\ic_point_blue.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <!-- Crveni pin emoji stil -->
    <path
        android:fillColor="#FF0000"
        android:strokeColor="#8B0000"
        android:strokeWidth="0.5"
        android:pathData="M12,2C8.1,2 5,5.1 5,9c0,5.3 7,13 7,13s7,-7.7 7,-13C19,5.1 15.9,2 12,2z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M12,6c-1.7,0 -3,1.3 -3,3s1.3,3 3,3 3,-1.3 3,-3S13.7,6 12,6z"/>
</vector>


FILE: app\src\main\res\drawable\ic_radar_white.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.42,0 -8,-3.58 -8,-8s3.58,-8 8,-8 8,3.58 8,8 -3.58,8 -8,8zM12,12c0,0 3,1.5 3,4.5c0,1.5 -1.5,3 -3,3s-3,-1.5 -3,-3C9,13.5 12,12 12,12z"/>
</vector>


FILE: app\src\main\res\drawable\ic_refresh_white.xml

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M17.65,6.35C16.2,4.9 14.21,4 12,4c-4.42,0 -7.99,3.58 -7.99,8s3.57,8 7.99,8c3.73,0 6.84,-2.55 7.73,-6h-2.08c-0.82,2.33,-3.04,4,-5.65,4 -3.31,0,-6,-2.69,-6,-6s2.69,-6 6,-6c1.66,0 3.14,0.69 4.22,1.78L13,11h7V4l-2.35,2.35z"/>
</vector>


FILE: app\src\main\res\drawable\ic_remove_white.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M19,13H5v-2h14v2z"/>
</vector>


FILE: app\src\main\res\drawable\ic_reset.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M17.65,6.35C16.2,4.9 14.21,4 12,4c-4.42,0 -7.99,3.58 -7.99,8s3.57,8 7.99,8c3.73,0 6.84,-2.55 7.73,-6h-2.08c-0.82,2.33,-3.04,4,-5.65,4 -3.31,0,-6,-2.69,-6,-6s2.69,-6 6,-6c1.66,0 3.14,0.69 4.22,1.78L13,11h7V4l-2.35,2.35z"/>
</vector>


FILE: app\src\main\res\drawable\ic_satellite.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M19,3L5,3c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2L21,5c0,-1.1 -0.9,-2 -2,-2zM18,6h-5.21c-0.45,0 -0.67,0.54 -0.35,0.85L13.79,9L11.5,9c-0.28,0 -0.5,0.22 -0.5,0.5v0c0,0.28 0.22,0.5 0.5,0.5h2.29l-1.79,1.79c-0.21,0.2 -0.21,0.53 0,0.73l0,0c0.2,0.2 0.52,0.2 0.72,0L16,10.71V13c0,0.28 0.22,0.5 0.5,0.5h0c0.28,0 0.5,-0.22 0.5,-0.5V9.21l1.5,-1.5c0.2,-0.2 0.2,-0.52 0,-0.72l0,0c-0.2,-0.2 -0.52,-0.2 -0.72,0L17,8.21L17,6.5c0,-0.28 -0.22,-0.5 -0.5,-0.5h0C16.28,6 16,6.22 16,6.5zM5,19L5,5h14v14L5,19z"/>
</vector>


FILE: app\src\main\res\drawable\ic_stop.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M6,6h12v12H6z"/>
</vector>


FILE: app\src\main\res\drawable\ic_zoom_in.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M19,13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
</vector>


FILE: app\src\main\res\drawable\ic_zoom_out.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M19,13H5v-2h14v2z"/>
</vector>


FILE: app\src\main\res\drawable\panel_background_modern.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="#CC1E1E1E" />
    <corners android:radius="16dp" />
    <stroke
        android:width="1dp"
        android:color="#33FFFFFF" />
</shape>


FILE: app\src\main\res\drawable\panel_modern.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#E6000000" />
    <corners android:radius="16dp" />
    <stroke
        android:width="1dp"
        android:color="#60FFFFFF" />
</shape>


FILE: app\src\main\res\drawable\panel_transparent_dark.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/transparent_dark" />
    <corners android:radius="16dp" />
</shape>


FILE: app\src\main\res\drawable\rounded_bg_blue.xml

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/primary_blue" />
    <corners android:radius="8dp" />
    <padding
        android:left="8dp"
        android:top="4dp"
        android:right="8dp"
        android:bottom="4dp" />
</shape>


FILE: app\src\main\res\drawable\target.xml

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">

    <!-- Spoljni krug -->
    <group>
        <path
            android:strokeColor="#FFFFFF"
            android:strokeWidth="2"
            android:fillColor="@android:color/transparent"
            android:pathData="M12,4 A8,8 0 1,1 12,20 A8,8 0 1,1 12,4" />
    </group>

    <!-- Unutrašnja taèka -->
    <group>
        <path
            android:fillColor="#FFFFFF"
            android:pathData="M11,12 L13,12 L13,14 L11,14 Z" />
    </group>

    <!-- Unakrsne linije -->
    <group>
        <path
            android:strokeColor="#FFFFFF"
            android:strokeWidth="1"
            android:pathData="M12,6 L12,9 M12,15 L12,18 M6,12 L9,12 M15,12 L18,12" />
    </group>
</vector>


FILE: app\src\main\res\layout\activity_admin.xml

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="@color/primary_dark"
    android:padding="8dp">

    <!-- Toolbar sa akcijama -->
    <com.google.android.material.appbar.MaterialToolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:background="@color/primary_dark"
        android:minHeight="?attr/actionBarSize"
        android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
        app:titleTextColor="@color/white">

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:paddingHorizontal="8dp">

            <!-- Nazad dugme -->
            <Button
                android:id="@+id/btnBack"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_alignParentStart="true"
                android:layout_centerVertical="true"
                android:background="@drawable/button_dark_blue"
                android:minWidth="0dp"
                android:minHeight="0dp"
                android:paddingHorizontal="12dp"
                android:paddingVertical="8dp"
                android:text="?"
                android:textColor="@color/white"
                android:textSize="16sp" />

            <!-- Naslov -->
            <TextView
                android:id="@+id/tvTitle"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_centerInParent="true"
                android:text="?? Admin Panel"
                android:textColor="@color/white"
                android:textSize="18sp"
                android:textStyle="bold" />

            <!-- Refresh dugme -->
            <Button
                android:id="@+id/btnRefresh"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_alignParentEnd="true"
                android:layout_centerVertical="true"
                android:background="@drawable/button_dark_blue"
                android:minWidth="0dp"
                android:minHeight="0dp"
                android:paddingHorizontal="12dp"
                android:paddingVertical="8dp"
                android:text="??"
                android:textColor="@color/white"
                android:textSize="16sp" />

        </RelativeLayout>
    </com.google.android.material.appbar.MaterialToolbar>

    <!-- Statistika dugme ispod toolbara -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:layout_marginTop="8dp"
        android:layout_marginBottom="16dp"
        android:paddingHorizontal="16dp">

        <Button
            android:id="@+id/btnStatistics"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginEnd="8dp"
            android:background="@drawable/button_dark_blue"
            android:paddingHorizontal="16dp"
            android:paddingVertical="12dp"
            android:text="?? Statistika"
            android:textColor="@color/white"
            android:textSize="14sp" />

        <TextView
            android:id="@+id/tvUserCount"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:background="@drawable/rounded_bg_blue"
            android:paddingHorizontal="16dp"
            android:paddingVertical="12dp"
            android:text="?? 0 korisnika"
            android:textColor="@color/white"
            android:textSize="14sp" />

    </LinearLayout>

    <!-- Users List -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/rvUsers"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:layout_marginTop="8dp"
        android:background="@color/white"
        android:padding="4dp" />

</LinearLayout>


FILE: app\src\main\res\layout\activity_login.xml

<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="24dp"
    android:background="@color/blue_light_background">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

         // -- Header -->
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Prijava"
            android:textSize="28sp"
            android:textStyle="bold"
            android:textColor="@color/blue_dark"
            android:gravity="center"
            android:layout_marginBottom="32dp"
            android:layout_marginTop="20dp" />

         // -- Email -->
        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            app:boxBackgroundMode="outline"
            app:boxCornerRadiusBottomEnd="12dp"
            app:boxCornerRadiusBottomStart="12dp"
            app:boxCornerRadiusTopEnd="12dp"
            app:boxCornerRadiusTopStart="12dp"
            app:boxBackgroundColor="@android:color/white">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etEmail"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Email"
                android:inputType="textEmailAddress" />

        </com.google.android.material.textfield.TextInputLayout>

         // -- Lozinka -->
        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="24dp"
            app:boxBackgroundMode="outline"
            app:boxCornerRadiusBottomEnd="12dp"
            app:boxCornerRadiusBottomStart="12dp"
            app:boxCornerRadiusTopEnd="12dp"
            app:boxCornerRadiusTopStart="12dp"
            app:boxBackgroundColor="@android:color/white">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etPassword"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Lozinka"
                android:inputType="textPassword" />

        </com.google.android.material.textfield.TextInputLayout>

        // -- Zaboravljena lozinka -->
        <TextView
            android:id="@+id/tvForgotPassword"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Zaboravljena lozinka?"
            android:textSize="14sp"
            android:gravity="end"
            android:textColor="@color/blue_dark"
            android:layout_marginBottom="32dp"
            android:clickable="true"
            android:focusable="true" />

        // -- Login dugme -->
        <Button
            android:id="@+id/btnLogin"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Prijavi se"
            android:textSize="16sp"
            android:textStyle="bold"
            android:background="@drawable/button_blue_rounded"
            android:textColor="@android:color/white"
            android:layout_marginBottom="24dp" />

        <!-- Registracija link -->
        <TextView
            android:id="@+id/tvRegisterLink"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Nemate nalog? Registrujte se"
            android:textSize="14sp"
            android:gravity="center"
            android:textColor="@color/blue_dark"
            android:clickable="true"
            android:focusable="true" />

    </LinearLayout>

</ScrollView>


FILE: app\src\main\res\layout\activity_main.xml

<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/primary_darker">

    <!-- Map View -->
    <org.osmdroid.views.MapView
        android:id="@+id/mapView"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <!-- Modern Tracking Panel -->
    <androidx.cardview.widget.CardView
        android:id="@+id/trackingPanel"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:layout_alignParentTop="true"
        android:layout_marginTop="16dp"
        android:visibility="gone"
        app:cardBackgroundColor="#E6101E2E"
        app:cardCornerRadius="20dp"
        app:cardElevation="8dp"
        app:contentPadding="8dp">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <!-- Header -->
            <TextView
                android:id="@+id/tvUserRole"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="?? BASIC"
                android:textColor="@color/blue_primary"
                android:textSize="12sp"
                android:visibility="gone"
                android:padding="4dp"
                android:background="@drawable/button_dark_blue"
                android:layout_margin="4dp" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="?? Snimanje Aktivno"
                android:textColor="#FF4CAF50"
                android:textSize="16sp"
                android:textStyle="bold"
                android:gravity="center"
                android:layout_marginBottom="12dp" />

            <View
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:background="#334CAF50"
                android:layout_marginBottom="12dp" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:weightSum="3">

                <!-- Brzina -->
                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:orientation="vertical"
                    android:gravity="center"
                    android:padding="8dp">

                    <TextView
                        android:id="@+id/tvSpeed"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="0.0"
                        android:textColor="#FFFFFF"
                        android:textSize="24sp"
                        android:textStyle="bold" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="km/h"
                        android:textColor="#88FFFFFF"
                        android:textSize="10sp" />

                </LinearLayout>

                <!-- Udaljenost -->
                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:orientation="vertical"
                    android:gravity="center"
                    android:padding="8dp">

                    <TextView
                        android:id="@+id/tvDistance"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="0.0 m"
                        android:textColor="#FFFFFF"
                        android:textSize="20sp"
                        android:textStyle="bold" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Udaljenost"
                        android:textColor="#88FFFFFF"
                        android:textSize="10sp" />

                </LinearLayout>

                <!-- Vreme -->
                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:orientation="vertical"
                    android:gravity="center"
                    android:padding="8dp">

                    <TextView
                        android:id="@+id/tvTime"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="00:00"
                        android:textColor="#FFFFFF"
                        android:textSize="20sp"
                        android:textStyle="bold" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Vreme"
                        android:textColor="#88FFFFFF"
                        android:textSize="10sp" />

                </LinearLayout>

            </LinearLayout>

            <!-- Progress bar za taènost -->
            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:layout_marginTop="8dp"
                android:padding="4dp">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Taènost:"
                    android:textColor="#88FFFFFF"
                    android:textSize="10sp" />

                <ProgressBar
                    android:id="@+id/accuracyProgress"
                    android:layout_width="0dp"
                    android:layout_height="4dp"
                    android:layout_weight="1"
                    android:layout_marginStart="8dp"
                    android:progress="100"
                    android:progressTint="#FF4CAF50"
                    style="?android:attr/progressBarStyleHorizontal" />

                <TextView
                    android:id="@+id/tvAccuracy"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Odlièno"
                    android:textColor="#88FFFFFF"
                    android:textSize="10sp"
                    android:layout_marginStart="8dp" />

            </LinearLayout>

        </LinearLayout>

    </androidx.cardview.widget.CardView>

    <!-- iCar Style Zoom Controls (Desna strana) -->
    <LinearLayout
        android:layout_width="44dp"
        android:layout_height="wrap_content"
        android:layout_alignParentEnd="true"
        android:layout_centerVertical="true"
        android:layout_marginEnd="12dp"
        android:orientation="vertical"
        android:background="@drawable/icar_zoom_panel"
        android:elevation="8dp">

        <!-- Zoom In -->
        <ImageButton
            android:id="@+id/btnZoomIn"
            android:layout_width="44dp"
            android:layout_height="44dp"
            android:background="@drawable/button_transparent_round"
            android:padding="10dp"
            android:src="@drawable/ic_zoom_in" />

        <!-- Divider -->
        <View
            android:layout_width="32dp"
            android:layout_height="1dp"
            android:background="#40FFFFFF"
            android:layout_gravity="center_horizontal" />

        <!-- Zoom Out -->
        <ImageButton
            android:id="@+id/btnZoomOut"
            android:layout_width="44dp"
            android:layout_height="44dp"
            android:background="@drawable/button_transparent_round"
            android:padding="10dp"
            android:src="@drawable/ic_zoom_out" />

        <!-- Compass Needle - ispod Zoom Out -->
        <ImageView
            android:id="@+id/compassNeedle"
            android:layout_width="40dp"
            android:layout_height="40dp"
            android:layout_marginTop="4dp"
            android:src="@drawable/compass_needle"
            android:visibility="gone"
            android:elevation="13dp" />

    </LinearLayout>

    <!-- Kompas -->
    <ImageButton
        android:id="@+id/btnCompass"
        android:layout_width="44dp"
        android:layout_height="44dp"
        android:layout_alignParentTop="true"
        android:layout_alignParentEnd="true"
        android:layout_marginTop="70dp"
        android:layout_marginEnd="12dp"
        android:background="@drawable/compass_background"
        android:src="@drawable/ic_compass_white"
        android:visibility="gone"
        android:elevation="8dp" />

    <!-- Dugme "Samo sebe" u donjem levom uglu -->
    <Button
        android:id="@+id/btnTrackingMode"
        android:layout_width="wrap_content"
        android:layout_height="32dp"
        android:layout_alignParentBottom="true"
        android:layout_alignParentStart="true"
        android:layout_marginStart="10dp"
        android:layout_marginBottom="10dp"
        android:background="@drawable/button_rounded_rectangle"
        android:text="?? Pratim sebe"
        android:textColor="#FFFFFF"
        android:textSize="11sp"
        android:paddingStart="10dp"
        android:paddingEnd="10dp" />

    <!-- Bottom Action Bar -->
    <RelativeLayout
        android:id="@+id/bottomActionBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_marginBottom="12dp"
        android:paddingHorizontal="16dp">

        <!-- Play i Stop dugmad u centru -->
        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:orientation="horizontal">

            <!-- Start Tracking -->
            <ImageButton
                android:id="@+id/btnStartTracking"
                android:layout_width="56dp"
                android:layout_height="56dp"
                android:background="@drawable/button_green_round"
                android:padding="14dp"
                android:src="@drawable/ic_play"
                android:layout_marginEnd="12dp"
                android:elevation="4dp" />

            <!-- Stop Tracking -->
            <ImageButton
                android:id="@+id/btnStopTracking"
                android:layout_width="56dp"
                android:layout_height="56dp"
                android:background="@drawable/button_red_round"
                android:padding="14dp"
                android:src="@drawable/ic_stop"
                android:elevation="4dp"
                android:enabled="false" />

        </LinearLayout>

        <!-- Saved Routes Button - desna strana -->
        <ImageButton
            android:id="@+id/btnSavedRoutes"
            android:layout_width="40dp"
            android:layout_height="40dp"
            android:layout_alignParentEnd="true"
            android:layout_centerVertical="true"
            android:background="@drawable/button_transparent_round"
            android:padding="8dp"
            android:src="@drawable/ic_list_white" />

    </RelativeLayout>

    <!-- Menu Button - gornji desni ugao -->
    <ImageButton
        android:id="@+id/btnMenu"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_alignParentTop="true"
        android:layout_alignParentEnd="true"
        android:layout_marginTop="12dp"
        android:layout_marginEnd="12dp"
        android:src="@drawable/ic_more_vert_white"
        android:background="@drawable/button_transparent_round"
        android:contentDescription="Navigacioni meni"
        android:padding="8dp" />

    <!-- Dostupni tipovi mape - gornji desni ugao ispod menija -->
    <ImageButton
        android:id="@+id/btnMapType"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_below="@+id/btnMenu"
        android:layout_alignParentEnd="true"
        android:layout_marginTop="8dp"
        android:layout_marginEnd="12dp"
        android:background="@drawable/button_transparent_round"
        android:padding="8dp"
        android:src="@drawable/ic_satellite"
        android:contentDescription="Tip mape" />

    <!-- Google mape - gornji desni ugao ispod tipova mape -->
    <ImageButton
        android:id="@+id/btnNavigation"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_below="@+id/btnMapType"
        android:layout_alignParentEnd="true"
        android:layout_marginTop="8dp"
        android:layout_marginEnd="12dp"
        android:background="@drawable/button_transparent_round"
        android:padding="8dp"
        android:src="@drawable/ic_google_maps"
        android:contentDescription="Google mape" />

    <!-- My Location Button -->
    <ImageButton
        android:id="@+id/btnMyLocation"
        android:layout_width="44dp"
        android:layout_height="44dp"
        android:layout_above="@+id/bottomActionBar"
        android:layout_alignParentEnd="true"
        android:layout_marginEnd="12dp"
        android:layout_marginBottom="12dp"
        android:background="@drawable/button_transparent_round"
        android:src="@drawable/ic_gps_fixed"
        android:padding="10dp"
        app:tint="#FFFFFF"
        android:contentDescription="Moja lokacija"
        android:elevation="6dp" />

    <!-- Add Point FAB - zamenjen sa ikonom ciodom -->
    <ImageButton
        android:id="@+id/fabAddPoint"
        android:layout_width="44dp"
        android:layout_height="44dp"
        android:layout_above="@+id/btnMyLocation"
        android:layout_alignParentEnd="true"
        android:layout_marginEnd="12dp"
        android:layout_marginBottom="8dp"
        android:background="@drawable/button_transparent_round"
        android:src="@drawable/ic_my_location_red"
        android:scaleType="center"
        android:contentDescription="Dodaj taèku"
        android:elevation="6dp" />

    <!-- Map Orientation, Follow Location, Export & Reset Buttons (Leva strana) -->
    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentStart="true"
        android:layout_above="@+id/bottomActionBar"
        android:layout_marginStart="12dp"
        android:layout_marginBottom="12dp"
        android:orientation="vertical">

        <!-- Map Orientation Button (North/Follow) - promenjena ikona -->
        <ImageButton
            android:id="@+id/btnMapOrientation"
            android:layout_width="44dp"
            android:layout_height="44dp"
            android:background="@drawable/button_transparent_round"
            android:padding="10dp"
            android:src="@drawable/ic_navigation_arrow"
            android:layout_marginBottom="8dp"
            android:contentDescription="Smer mape" />

        <!-- Follow Location Button (Auto-follow On/Off) - promenjena ikona -->
        <ImageButton
            android:id="@+id/btnFollowLocation"
            android:layout_width="44dp"
            android:layout_height="44dp"
            android:background="@drawable/button_transparent_round"
            android:padding="10dp"
            android:src="@drawable/ic_radar_white"
            android:layout_marginBottom="8dp"
            android:contentDescription="Auto praæenje" />

        <!-- Export Button -->
        <ImageButton
            android:id="@+id/btnExport"
            android:layout_width="44dp"
            android:layout_height="44dp"
            android:background="@drawable/button_transparent_round"
            android:padding="10dp"
            android:src="@drawable/ic_export"
            android:layout_marginBottom="8dp" />

        <!-- Reset Button -->
        <ImageButton
            android:id="@+id/btnReset"
            android:layout_width="44dp"
            android:layout_height="44dp"
            android:background="@drawable/button_transparent_round"
            android:padding="10dp"
            android:src="@drawable/ic_reset" />

        <!-- Debug Button - sakriven po defaultu -->
        <ImageButton
            android:id="@+id/btnDebug"
            android:layout_width="44dp"
            android:layout_height="44dp"
            android:background="@drawable/button_transparent_round"
            android:padding="10dp"
            android:src="@drawable/ic_radar_white"
            android:visibility="gone" />

    </LinearLayout>

</RelativeLayout>


FILE: app\src\main\res\layout\activity_register.xml

<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="24dp"
    android:background="@color/blue_light_background">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        // Header
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Registracija"
            android:textSize="28sp"
            android:textStyle="bold"
            android:textColor="@color/blue_dark"
            android:gravity="center"
            android:layout_marginBottom="32dp"
            android:layout_marginTop="20dp" />

        // -- Ime -->
        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            app:boxBackgroundMode="outline"
            app:boxCornerRadiusBottomEnd="12dp"
            app:boxCornerRadiusBottomStart="12dp"
            app:boxCornerRadiusTopEnd="12dp"
            app:boxCornerRadiusTopStart="12dp"
            app:boxBackgroundColor="@android:color/white">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etName"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Ime i prezime"
                android:inputType="textPersonName" />

        </com.google.android.material.textfield.TextInputLayout>

        // -- Email -->
        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            app:boxBackgroundMode="outline"
            app:boxCornerRadiusBottomEnd="12dp"
            app:boxCornerRadiusBottomStart="12dp"
            app:boxCornerRadiusTopEnd="12dp"
            app:boxCornerRadiusTopStart="12dp"
            app:boxBackgroundColor="@android:color/white">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etEmail"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Email"
                android:inputType="textEmailAddress" />

        </com.google.android.material.textfield.TextInputLayout>

        // -- Broj telefona -->
        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            app:boxBackgroundMode="outline"
            app:boxCornerRadiusBottomEnd="12dp"
            app:boxCornerRadiusBottomStart="12dp"
            app:boxCornerRadiusTopEnd="12dp"
            app:boxCornerRadiusTopStart="12dp"
            app:boxBackgroundColor="@android:color/white">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etPhone"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Broj telefona (opciono)"
                android:inputType="phone" />

        </com.google.android.material.textfield.TextInputLayout>

        // -- Lozinka -->
        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            app:boxBackgroundMode="outline"
            app:boxCornerRadiusBottomEnd="12dp"
            app:boxCornerRadiusBottomStart="12dp"
            app:boxCornerRadiusTopEnd="12dp"
            app:boxCornerRadiusTopStart="12dp"
            app:boxBackgroundColor="@android:color/white">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etPassword"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Lozinka"
                android:inputType="textPassword" />

        </com.google.android.material.textfield.TextInputLayout>

        //
        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="32dp"
            app:boxBackgroundMode="outline"
            app:boxCornerRadiusBottomEnd="12dp"
            app:boxCornerRadiusBottomStart="12dp"
            app:boxCornerRadiusTopEnd="12dp"
            app:boxCornerRadiusTopStart="12dp"
            app:boxBackgroundColor="@android:color/white">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etConfirmPassword"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Potvrdi lozinku"
                android:inputType="textPassword" />

        </com.google.android.material.textfield.TextInputLayout>

        //
        <Button
            android:id="@+id/btnRegister"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Registruj se"
            android:textSize="16sp"
            android:textStyle="bold"
            android:background="@drawable/button_blue_rounded"
            android:textColor="@android:color/white"
            android:layout_marginBottom="24dp" />

        //
        <TextView
            android:id="@+id/tvLoginLink"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Veæ imate nalog? Prijavite se"
            android:textSize="14sp"
            android:gravity="center"
            android:textColor="@color/blue_dark"
            android:clickable="true"
            android:focusable="true" />
    </LinearLayout>

</ScrollView>


FILE: app\src\main\res\layout\custom_toast.xml

<?xml version="1.0" encoding="utf-8"?>
<androidx.cardview.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:cardBackgroundColor="#FF4CAF50"
    app:cardCornerRadius="20dp"
    app:cardElevation="8dp">

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp"
        android:gravity="center">

        <ImageView
            android:layout_width="20dp"
            android:layout_height="20dp"
            android:src="@drawable/ic_notification_gps"
            android:tint="#FFFFFF" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="?? Snimanje aktivno!"
            android:textColor="#FFFFFF"
            android:textSize="14sp"
            android:textStyle="bold"
            android:layout_marginStart="8dp" />

    </LinearLayout>

</androidx.cardview.widget.CardView>


FILE: app\src\main\res\layout\dialog_tracking_modern.xml

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="260dp"
    android:layout_height="wrap_content"
    android:layout_gravity="center"
    android:orientation="vertical"
    android:padding="12dp"
    android:background="@drawable/dialog_tracking_background"
    android:elevation="8dp">

    <!-- Progress Bar -->
    <ProgressBar
        android:id="@+id/progressBar"
        style="?android:attr/progressBarStyleHorizontal"
        android:layout_width="match_parent"
        android:layout_height="4dp"
        android:layout_marginBottom="12dp"
        android:indeterminate="true" />

    <!-- Tracking Info Row -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:layout_marginBottom="4dp">

        <!-- Vreme -->
        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="VREME"
                android:textSize="10sp"
                android:textColor="#80FFFFFF"
                android:textStyle="bold" />

            <TextView
                android:id="@+id/tvDialogTime"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="00:00"
                android:textSize="16sp"
                android:textColor="#FF333333"
                android:textStyle="bold" />
        </LinearLayout>

        <!-- Udaljenost -->
        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="UDALJENOST"
                android:textSize="10sp"
                android:textColor="#80FFFFFF"
                android:textStyle="bold" />

            <TextView
                android:id="@+id/tvDialogDistance"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="0 m"
                android:textSize="16sp"
                android:textColor="#FF333333"
                android:textStyle="bold" />
        </LinearLayout>

        <!-- Brzina -->
        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical"
            android:gravity="center">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="BRZINA"
                android:textSize="10sp"
                android:textColor="#80FFFFFF"
                android:textStyle="bold" />

            <TextView
                android:id="@+id/tvDialogSpeed"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="0.0 km/h"
                android:textSize="16sp"
                android:textColor="#FF333333"
                android:textStyle="bold" />
        </LinearLayout>
    </LinearLayout>

    <!-- Status -->
    <TextView
        android:id="@+id/tvStatus"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Tražim GPS signal..."
        android:textSize="12sp"
        android:textColor="#FF333333"
        android:gravity="center"
        android:layout_marginTop="4dp" />

</LinearLayout>


FILE: app\src\main\res\layout\dialog_tracking_started.xml

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="24dp"
    android:background="@drawable/dialog_background_modern">

    <!-- Animirana ikonica -->
    <ImageView
        android:layout_width="64dp"
        android:layout_height="64dp"
        android:layout_gravity="center"
        android:src="@drawable/ic_gps_animated"
        android:contentDescription="GPS" />

    <!-- Poruka -->
    <TextView
        android:id="@+id/tvMessage"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:text="Snimanje rute je pokrenuto!"
        android:textColor="@color/text_primary"
        android:textSize="16sp"
        android:textStyle="bold"
        android:gravity="center"
        android:lineSpacingExtra="4dp" />

    <!-- Progress bar -->
    <ProgressBar
        android:id="@+id/progressBar"
        android:layout_width="match_parent"
        android:layout_height="4dp"
        android:layout_marginTop="16dp"
        android:indeterminate="true"
        android:progressTint="#3498DB"/>

    <!-- Stats preview -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:orientation="horizontal"
        android:gravity="center">

        <TextView
            android:id="@+id/tvInitialStats"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="?? Lokacija: Aktivna\n? Brzina: 0 km/h"
            android:textColor="@color/text_secondary"
            android:textSize="12sp"
            android:gravity="center" />

    </LinearLayout>

</LinearLayout>


FILE: app\src\main\res\layout\item_user.xml

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp"
    android:background="@drawable/card_dark_blue"
    android:layout_margin="4dp">

    <TextView
        android:id="@+id/tvUserEmail"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="email@example.com"
        android:textColor="@color/white"
        android:textSize="16sp"
        android:textStyle="bold" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical">

        <TextView
            android:id="@+id/tvUserRole"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Basic"
            android:textColor="@color/blue_primary"
            android:textSize="14sp" />

        <TextView
            android:id="@+id/tvUserDate"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="01.01.2024"
            android:textColor="@color/white"
            android:textSize="12sp"
            android:alpha="0.7" />

    </LinearLayout>

</LinearLayout>


FILE: app\src\main\res\layout\tracking_panel_modern.xml

<?xml version="1.0" encoding="utf-8"?>
<androidx.cardview.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/trackingPanel"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="16dp"
    android:visibility="gone"
    app:cardBackgroundColor="#E6101E2E"
    app:cardCornerRadius="20dp"
    app:cardElevation="8dp"
    app:contentPadding="8dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">

        <!-- Header -->
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="?? Snimanje Aktivno"
            android:textColor="#FF4CAF50"
            android:textSize="16sp"
            android:textStyle="bold"
            android:gravity="center"
            android:layout_marginBottom="12dp" />

        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="#334CAF50"
            android:layout_marginBottom="12dp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:weightSum="3">

            <!-- Brzina -->
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:orientation="vertical"
                android:gravity="center"
                android:padding="8dp">

                <TextView
                    android:id="@+id/tvSpeed"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="0.0"
                    android:textColor="#FFFFFF"
                    android:textSize="24sp"
                    android:textStyle="bold" />

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="km/h"
                    android:textColor="#88FFFFFF"
                    android:textSize="12sp" />

            </LinearLayout>

            <!-- Udaljenost -->
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:orientation="vertical"
                android:gravity="center"
                android:padding="8dp">

                <TextView
                    android:id="@+id/tvDistance"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="0.0 m"
                    android:textColor="#FFFFFF"
                    android:textSize="20sp"
                    android:textStyle="bold" />

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Udaljenost"
                    android:textColor="#88FFFFFF"
                    android:textSize="12sp" />

            </LinearLayout>

            <!-- Vreme -->
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:orientation="vertical"
                android:gravity="center"
                android:padding="8dp">

                <TextView
                    android:id="@+id/tvTime"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="00:00"
                    android:textColor="#FFFFFF"
                    android:textSize="20sp"
                    android:textStyle="bold" />

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Vreme"
                    android:textColor="#88FFFFFF"
                    android:textSize="12sp" />

            </LinearLayout>

        </LinearLayout>

        <!-- Progress bar za taènost -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:layout_marginTop="8dp"
            android:padding="4dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Taènost:"
                android:textColor="#88FFFFFF"
                android:textSize="10sp" />

            <ProgressBar
                android:id="@+id/accuracyProgress"
                android:layout_width="0dp"
                android:layout_height="4dp"
                android:layout_weight="1"
                android:layout_marginStart="8dp"
                android:progress="100"
                android:progressTint="#FF4CAF50"
                style="?android:attr/progressBarStyleHorizontal" />

            <TextView
                android:id="@+id/tvAccuracy"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="100%"
                android:textColor="#88FFFFFF"
                android:textSize="10sp"
                android:layout_marginStart="8dp" />

        </LinearLayout>

    </LinearLayout>

</androidx.cardview.widget.CardView>


FILE: app\src\main\res\mipmap-anydpi-v26\ic_launcher.xml

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>


FILE: app\src\main\res\mipmap-anydpi-v26\ic_launcher_round.xml

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>


FILE: app\src\main\res\values\colors.xml

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Dark Blue Theme (iCar GPS Style) -->
    <color name="primary_dark">#FF1565C0</color>      <!-- Tamno plava -->
    <color name="primary_darker">#FF0D47A1</color>    <!-- Tamnija plava -->
    <color name="primary_medium">#FF1976D2</color>    <!-- Srednje plava -->
    <color name="accent_green">#FF4CAF50</color>
    <color name="accent_red">#FFF44336</color>
    <color name="text_primary">#FFFFFFFF</color>
    <color name="text_secondary">#FFB3E5FC</color>    <!-- Svetlo plava -->
    <color name="card_dark">#FF1E88E5</color>         <!-- Plava za kartice -->

    <!-- Transparent Colors -->
    <color name="transparent_dark">#801E88E5</color>  <!-- Polu-transparentno plava -->

    <!-- Original Colors (za kompatibilnost) -->
    <color name="blue_primary">#FF2196F3</color>
    <color name="blue_dark">#FF1976D2</color>
    <color name="blue_light">#FFBBDEFB</color>
    <color name="blue_light_background">#FFE3F2FD</color>
    <color name="blue_very_light">#FFE1F5FE</color>
    <color name="green">#FF4CAF50</color>
    <color name="red">#FFF44336</color>
    <color name="orange">#FFFF9800</color>
    <color name="purple">#FF9C27B0</color>
    <color name="yellow">#FFFFEB3B</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="gray">#FF9E9E9E</color>
    <color name="gray_dark">#FF424242</color>
    <color name="gray_light">#FFEEEEEE</color>
    <color name="green_active">#FF4CAF50</color>
    <color name="transparent">#00000000</color>
    <color name="semi_transparent_white">#80FFFFFF</color>
    <color name="semi_transparent_black">#80000000</color>
    <color name="card_light">#FFFFFFFF</color>
    <color name="primary_blue">#3498DB</color>
    <color name="modern_dark_blue">#FF1E2E3E</color>
    <color name="accent_orange">#FFFF9800</color>
    <color name="transparent_white">#88FFFFFF</color>

</resources>


FILE: app\src\main\res\values\dimens.xml

<resources>
    <!-- Dodajte ovo ako veæ ne postoji -->
    <dimen name="tracking_dialog_margin_top">100dp</dimen>
</resources>


FILE: app\src\main\res\values\ic_launcher_background.xml

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#FFFFFF</color>
</resources>


FILE: app\src\main\res\values\strings.xml

<resources>
    <string name="app_name">GPS Tracker PRO</string>
    <string name="maplibre_access_token">your_token_here</string>
    <string name="time_label">VREME</string>
    <string name="distance_label">UDALJENOST</string>
    <string name="speed_label">BRZINA</string>
    <string name="searching_gps">Tražim GPS signal...</string>
</resources>


FILE: app\src\main\res\values\styles.xml

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">

    <!-- Base application theme. -->
    <style name="Base.Theme.GpsTrackerDs" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/blue_primary</item>
        <item name="colorPrimaryDark">@color/primary_dark</item>
        <item name="colorAccent">@color/accent_green</item>
    </style>

    <style name="Theme.GpsTrackerDs" parent="Base.Theme.GpsTrackerDs" />

    <!-- Modern Alert Dialog -->
    <style name="ModernAlertDialog" parent="Theme.AppCompat.Light.Dialog.Alert">
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:backgroundDimAmount">0.7</item>
        <item name="android:windowIsFloating">true</item>
        <item name="android:windowContentOverlay">@null</item>
    </style>
    <style name="TransparentDialogTheme" parent="Theme.AppCompat.Dialog">
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:windowIsTranslucent">true</item>
        <item name="android:windowNoTitle">true</item>
        <item name="android:backgroundDimEnabled">false</item>
        <item name="android:windowContentOverlay">@null</item>
    </style>

</resources>


FILE: app\src\main\res\values\themes.xml

<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Base.Theme.GPSTrackerDS" parent="Theme.Material3.DayNight">
        <!-- Customize your theme here. -->
    </style>

    <style name="Theme.GPSTrackerDS" parent="Base.Theme.GPSTrackerDS" />
</resources>


FILE: app\src\main\res\xml\backup_rules.xml

<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <include domain="file" path="." />
    <include domain="database" path="." />
    <include domain="sharedpref" path="." />
</full-backup-content>


FILE: app\src\main\res\xml\data_extraction_rules.xml

<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="file" path="." />
        <include domain="database" path="." />
        <include domain="sharedpref" path="." />
    </cloud-backup>
    <device-transfer>
        <include domain="file" path="." />
        <include domain="database" path="." />
        <include domain="sharedpref" path="." />
    </device-transfer>
</data-extraction-rules>


FILE: app\src\main\res\xml\file_paths.xml

<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="external_files" path="." />
    <external-files-path name="external_files_path" path="." />
    <files-path name="files_path" path="." />
    <cache-path name="cache_path" path="." />
</paths>


FILE: app\src\main\res\xml\network_security_config.xml

<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="true">
        <trust-anchors>
            <certificates src="system" />
            <certificates src="user" />
        </trust-anchors>
    </base-config>
</network-security-config>


FILE: app\src\test\java\jovannedeljkovic\gps_tracker_pro\ExampleUnitTest.kt

package jovannedeljkovic.gps_tracker_pro

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}


FILE: gradle\wrapper\gradle-wrapper.properties

#Wed Nov 05 13:47:39 CET 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



